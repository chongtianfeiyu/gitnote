#极限编程
也叫敏捷开发。就是针对于小项目，不会从头一步一步地来，而是迅速开始，先在数据库中建立几张表，然后迅速将项目作出一个雏形。简化项目的规模，予以实现，演示。一般而言，项目的大小可以依据后端数据库的表的数目多少来进行衡量。  

#数据结构基础
数据结构一般有以下几种：  
1. 线性表：包括数组与链表。  
2. 栈、队列、串。  
3. 树、二叉树等。  
4. 图  
5. 映射表：Map

#传递多个参数的时候，要传递可变参数，而不是传递一个数组。原因是，传递可变参数时，即使是没有参数，在方法里面使用的时候不会报空指针异常。但是如果是使用数组，那么在方法里面就会可能报空指针异常。

#Java基础知识
---
1. `Java`源代码->`.class`文件（字节码）->机器码(二进制码)  
源代码与`.class`文件(字节码)之间是`Java`编译器(`JDK`)，字节码与机器码之间是`JVM`(`Java`虚拟机)
2. `Java`中，`applet`是用于在浏览器段运行的程序，`servlet`是用于在服务器端运行的程序。因此，`applet`相当于`javascript`运行在浏览器段。`servlet`相当于`PHP`运行在服务器端。`Java`对服务器端与浏览器端都进行了扩展。
3. `Node.Js`就是在服务器端运行JS代码。
4. 
`Java se`:桌面应用

`Java ee`：企业应用

`Java me`：移动应用

         javac                  java
`Java`源代码->二进制代码（平台无关）->`linux`(`windows`)机器码
         编译器                   JVM 

如果只运行`Java`程序，安装`JRE`即可。如果编译`Java`程序，那就还需要安装`JDK`。
>
	JDK=JRE+.java文件被编译时所需的一些类库
    JRE=JVM+.class文件运行时所需的一些的库

实际安装中，其实`JDK`中本来就带有`JRE`，所以不用另外安装公共`JRE`。安装`JDK`即可。

`Java/Bin`目录：`Java`提供的各种工具，如`javac` ，`javap`等

在安装`JDK`设置环境变量的时候。`Path`中加入的是`JDK`的`bin`目录路径。  
这个路径下面是各种`java`工具。系统会在这些路径下查找我们所需要的工具。这个路径是给`shell`使用的。

还有一个`classpath`路径，这个路径的作用：当我们使用使用`java`运行二进制文件的时候，如果没有指定二进制文件`(.class)`的绝对路径的时候，会去这个`classpath`中查找对应名字的文件。同样，在我们的源程序中`import`了`JDK`中的某一个类的时候，也是去`classpath`所指的目录中查找需要的编译后`.class`文件的。这里就要在`classpath`中加入`JDK`的`lib`路径。使用`JDK`中给我们写好编译好的各种类。  
这个路径是给`JVM`使用的。

`Java`中数据类型有：  
1. 基本数据类型：`int`、`double`等。  
2. 类型：数组/类/接口/枚举类型。

#Java中基本数据类型
--------------
1. 整型：`int（4）`、`short（2）`、`long（8）`、`byte（1）`。表示整数。由于`JVM`的存在，使得在不同的机器平台上的`Java`程序的数据类型所占内存空间是一样大的。解决了移植性的问题。长整型数据后缀L。十六进制前缀0X，八进制前缀0。注：`Java`中没有无符号数。

2. 浮点数：`float（4）`与`double（8）`。表示小数。`float`数后缀F，没有后缀默认`double`，也可以后缀为D。注：很少使用`float`，都是使用`double`。

4. `char`类型：用于表示单个的字符。表示字符常量。“”与‘’是不同的，‘’里面的表示这是一个`char`字符，而“”表示这里面的是一个带有字符的字符串，即使只有一个字符也是字符串。二者是不同的。`\u`转义表示这是一个`Unicode`字符。最好不要使用`char`类型，而是使用抽象数据类型-字符串类型。这样有利于操作。

4. `boolean`类型：注：`Java`中数值0不能代表`false`，非0也不能代表`true`。

#Java中的数组
-------
大数值：`java.math`包中有两个类`BigInterger`和`BigDecimal`来处理任意长度的数字序列。  
`Java`中没有提供运算符重载功能。

数组：
> 
	int[] a=new int[100];
	或者 int[] a=new int[]{1,2,3};

以下方法都需使用`java.util.*`包。这些都是针对数组这个结构的`static`方法。  
`Arrays`这个类：它的作用就是操作数组这个类型的工具类。里面都是各种`static`方法，针对于数组这个类型的。  
Arrays类中的方法：  
>
数组拷贝：  
1. 数组引用变量的拷贝，使两个数组变量指向同一个数组。  
2. 数组元素的拷贝，也就是制造两个数组。使用`Arrays.copyOf()`这个`static`方法。
>
	int[] b = new int[]{1,2,3};
	int[] a = Arrays.copyOf(b);//将b数组拷贝到a数组中。
>
数组排序：  
使用`Arrays.sort()`这个静态方法。这是一个快速排序法。
>
返回数组中数据元素的字符串形式：  
使用`Arrays.toString()`静态方法。
>
二分查找法：  
`Arrays.binarySearch()`静态方法。

二维数组：
>
	int[][] bal=new int[][]
	{
		{1,2,3},
		{4,5,6},
	};

遍历二维数组每一个元素：
>
	Arrays.deepToString()静态方法。

实际上对多维数组进行操作都要使用`deep`开头的方法。

实际上`Jav`a中没有多维数组，本质就是数组的数组。  
`bal`数组实际上包含两个元素的数组，每个元素由三个元素组成。`bal[1]`引用的是二维表的第i行。这一行本身就是一个数组。  
为每一行分配元素的时候：
>
	bal[2]=new int[3];将这一行当做一个元素。这样可以创建不规则数组。
>
	int[][] a=new int[10][];
	for( int n=0;n<10;n++)
	{
		a[n]=new int[n+1];
	}
或者直接：
>
	int[][] a=new int[][]{{1,2,3},{1},{2,3}};
这样创建的是一个三角形的不规则数组。不规则数组就是Java语言和其他语言的不同。

输出的时候:
>
	for (int m=0;m<a.length;m++)
		for (int k=0；k<a[m].length;k++)

这样即可遍历。

或者使用foreach:
>
	for (int[] row :a)
		for (int m:row)

这样亦可。

在java里面，数组也是一个和int、类这些东西同级的类型。他可以用于创建一个数组引用变量，也可以用于类型的转换，和所有的基本数据、类都是一模一样的。  
所有的数组都是在其他的类型后面加上[]即变为数组类型。如：  
`String[]`就是一个数组类型。`int[]`数组类型后面加上`[]`就变成了`int[][]`这个数组类型.  
数组类型变量本质就是引用类型，实际上就是指针。数组引用本来就是一个变量。

所以，写数组的时候必须写成：`int[]`,而不要是`int a[]`;  

`Java`语言是静态语言，就是说，一旦变量类型确定，就不能再修改，也就是说变量内存空间大小也不能修改了。那么`jav`a中数组的长度是不能改变的，一旦初始化完毕就恒定了。空间是固定下来的，即使元素被清空，其空间依旧保留，可以被别的元素占用。

数组类型变量只是一个指针，如果没有将它引用到一个数组对象，那么就不能直接使用这个数组变量。也就是说数组变量必须指向一个有效的内存，也就是必须进行**初始化**。  
初始化两种：
>
静态初始化：
>
	int[] a=new int[]{1,2,3};//这就是静态初始化，后一个[]里面不能设置长度，因为后面的{}里面已经确定数组长度了，是一个固定的长度了，也就是数组对象定义的时候就已经静态化它的长度了。指定了数组的元素，让系统判断数组长度。
动态初始化：
>
	int[] a=new int[3];//只指定数组的长度，不指定数组的元素。后面再进行数组元素的初始化。

总之，不能即指定数组长度又指定数组元素:
>
	int a=new int[3]{1,2,3};//这是错的。因为是没有必要的。

在数组初始化之后，每一个数组元素都可以作为基本数据变量或者引用类型变量使用。
数组的使用：  
1. 数组的`length`属性，返回数组长度。


#Java中字符串类型
---------------
1、和`char`不同，这是字符串类型。不是`char`那样的基础数据类型。使用双引号。是一个类。而不是基础数据。
>
	String Str=“hello”；//这是一个字符串。
	char c=‘a’；//这是一个字符。

获得子串：`substring()`方法；
>
	String substr=Str.substring(1,3);//从字符串Str中取一个子串。

拼接：“+”；
  
`String`对象中的单个字符是不能修改的，也就是说，没有函数可以直接修改一个字符串中的某一个字符。  
如：  
`String Str="hello"；`  
修改为`"hellp"`的方法有两个：  
`Str="hellp";`或者`Str.substring(0,3)+"p";`而没有一个方法直接将最后一个字符进行修改。
这就是不可变字符串。
  
字符串相等比较，要使用`equals()`或者`equalsIgnoreCase()`而不是`==`  
因为：`equal()`是比较字符串是否一样的。而`==`是比较两个字符串在内存中的位置是否相等（也就是`String`对象的引用变量是否相等）。当两个字符串是一样的，但是位于内存的不同处，这样使用`==`判定就会是`false`。因为内存位置不同。  
如：
>
	String Str=“hello”；
	if（Str==“hello”）//比较的是Str这个字符串变量指向的字符串的位置是否与后面的“hello”字符串所在的内存位置是一样的。判断会失误。

误区：关于string缓存机制
>
	String s1=new string（“hello”）；
	String s2=new string （“hello”）；//s1！=s2；因为new创建了不同的对象，s1与s2指向不同的对象。
>
	String s3=“hello”；
	String s4=“hello”；//s3=s4；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s4的时候，不再创建新的字符串对象，而是使用s3的字符串对象。

同理：
>
	String s5=“hello”；
	String s6=“he”+“llo”；//s5=s6；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s6的时候，二者字符串一样。所以不再创建新的字符串对象，而是使用s5的字符串对象。

但是缓存只对于常量有用，也就是说，只会对`"hello"`这样的有缓存。对于`string s1="hello"`
这样的，下一次使用`s1`是不能使用缓存的，只有使用`"hello"`的时候才是使用上次的缓存。
>
	String s=“good”；
	String s2=s；//没有使用缓存；
	String s3=“good”;//使用了第一次的缓存。

注：使用缓存的意思就是：他们所指向的空间是一样的。

误区：关于`java`的宏替换
`final`修饰的变量会执行“宏替换”：
如果`final`修饰的变量在编译的时候就可以确定它的值（什么叫在编译的时候就知道它的值？  
如：
>
	String s="hi";  
这就是在编译的时候知道`s`的值。什么叫在运行的时候知道它的值？
如：
>
	String s1="hi";
	String s2=s1;  
那么，`s1`在编译的时候就知道它的值，而`s2`直到运行的时候才知道它的值。），那么，这个变量实际上是不存在的。而是在以后使用这个变量的时候直接执行“宏替换”。
这句话的意思就是：`final`修饰的变量如果赋予了初始值，而且这个初始值在编译的时候就已知，那么在内存中根本就不存在这个`final`变量，而只有它所指向的空间存在。以后使用的时候，是直接用这个初始值直接进行宏替换。
如：
>
	final string s3="hello";
	String s4=s3;  
这段代码中，变量`s3`并不存在，在`s4`语句中，需要用到`s3`，就是在编译到`s4`的时候直接执行宏替换，将`"hello"`置换到`s4`指向的空间中。也就是说，编译的时候，`s4`的值就已知（相当于直接在`s3`的位置放上`"hello"`）导致`s4`编译的时候就知道它的值。而且连`"hello"`这个对象也不存在，因为前面的引用变量`s3`已不存在了，所以再创建出对象也没有意义.  
而在前例中，`s2`的值在编译的时候是未知的，直到运行的时候才知道。这就是`final`修饰的一个`feature`。
总之，如果`final`变量已初始化，且在编译的时候就知道其值，那么这个变量不存在了，变量所引用的对象也是不存在的。变量都不存在了其引用对象就没有存在的必要了。
`final`成员变量定义时的赋值、初始化块中的赋值都不会插入到构造函数最前面，因为`final`成员变量在编译是已知其值，则该变量不存在。无`final`的一般成员变量都会插入到构造器中。
同理，`static`的`final`成员变量的定义时赋值也不会被插入到`static`初始化块中。无`final`的`static`的成员变量都会被插入到`static`初始化块中。

所谓的宏替换：就是查找、替换。

要注意：宏替换变量应该使用大写单词表示，且由多个单词连接而成，各个单词之间以下划线分隔。
>
	Final String s1=“hi”；
	Final String s2=“hello”；
	Final String s3=s1+s2；

这里创建了1个对象（`"hihello"`），但是只有0个变量，`s1`、s2``、`s3`这3个变量不存在。因为是`final`的，且编译时值已知。
#Java中变量
---------
基本数据类型的变量：
>
	int a=5；//这个5直接放置在a这个变量中，a就是基本类型变量。

引用变量：
引用变量中并不是放置着具体的内容数据，而是其引用的数据的地址。这就是引用变量。当然指针本身也是变量，放在栈中。指针所指向的内容放在堆中。

变量的声明，如:
>
	int a；
	double b；
变量声明之后，必须使用赋值语句进行初始化，编译器不会自己给它赋值的，这一点和`C`不同。没有自己初始化使用就会导致问题。`Java`中不区分变量的声明与定义。
`Java`中使用`final`声明常量。使用大写。且这个量只能被赋值一次。不能修改。
`Java`中如果要使一个常量可以被一个类中的所有方法共同使用，称之为类常量，这个量的大小不能修改，属于整个类。使用`static final`进行设置。
>
	static final int a=10；这个值被所有的对象所有的方法使用，且不能修改。

这个不同于单纯的`static`成员变量。这个`static`变量只是属于整个类。但是不能保证不变。

成员变量：在类中定义。
属于类的成员变量：`static`
属于对象的成员变量：无`static`
在某个方法中建立一个对象的时候，对象本身在堆中，对象的引用在栈中。
系统加载一个类，就为这个类开辟一块空间。只加载一次。
建立对象的时候，会为成员变量进行初始化。

局部变量：局部变量就是在方法中定义的变量，储存在方法栈中，必须由程序员进行初始化。不能用`static`进行修饰。局部变量不允许重名。
方法中的局部变量，作用域仅在方法中。
代码块中的局部变量，仅在代码块中有效。  
代码块：如，某个方法里面有一个括号，括号中内容就是一个代码块。代码块就是一个花括号。
形参：在整个方法中有效。

`Java`中没有所谓的全局变量的说法。


#Java中的运算符
--------
数据的左右移位：>>与<<
在没有数据溢出的情况下，左移n位就是乘以2的n次方。右边空的地方补上0；
右移没有溢出问题。相当于右边去掉n位。右移n位就是在左边的空地方补上符号位，正数补上0，相当于除以2的n次方，然后舍去小数部分。负数就是补上1，相当于除以2的n次方，然后将小数部分补成整数。结果都比算术意义上的数小。
数字以最快的速度乘以8，就是左移3位即可。这就是提高效率的方法。

数据的无符号右移：>>>:无论数据的正负，右移都是在数据左边空地方补上0，一直补0；会将负数变为正数。


Java中基本数据之间的转换
-----
基本数据之间的转换不涉及向上或者向下造型。而是其单独独立的转换方法。
其中6个实心箭头，表示小空间向大空间转换，转换无信息丢失。3个虚箭头，表示可能有信息丢失。
基本数据类型之间的转换有两种:

一种是无信息丢失的转换，这种转换称为自动转换。例如：`int a=10；double b=a；`这样使用a这个int来初始化b这个double是一种类型自动转换。

第二种是有信息丢失的转换，这种转换称为强制转换。例如：`double a=10.58；int b=（int）a；`这样使用a这个double来初始化b这个int，由于是大空间向小空间的转换，所以需要使用强制类型的转换。当然会有空间精度的损失。截断小数部分(不是四舍五入）。

注，此处，如果想获得一个浮点数的四舍五入的结果，就使用`Math.round()`这个方法，获得的是一个long整型数据，如果要变成int型数据，这就需要强制类型转换。也就是`int b=(int)Math.round(a);`也会有精度丢失的问题。

Java中输入输出
-----------------
A、键盘输入：

输入使用`Scanner`类对象进行。涉及密码输入时使用`Console`类对象进行（不显示密码）
系统里，`System.in`代表键盘。如果直接使用这个会很麻烦，一般都会对其进行包装：
包装成`BufferedReader`，这个更安全，而且有更完善的异常机制。
JDK1.5之后，出现`Scanner`，这个更方便，但在异常机制上有不足。

>
	Scanner sr = new Scanner(System.in);//这样就将键盘这个对象包装成Scanner类对象。
	while(sr.hasNextLine())//判断是否还有下一行输入。同理还可以判断是否有下一个字符的输入
	{
		System.out.println(sr.nextLine());
	}

注：多线程最困难的地方就是：出错难以调试。因为线程调用是随机的。

B、屏幕输出：
>
	System.out.println（）方法即可输出。


文件输入与输出：

A、文件读入：
读取文件的时候，使用一个`file`对象构造出一个`Scanner`对象。
这样就将一个文件内的内容读入到内存中了。
>
	Scanner in=new Scanner（new file（“myfile.txt”））；

如果文件路径中有“\”，那么需要使用转义字符。
>
	Scanner in=new Scanner（new file（“C:\\myfile.txt”））；

这样才行。`in`这个输入流中就是这个文件中的内容。然后就可以使用`Scanner`这个类的方法对这个输入流进行读取了。

B、文件写入：
>
	PrintWriter out = new PrintWriter(“myfile.txt”);//将写入流对象与文件相连接。

定位文件时可使用绝对路径:
>
	C:\\myfile\\myfile.txt;或者/home/me/myfile.txt;

当然，流最后都需要关闭。
>	
	out.close（）；


注：输入流就相当于一个管子。管子本来是空的。实际上就是表示在内存中的内容。
输入流对象这个管子里面是什么需要内容与外界的输入进行连接，这个流对象在哪里显示需要与外界的显示输出连接起来。也就是说，一个流就是内存中的一块空间。需要在两端与外界连接。这才是流的特征，有来源有出口。

和控制台的输入相连接：
>
	Scanner in=new Scanner(System.in)；//这是将输入流对象in与系统控制台输入进行连接。
	Console inc=System.console();//这是将输入流对象inc与系统密码输入相连接。

与控制台的输出相连接：
>
	String name=in.nextLine();//将输入流对象与name这个输出的东西进行连接。	

任何一个输入、输出流对象都需要在两端进行连接，然后就可以使用。只不过流对象的功能不同。各种不同的流对象都是针对不同的两端的内容的。两端内容不同，使用不同的流对象。

Java中的块，一个变量的有效范围就是一个块。但是嵌套的块中，变量不会覆盖块外的变量，这一点和C++不同。



Java中的语句
-------

选择语句：
>
	if（）……else if（）……else……
多重选择：
>
	switch（）case1：……break；case2：……break；default：……；一般很少使用switch。

循环语句：
>
不确定循环：
>
	while（）……do……；do……while（）；
确定循环：
>
	for循环，for循环是支持迭代的通用结构。利用每次迭代之后更新的计数器或者类似的变量来控制迭代次数。

>
Foreach 循环：
>
	for（variable：collection）statement；

Java类之间的关系
-----------

1、依赖（use a）：一个类的方法中操作了另一个类的对象，这就是依赖的关系。例如类A的某个方法中使用了B类对象作为局部变量，这就是依赖。
应该将互相依赖的类减至最少。这就是使A类不知道B类的存在，意味着B类的改变不会导致A类产生bug。这样就是让类之间的耦合度减小。

2、聚合（has a）：一个类A中的成员变量包括B类对象，这就是聚合关系。也就是A类对象包含B类对象。

3、继承（is a）：A类由B类继承而来。特殊与一般的关系。包含B类中的方法。


Java中的引用
---------
java中的引用类似与C++中的指针。

一个java源程序中，只能有一个`public`类（也就是只能是`main`那个函数所在的类是`public`，其他的所有类都不能）。但可以有任意个非`public`类。


Java中的编译与文档生成、汇编
------------------------
java编译：  
java中可将各个类放在不同的源文件中，如:`test.java`与`testdrive.java`.
在编译的时候，如果一个java源文件中具有两个类，那么就会编译产生两个`.class`文件。
这样编译的时候，可以使用通配符：
>
	javac test*.java

这样所有的文件都被编译成`.class`文件。

编译`public`类文件:
>
	javac testdrive.java

这样编译器会先导入`testdrive`类，然后自动搜索需要的类，在编译的时候，会首先查找`test.class`文件，如果没有就会查找`test.java`文件并编译它。如果`.java`文件比`.class`文件新，就会重新编译`.java`文件。这就相当于java编译器内置了make工具。

相对路径：不以盘符开始的路径。不唯一的。所以要使用相对路径就需要在一个基础路径才可以。相对路径的基础路径就是当前路径，就是现在操作的路径。
绝对路径：以盘符开始的路径。唯一的确定的。

javac命令用于编译；
java命令用于运行；
javadoc命令用于从源文件中提取文档注释以生成**API**文档：
命令：
>
	javadoc -d 生成API放置目录路径 java源文件； 

然后去**API**文档目录中查看`index.html`文档即可。

javac将程序编译都一个文件夹中需要先自己创建一个文件夹。这个文件夹对应整个工程。里面的都是一个个程序编译出来的包（package），package放在这个自己创建的文件夹中(这个工程的文件夹）。

也可以不直接创建一个文件夹：而是编译时使用：
>
	javac -d .\ java源文件  // .\表示放在本目录下创建文件夹。文件夹中的包和源文件中的package层次相对应


但是javadoc提取**API**是不需要自己创建一个对应文件夹的，程序会自己创建一个。


javap 命令的使用：
>
	javap -c 类名：

java中的反射库：用于产生程序执行过程的汇编代码。

java的return
----------
访问器方法的`return`不能是可变变量的引用。  
因为返回可变变量的引用之后，就会导致以这个访问器方法做左值的时候，就会在类外修改了类的`private`成员变量的值。这就破坏了封装原则了。
那么访问器`return`的时候，应该返回可变变量的`clone()`才行。或者返回`final`变量。

java中final关键字
-----------------
1、`final`修饰变量（*成员变量*（类拥有变量与实例拥有变量）与局部变量（方法内局部变量与块内局部变量））  

`final`修饰符大部分用于基本数据类型，或者不可变类的域（类中的每一个方法都不改变该成员变量）。如果是用于一个类成员变量（也就是非基本数据类型成员变量），就会导致混乱，因为在一个类中使用`final`类成员变量，只说明这个类成员变量的引用是不变的，而不说明这个对象本身时不变的，只是引用不变而已。
所以`final`修饰符最好不要使用在非基本数据类型成员变量上。
`final`成员变量表示这个变量是不能被修改的。

A、`final`修饰成员变量
必须人工进行初始化，初始化的位置：
定义成员变量时、
初始化块（普通初始化块与`static`初始化块）、
构造函数。

普通方法不允许为`final`成员变量赋值。`final`成员变量只能在以上三个位置进行初始化且只能在一个地方赋值。因为他们前两个实际上都是插入到构造器中来发挥作用的，所以三者都是平等的地位。都可以对`final`成员进行初始化。

B、`final`修饰局部变量	
必须人工初始化，无论是否是`final`局部变量。
局部变量加了`final`之后，以后再也不能修改其值了。

要注意`final`变量的工作方式与普通变量是不同的，见java中字符串类型中说明的`final`变量的工作原理。

2、`final`修饰符用于类方法或者整个类，表示这个类或者方法不能被继承或重写了。  
非`final`类中可有非`final`方法和`final`方法，其中的非`final`方法可有被继承重写。但是`final`方法不能被重写。  
`final`类中所有的方法都是默认为`final`的，也就是说，`final`类中所有方法都不可被重写。但是不说明那些成员变量是`final`的（`final`成员变量表明成员变量不变）。
也就是说`final`成员变量可以设置为`public`，因为它已不能被修改了，为一常量。

Java中static关键字
-----------------
`static`就是一个标志，不是什么静态的意思。  
`static`成员变量和`static`成员方法还有`static`初始化块。与类共存亡。  
`static`成员变量属于整个类，所有对象共享。`static`成员变量可以在声明定义的时候即赋值，也可以在`static`代码块中进行赋初值，但是不能在构造函数中赋初值。  
如果是`final static`常量，能在成员常量定义的时候赋初值。也能等到在`static`初始化块里面赋初值。因为最终也是要插入到`static`初始化块的。    
`static`成员变量使用的较少。但是`static`成员常量用的较多，也就是`static final`成员常量。全类共享，且不变。  
`static`成员方法是不能对对象进行操作的，只能对类共享的成员变量进行操作。不需要对象，也就是`static`方法没有`this`这个隐藏参数。  
以下两种情况下需要使用`static`成员方法。  
1. 当这个方法不需要使用对象的状态的时候，也就是这个方法的所有的参数都是显式提供的，而不需要隐式提供的`this`。  
2. 这个方法只需要访问类的`static`成员变量，不需要访问非`static`成员变量。当有类但是没有创建对象的时候，可以通过类直接使用`static field`或者方法。

静态方法的还有一个用处就是：`Factory`方法。用于产生不同风格的格式对象。

在同一个类中：
`static`成员不能访问非`static`成员（包括成员变量与方法）。  
`this`、`super`都不能出现在`static`成员中（如，不能出现在`static`方法中）；
这里的`static`成员包括：`static`方法、`static`初始化块、`static field`但不包括构造器（也就是说，`static`成员可以调用所有的构造器，因为构造器根本就没有`static`修饰这回事儿）。
也就是说，`static`初始化块里面都不能出现属于实例的非`static`的东西。  
总之一句话，类拥有的东西不能碰对象拥有的东西，也就是说，抽象、集体的东西不能碰具体、个人的东西。但前提是：在同一个类中。
>
	Static main方法都不能访问同一个类中的非static field。
	Public class m
	{
		int a=10；
		Public static void main（String[] args）
		{
		System.out.println（a）;//这是错的，在同一个类中，本类的static成员不能访问本类的非static成员。
		}
	}
`static`的东西在导入这个类的时候即导入。是最先导入的。  
`main`方法也是一个`static`方法。
任何一个类都可以拥有它自己的main方法，这是常用的对类进行单元测试的技巧。
如果要单元测试这个类，可以直接`javac employee`即可。这样就会执行`employee`这个类的`main`方法。

Java中abstract关键字
------------------
`abstract`类：  
`abstract`类特点：有得有失  
得：可以拥有抽象方法。因为普通类中不能有抽象方法，只有抽象类中才可以有抽象方法。所以，一个类中有了抽象方法就一定是抽象类。  
失：不能创建实例。  
误区：  
1. 其他的和普通方法都是一样的。同样有各种`field`（`static`与非`static`），各种构造器，各种初始化块（`static`与非`static`的）。  
2. 抽象类可以没有抽象方法。但这种抽象类依旧不能创建实例。

但是，既然抽象类无法创建实例，那么，我们还需要抽象类的实例方法、变量（非`static`方法与非`static`成员变量）和构造器干什么？  
Answer：  
1、抽象类的构造器是用于供其子类调用以进行父类成员变量的初始化。  
2、抽象类的各种非`static`成员方法是用于被子类重写(`override`)。或者被子类直接调用(直接使用`super`即可)。非`static`成员方法中，抽象成员方法用于被子类重写。非抽象成员方法用于被子类调用（父类、子类都拥有这些方法）。

`abstract`方法:  
说明这个方法既不能被本类调用又不能被本类的实例调用，只是占了一个坑，留给子类来填。使用`abstract`修饰，且没有方法体。  
`abstract`不能与`final`同时出现：`abstract`表明必须继承重写，`final`表明不能重写,矛盾.  
`abstract`不能与`static`同时出现：`abstract`表明这个方法不能被类调用也不能被对象调用，必须被继承重写之后才可以被使用。而`static`表面这个方法可以被本类调用,矛盾。
`abstract`不能与`private`同时出现：`private`方法不能被覆盖（`private`无法被子类调用识别，更不用谈覆盖重写了）。`abstract`方法必须被覆盖。所以二者矛盾。  
`abstract`方法可能不能被子类重写。当子类在另外的包中的时候，就不能覆盖父类中`abstract`方法。因为没有明确写访问权限的时候，父类中`abstract`方法不能被位于不同包中的子类重写。



Java中传值
-----------
java方法传递值，都是按照值传递，也就是复制传递的。只有这一种方法。
只是复制传递过来的有两种：
基本数据类型、
对象的引用。
>
	int a=10；
	p.f（a）；
不管这个方法的具体实现。这样方法调用完之后，a的值依旧是10；因为只是一个复制拷贝被传递进来而已。

也就是说：一个方法不可能修改一个基本数据类型的参数。
但是，以一个对象引用作为参数就不同了，可以很方便得修改对象引用所对应的实际对象，不能修改这个对象的引用，但是可以通过对象引用来修改对象本身。

总之，记住，java方法传参只有一种，那就是通过复制传值，可能传递的是基本数据，也可能传递的是对象的引用变量。

Java中构造
------------------
构造器：
特殊的方法，无需返回值。
构造器的作用：并不是用于创建对象的，而是用于进行初始化的。创建对象是new的功能。
构造器的重载：完全类似于普通方法的重载。
如果构造函数中没有显式初始化成员变量，编译器就会自己给初始化，但是实际中程序员都要自己进行初始化。
但是方法中的局部变量和类成员变量是不同的，局部变量是不会被编译器给自动初始化的。所以，方法中的局部变量必须被显式初始化。
一个成员变量在被构造函数构造之前，也就是这个成员变量定义的时候，就可以赋初值，这种用法在希望该类的每一个对象都拥有相同这个成员变量值的时候可以使用。
Java，初始化时，先初始化成员变量的定义部分赋值，然后执行初始化块中的内容，再执行构造函数中的内容。 

当一个成员变量的初始化很复杂（例如，是一个对象，需要好几个语句进行初始化赋值，这时候，就不能使用成员变量时的初始化赋初值。只能在初始化块中或者构造函数中进行赋初值。对于`static`成员变量定义时赋初值或者`static`构造块，它们执行顺序与定义的顺序是一样，也就是说，如果`static`构造块在前面，`static`成员变量初始化赋值初始化在后面，那么在使用这个类的时候，即进行初始化。总之，所以`static`的东西在非`static`的东西之前进行初始化。是所有的都是如此。非`static`是在创建对象的时候才进行初始化。`static`的成员变量在创建对象之前就初始化了。因为他是属于整个类的东西。
类所在目录路径必须与类代码前面的包名相同，这是规定。 

Java中继承
-----------------
java中所以继承都是公有继承。 
 
尽管子类可以继承拥有父类中所有的成员变量与方法，但是，子类依旧不能使用父类中的私有成员变量与方法。只有父类才能访问他自己的私有成分。子类要使用父类的私有部分也只能通过父类中的`public`成员方法才行。`Super.f();`这样才行。 
 
在子类的构造函数中，C++中是通过构造列表来构造初始化父类中的成员变量的。而java中是通过在子类的构造函数中最先调用父类的构造函数来对父类中成员变量进行初始化`Super();`构造。
 
子类中可以增加成员变量，成员方法。还可以覆盖父类的方法， 但不能覆盖父类中的成员变量。

java中的继承：是单继承。但可以有n个间接父类。  
注：
java中的继承于现实中的继承是不同的。
现实中继承：对象与对象之间的关系。如：父亲与儿子的关系，这是对象之间的继承。  
java中的继承：类与类之间的关系。父亲与儿子之间的关系并不是java中所指的继承。  
java中的继承是：从一般到特殊的关系。是`“is-a”`的关系。就是扩展、延伸的意思。

子类继承父类：在父类中的5个部分中，子类可以获得父类所有的属性与方法（包括`private`的，但是不能在子类中访问，但确实是有），但是不能获得父类的构造器、初始化块、内部类等东西。


 
Java中数组与Arraylist的区别
---------------
>
	int［］ m＝new int［］；

> 或者
> 	
	Emploree[] staff=new Emploree[3];
    m［0］＝1； 
    m［1］＝2；//这样即设定了数组m的长度，即使数组元素可以修改，但是数组长度不能修改了。只能为2。 
 
`Arraylist`就是一个泛型类。类似与C++中的vector模板。
Java中的Arraylist就是所谓的动态数组。在定义这个对象的时候并未决定容器长度，长度可以动态改变。 
取数组中的元素使用[]即可，但是由于arraylist并没有像c++中vector那样重载[]，所以，要是使用显式方法get（）与set（）来获得、存取数据元素。  
同时要注意，数组的元素操作是通过工具类`Arrays`类来进行的.

这就是它们之间的区别。

Arraylist中元素访问不方便，而数组规模不能扩充。所以可以采用一个方式将二者的长处结合起来，这样就可以使得即能扩充规模，又能方便地访问数据。
这种方法就是：将数据储存于arraylist中之后，将这个arraylist转换为一个数组。这样就能达到目的。就是对arraylist对象调用toArray方法，就会产生一个数组对象。
这个arraylist就是一个数组列表，相当于vector。如果插入删除较多，就会导致效率下降，这时候就应该使用linklist数据，就是链表。这样有利于插入和删除。	

Arraylist对象都有注明存储类型。

Java中的多态
-------------
在C++中，如果要实现某个函数的多态进行动态绑定，就需要将相应的方法设为虚函数。
但是在Java中，要实现某个函数的多态动态绑定，不需要设为虚函数，Java中并没有特别指出虚函数，默认所有的函数都是虚函数。也就是说，任何函数都可以实现动态绑定实现多态，而不需特殊声明。这就是C++和Java中的区别。
当然，如果不想让这个方法实现多态动态绑定，可以将这个方法标为final的即可。这样，这个方法就不可以被重写，这样也就没有动态绑定的了。

另注意辨析Java中的final关键词，表示这个函数不能被重写。
Final类不能被继承了。Final类中所有方法都是final的。
Java中没有多重继承。Java中的置换法则，就是程序中任何的父类对象都可以使用子类对象进行置换。
如：employee e=new manager（）；employee这个父对象可以使用manager这个子类对象进行置换。

在Java中，默认对象变量是多态的，也就是说，一个父类变量既可以引用一个父类对象，也可以引用一个子类对象。如上文父类变量e既可以引用一个父类对象employee对象，也可以引用一个manager类对象。

重要的问题，动态绑定中，可以通过父类变量引用子类对象，多态引用之后，父类变量会自动使用子类中重写的方法，也就是说，如果子类重写了父类中的方法，那么会自动使用子类重写的那个方法。但是，如果某个方法在父类中是没有的而是在子类中新加入的，那么就不能使用父类变量来调用这个方法，而只能使用父类中已有的方法。也就是说，尽管有多态的存在，父类变量依旧只能使用父类中拥有的方法（子类中新加入的方法父类是不能使用的），子类对象才能使用他自己拥有的方法（包括子类中新加入的方法）。

注意：任何数组里面放的是类变量，而不是变量所引用的类对象。

Java中的方法签名：方法的名字和参数列表，但是函数的返回类型不是方法的签名。以前，在子类覆盖父类方法中，子类方法返回类型必须与父类相同，现在允许子类返回父类的子类类型。也就是说，manager类某一个覆盖父类的方法的返回值可以是manager类，也可以是employee类的。以前是必须保证manager覆盖的方法的返回值必须与父类的相同。现在可以返回父类子类类型。
当然，覆盖方法时，覆盖方法名字与参数列表是不能改变的，必须与父类的那个方法是一样的。

Private方法不能覆盖。Static也不用覆盖，final方法不能覆盖。这三种方法都是静态绑定。

多态实现的原理就是，虚拟机会搜索类变量实际类型的方法表，以确定实际上该使用哪个类的方法。然后即可以调用这个实际的方法了。这样就实现了动态绑定。

注意，final类中所有的方法默认是final的，但不说明成员变量是final的。
非final类中可以有final成员方法和非final成员方法。

将一个类或者方法设为final的原因在于：他们不会在子类中改变语义。

Java中类型转换
--------------------

关于类型转换的问题。
基础数据类型：
短空间向长空间转换：这样可以直接转换，因为不涉及精度损失：
int a=10；double b=a；//这样是没有问题的。
B、长空间向短空间的转换：
>
    double b=10.0；int a=b；//这里必须使用强制转换，因为涉及精度损失。会产生截断。

非基础数据类型。也就是类对象变量之间的转换。
他们涉及的是向上、向下造型。//manager继承自employee对象。
子类变量向父类变量的转变：这就是向上造型。
>
	Employee e=new manager（） ；这样就是向上造型。

B、父类变量向子类变量的转变：这是向下造型，需要类型强制转换。
>	
	Manager k=new manager（）；//这样建立一个子类变量k
    Employee e =k；//这样是向上造型，将子类对象转换为父类对象，这样可以实现多态，但是转换后的父类变量e并不能调用子类中独有的方法f（），只能调用父子类都有的方法。
	Manager m=（manager）e；//这样就是向下造型。类型强制转换。将向上造型获得的父类变量还原成他原来的类型。
	m.f（）;//这样可以通过向下造型获得的子类对象来调用子类独有的方法。`

但是这样的转换往往并不成功（这是因为这种向下造型只对于那些事通过向上造型获得的父类变量才有效，也就是说向下造型值能用于还原向上造型得到的父类变量，而不能转换任意的父类变量）。所以需要事先检查到底是都可以转换，也就是：
>
	if（e instanceof manager）
	{ 
		Manager m=（manager）e；
	}

一般来说，向下转换是很少使用的，使用的时候一般用于：父类对象要使用子类的方法的时候，这个强制转换的作用就是将已经被向上造型的类变量还原成他原来的类型。也就是说，以前由向上造型从manager变为employee，那么转换之后就不再能通过转换后的employee变量来调用manager独有的方法了（就是manager自己增加的方法），这个动态绑定导致只能通过父类变量调用父子都拥有的方法，而不能调用子类独有增加的方法。如果，转换后的这个父类变量想要使用子类自己独有的方法（注意，这个时候，这个父类变量是通过向上造型获得的，他实际上引用的是子类变量，只不过他不能使用子类独有的方法而已，只能使用父子类都有的方法），这个时候就可以通过这个向下造型将向上造型获得的父类变量转换为子类变量。然后通过这个子类变量来使用它独有的那些方法。
Java中需要将向下造型与类型判断(isinstanceof)一起结合。


Java中类型转换有这么几种：
自动类型转换：
基本数据类型之间的短空间向长空间的数据类型转换。
类之间的子类向父类的向上造型。
自动转换能否完成的决定因素是：被转换的数是否在转换目标的范围之内？
>
	double i =5；//5这个int在double的范围之内，所以可以自动转换。
	Byte b=5；//5这个int在byte的范围之内，所以可以自动转换。不同强制转换。

强制类型转换：
基本数据类型之间的长空间向短空间的数据类型转换。
类之间的父类想子类的向下造型（当然是用于恢复被向上转换的子类型）。

实际上出来基本数据和类之间的类型转换，还有一种就是表达式类型的自动提升。
所谓的表达式的类型：就是表达式中最高级的运算元素的类型。如int+double：结果就是double型。
>
	int a=5+5.5;//这样就是错误的，因为右边的表达式结果是double型，要转换成左边的int型就需要强制转换，而不能直接转换，精度会有损失所以是不能自动转换的。
如果需要使用，就需要将右边表达式结果进行强制转换：
>
	int a=(int)(5+5.5);

这样才是可以的，这样就是表达式类型的提升。

此处一个注意点：任何的表达式结果的类型都是其所有的运算因子最高的类型。即使运算结果是其他的类型，也必须是运算式中的最高级。
例如：int a=10/4;//这是正确的，因为10/4这个右边的表达式的结果是2，因为10与4都是int型，所以，10/4的结果也必须是int型，即使算术上结果是2.5，那也只能得到2这个int型。所以这个式子是没有问题的。
所以来说：一个表达式的结果的数据类型早已被它的运算元素决定了，而不在于实际的算术运算的结果。


Null不能赋值给基本类型变量，只能赋给引用变量。

强类型语言更加健壮。

Java中的抽象类
-----------------
C++中多态是通过抽象类实现的。而Java不是。
实际上Java中也有抽象成员函数。但是Java中的抽象类与抽象成员函数时用于继承的。也就是，抽象函数不用实现。留给子类进行实现。
 抽象方法充当占位的作用。
抽象类不能实例化。也就是不能创建一个抽象类对象。
但是可以创建一个抽象类变量，只是这个变量不能引用抽象类对象，可以引用非抽象类对象（如子类对象）。这也就是说抽象类变量可以作为一个多态接口。通过抽象类变量来调用具体的子类变量的方法。因为可以创建抽象类变量，只是不能创建抽象类对象而已。

只要有一个抽象方法的类就必须声明为抽象类。
没有一个抽象方法的类也可以声明为抽象类。

C++与Java中关键词对比：
Java中final=const；但是添加了不能继承的特性。
Java中static=static；全类共有的方法与变量。
Java中abstract=abstract；但是去掉了控制多态性的特性。

Java控制可见性：
Private：仅对本类可见。
Public：对所有类可见。
Protected：对本包和所有子类可见（这一点和C++不同）
默认：也就是不人工设置可见性，这个默认对本包可见。


Java中所有的类都是Object类的子类。所以，可以使用Object 类来引用所有的类对象（包括任何的数组）。这是向上造型。


Java中抽象类的作用，抽象关键词见Java中abstract关键字。
主要是一个设计模式相联系：模板模式。Java中共有23中设计模式。
当在一个类中某个方法暂时不能被实现时，可以留给子类进行实现。这时候，就需要在父类中将这个方法设为抽象方法，同时这个类也是抽象类。
这个时候，在子类中，要么将父类中全部抽象方法都给实现了，要么子类继续当一个抽象类（因为只要子类中有一个抽象方法，子类就必须是抽象类）。

抽象类不能创建对象，但是抽象类引用变量可以引用非抽象类对象实例。
>
	Abstract class A；
	Class B extends A；//B中重写了A中的抽象方法。
	A a=new B（）；//A是抽象类，不能创建实例。B不是抽象类。A的引用变量可以引用B类对象实例。

然后就可以使用a这个引用来调用B中重写的A的抽象方法，这就模板模式的工作原理。

Java的Object类中的常用方法
----------------------
Equal方法：
判断对象相等的方法，比较对象是否相等。
对于对象而言，使用“==”判等，只是判断对象的引用变量是否相等，而不是判断对象本身是否相等。
所以要重写equal方法来对对象判等。

注：使用==判断基本数据类型的时候，只会判断数据实际的大小，而不会比较数据的类型。
Eg：
int a=10；
double =10.0;
a==b;//对的。
　
HashCode方法：用于返回对象的散列码。
散列码是由一个对象导出的一个整数值，没有规律。对象不同，他们所对应的散列码（hashcode）也是不同的。这个散列码就是对象的内存地址。相等对象返回相同的散列码。
计算散列码的算法方法在Object类中，每一个子类计算对象散列码的算法都来自于此。

toString方法：用于返回对象的描述性字符串。
Object类中有toString方法，我们可以自己定义自己的toObject方法。
注意，equal、toString，hashCode这些方法都是从Object继承下来的类才有的。对于基本数据类型如、int这些是没有的。因为他们不是对象。只有对象才能使用这些方法。
toString方法是非常有用的调试方法。类库中许多类都拥有自己的toString方法。
Tostring方法有一个标准写法。程序员自己重写的用于调试。

Clone方法，用于复制一个新的对象，重新分配空间。创建对象的副本。

getClass，返回类的情况。
Getname，返回类的名称。
Getsuperclass，返回超类的情况。

Java中的包装类
-------------
由于java是面向对象语言，所以java中的一切都是对象。所有的类都是object类的子类。
但是历史遗留下来的8个基本数据类型是例外（他们是从C来的）。不能当成对象来使用。
因此java为这8个基本类型提供包装器，将他们包装成类。本质依旧是基本数据类型，只是被包装成类。 	

Java中存在一个对象包装器，当需要将一个基本数据类型转换为一个对象的时候，就需要使用对象包装器来将基本数据类型装换为一个对象。实际上所有的基本数据类型都存在一个对应的类。
例如：
某个arraylist中只能存储Interger这种对象，而不能存放基本数据类型，这时候就需要将int型数据包装成interger对象。
Interger i=new interger（2）；//这样就将一个基本数据包装成i这个interger对象。这称为自动打包。现在不需要这样人工手动进行包装了，JDK会自动进行包装。
可以直接：Integer i=2；即可。
但是打包成对象之后，会导致操作效率下降。

当将一个对象赋给一个基本数据类型的时候，会自动进行解包。
int a=i；//这样就将一个对象进行解包了。
相当于：int a=i.intvalue();//现在可以自动转换，不需要再使用函数进行人工转换了。
另外，在对对象进行增、减操作的时候，也会自动进行解包，增减操作之后再进行打包。
i++；//先解包，然后对里面的基本数据进行增减操作，然后再打包。

基本数据“==”判等的时候，是判断数据大小的。
数据包装器“==”判等的时候，是判断类变量所指向的内存位置是否相等。
那么在数据包装之后的类对象进行判等就需要使用equal方法进行。
打包和拆包是编译器的事，不是虚拟机的事。编译器在生成打包后的类的时候，会生成一些字节码，加入必要的方法调用。虚拟机只是执行这些字节码。
使用基本数据包装器的好处是：可以将一些需要使用的基本方法放在对象中，因为基本数据类型中是不能自己添加方法的。所以包装成对象之后，就可以添加自己想要的方法。
 例如：将一个数值字符串转换成基本数据类型。这样就可以在包装后的类中添加必要的方法以实现这一点。
包装器对象时不可变的，也就是说基本数据类型被包装之后，就不能够被修改了。这个对象里面的内容就固定了。

Java基本类型的包装类。
byte->Byte;
short->Short;
……

在JDK1.5之后，基本类型的数据值可以直接当成对象，被类型引用变量引用。因为JDK1.5之后提供了自动装箱、解包功能，将基本数据类型数据包装成对象（被当成它的包装类使用）。也可见对象当成它的基本数据类型使用。
Eg：
Object a=3；//3这个基本数据类型值直接被a这个引用变量引用。
Integer a=2；//这也是对的，会自动将2这个基本数据包装成Integer类型。

还会自动将包装类的对象解包成基本数据。这是没有问题的。
int b=a；//这样自动将a这个对象解包成int这个基本数据类型。

由于包装和解包极其方便，所以现在很少直接使用int、double这种基本数据类型。而是使用包装的类。因为包装类使用更加方便。

对于所有的基本类型包装类，在1.7之后，添加了一个新的方法static compare（）；
Eg：
compare（Double a，Double b）：

Java中的方法栈及内存模型
-------------
任何一个方法里面声明的变量，都是存放在这个方法的栈里面，有很多的栈，每个方法都有自己的栈。方法运行结束就会释放这块内存。栈内存只是一个临时内存。
基本数据类型变量和变量值都是放在方法的栈中。
引用类型变量也是放在方法的栈中，这个变量引用的对象是放在堆中的。每个Java虚拟机只有一个堆内存，一般默认是64M，但是可以在运行java程序的时候进行设置。只要JVM不退出，堆内存就一直存在。Java -Xms256：就是设置为256M。堆内存中的对象只能通过引用来访问。
例如：数组类型变量存放在栈中，数组这个对象本身时存放在堆中的。
Java中并没有真正意义上的数组。所谓的二维数组，只是若干数组引用变量构成的一个新的数组。

二维数组的特殊之处：内含的一维数组的首地址也就是一维数组的引用变量被存放在堆内存中。然后这个引用变量指向堆中的另一块空间中的数组。而不是如一维数组中的那样放在栈中，所以：一个引用并不一定是放在栈中，还有可能放在堆中。

Eg：二维数组的使用：
int[][] a=new int[4][];
a[0]=new int[]{1,2};//一维数组的引用。依次确定各维数组地址。a[0]就是一个引用变量。指向一个数组。
…… 
总之，N维数组的元素就是n-1维数组的引用变量。如此递归，一直向下引用。


操作数组的Arrays类，这是一个工具类，用于操作数组。
都是一些static方法，Arrays.search(a,5);//在数组a中查找一个数据5

数组引用变量被从栈中销毁之后，数组对象本身时不一定会立刻从堆中销毁（不会随着数组引用变量而回收）。
而是依靠GC（垃圾回收线程），来自动销毁堆内存中的对象。它的原理就是：GC会自动记录堆内存中对象是否有引用变量引用它。会在合适的时候回收该堆内存的位置。 

内存泄露：内存被占用，但是没有被收回，导致内存泄露。
还有一种情况：内存还需要继续被使用，就直接收回了这个内存。
这两种是编程中常见的内存问题。C语言中尤为常见。Java中概率小很多。
Java中引用实际上就是指针。只不顾对指针进行了包装，使其使用更为安全。

char ch =”0”;
int num=ch;//这样num就是48；是一个int，可以自动转换的。如果在数组中第0个元素对应为为“0”；那么转换的时候就是num-48，这样才行。

Java中对象的内存管理步骤：
在堆中开辟一块permenant空间，用于储存类的static部分。
创建对象引用变量，放在栈中。
创建引用的对象本身，这个对象放在堆中，对象自有的（不是类所有的）成员变量也放在这个对象中，就是在堆中。
调用方法时，方法中的局部变量放在栈中。
