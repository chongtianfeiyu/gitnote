#Java中数据类型有
---
1. 基本数据类型：`int`、`double`等。  
2. 引用类型：对数组/类/接口/枚举对象的引用。

#Java中基本数据类型
--------------
##整型
`int（4）`、`short（2）`、`long（8）`、`byte（1）`。表示整数。  
由于`JVM`的存在，使得在不同的机器平台上的`Java`程序的数据类型所占内存空间是一样大的。解决了移植性的问题。长整型数据后缀L。十六进制前缀0X，八进制前缀0。注：`Java`中没有无符号数。

##浮点型
`float（4）`与`double（8）`。表示小数。`float`数后缀F，没有后缀默认`double`，也可以后缀为D。注：很少使用`float`，都是使用`double`。

##char类型
用于表示单个的字符。表示字符常量。""与''是不同的，''里面的表示这是一个`char`字符，而""表示这里面的是一个带有字符的字符串，即使只有一个字符也是字符串。二者是不同的。`\u`转义表示这是一个`Unicode`字符。最好不要使用`char`类型，而是使用抽象数据类型-字符串类型。这样有利于操作。

##boolean类型
注：`Java`中数值0不能代表`false`，非0也不能代表`true`。  

##基本数据之间的转换
基本数据之间的转换不涉及向上或者向下造型。而是其单独独立的转换方法。  
其中6个实心箭头，表示小空间向大空间转换，转换无信息丢失。3个虚箭头，表示可能有信息丢失。  
基本数据类型之间的转换有两种:  
1. 是无信息丢失的转换，这种转换称为自动转换。  
例如：`int a=10；double b=a；`这样使用a这个int来初始化b这个double是一种类型自动转换。  
2. 是有信息丢失的转换，这种转换称为强制转换。  
例如：`double a=10.58；int b=（int）a；`这样使用a这个double来初始化b这个int，由于是大空间向小空间的转换，所以需要使用强制类型的转换。当然会有空间精度的损失。截断小数部分(不是四舍五入）。  
注，此处，如果想获得一个浮点数的四舍五入的结果，就使用`Math.round()`这个方法，获得的是一个long整型数据，如果要变成int型数据，这就需要强制类型转换。也就是`int b=(int)Math.round(a);`也会有精度丢失的问题。
##将字符串转化为基本数据类型
使用每个基本数据类型的包装类的静态方法parseXXX(String str)将字符串转换成基本数据类型。

注：  
大数值：`java.math`包中有两个类`BigInterger`和`BigDecimal`来处理任意长度的数字序列。  
`Java`中没有提供运算符重载功能。  
#Java中的数组
-------
一个数组中，只能存放同一种类型的数据。  
一旦数组被初始化完成，其在内存中所占的空间就被固定下来。因此数组的长度将不能被改变。长度不能被改变，即使数组数据被清空。  
数组也是一种对象，当没有引用变量引用它的时候，就会自动被JVM的GC回收。  
所以，为了手动让一个数组对象被回收，可以将引用这个数组对象的引用变量值赋为null。这样就可以将这个数组对象进行回收了。  
数组内存模型，见`疯狂Java讲义p93页`  
数组引用变量是放在堆内存中，而数组对象本身时放在栈内存中的。  
数组：
> 
	int[] a=new int[100];
	或者 int[] a=new int[]{1,2,3};

以下方法都需使用`java.util.*`包。这些都是针对数组这个结构的`static`方法。  
##操作数组的工具类
`Arrays`这个类：它的作用就是操作数组这个类型的工具类。里面都是各种`static`方法，针对于数组这个类型的。  
Arrays类中的方法：  
>
数组拷贝：  
1. 数组引用变量的拷贝，使两个数组变量指向同一个数组。  
2. 数组元素的拷贝，也就是制造两个数组。使用`Arrays.copyOf()`这个`static`方法。
>
	int[] b = new int[]{1,2,3};
	int[] a = Arrays.copyOf(b);//将b数组拷贝到a数组中。
>
数组排序：  
使用`Arrays.sort()`这个静态方法。这是一个快速排序法。
>
返回数组中数据元素的字符串形式：  
使用`Arrays.toString()`静态方法。
>
二分查找法：  
`Arrays.binarySearch()`静态方法。

二维数组：
>
	int[][] bal=new int[][]
	{
		{1,2,3},
		{4,5,6},
	};

遍历二维数组每一个元素：
>
	Arrays.deepToString()静态方法。

实际上对多维数组进行操作都要使用`deep`开头的方法。

##多维数组
实际上`Jav`a中没有多维数组，本质就是数组的数组。  
`bal`数组实际上包含两个元素的数组，每个元素由三个元素组成。`bal[1]`引用的是二维表的第i行。这一行本身就是一个数组。  
为每一行分配元素的时候：
>
	bal[2]=new int[3];将这一行当做一个元素。这样可以创建不规则数组。
>
	int[][] a=new int[10][];
	for( int n=0;n<10;n++)
	{
		a[n]=new int[n+1];
	}
或者直接：
>
	int[][] a=new int[][]{{1,2,3},{1},{2,3}};
这样创建的是一个三角形的不规则数组。不规则数组就是Java语言和其他语言的不同。

输出的时候:
>
	for (int m=0;m<a.length;m++)
		for (int k=0；k<a[m].length;k++)

这样即可遍历。

或者使用foreach:
>
	for (int[] row :a)
		for (int m:row)

这样亦可。

##数组本质
在Java里，数组也是一个和int、类这些东西同级的类型。他可以用于创建一个数组引用变量，也可以用于类型的转换，和所有的基本数据、类都是一模一样的。  
所有的数组都是在其他的类型后面加上[]即变为数组类型。如：  
`String[]`就是一个数组类型。`int[]`数组类型后面加上`[]`就变成了`int[][]`这个数组类型.  
数组类型变量本质就是引用类型，实际上就是指针。数组引用本来就是一个变量。  
所以，写数组的时候必须写成：`int[]`,而不要是`int a[]`;  

`Java`语言是静态语言，就是说，一旦变量类型确定，就不能再修改，也就是说变量内存空间大小也不能修改了。那么`java`中数组的长度是不能改变的，一旦初始化完毕就恒定了。空间是固定下来的，即使元素被清空，其空间依旧保留，可以被别的元素占用。  
##数组初始化
数组类型变量只是一个指针，如果没有将它引用到一个数组对象，那么就不能直接使用这个数组变量。也就是说数组变量必须指向一个有效的内存，也就是必须进行**初始化**。  
初始化两种：
>
静态初始化：
>
	int[] a=new int[]{1,2,3};//这就是静态初始化，后一个[]里面不能设置长度，因为后面的{}里面已经确定数组长度了，是一个固定的长度了，也就是数组对象定义的时候就已经静态化它的长度了。指定了数组的元素，让系统判断数组长度。
动态初始化：
>
	int[] a=new int[3];//只指定数组的长度，不指定数组的元素。后面再进行数组元素的初始化。

总之，不能即指定数组长度又指定数组元素:
>
	int a=new int[3]{1,2,3};//这是错的。因为是没有必要的。

在数组初始化之后，每一个数组元素都可以作为基本数据变量或者引用类型变量使用。
数组的使用：  
数组的`length`属性，返回数组长度。  
##形参长度可变
传递多个参数的时候，要传递可变参数，而不是传递一个数组。原因是，传递可变参数时，即使是没有参数，在方法里面使用的时候不会报空指针异常。但是如果是使用数组，那么在方法里面就会可能报空指针异常。而且使用更加简洁。  
##注
注：Java中的引用变量，实际上就是C里面的指针。只是Java将这个指针封装起来，避免开发者进行繁琐的指针操作。  
this关键字，就是对本对象的默认引用变量。在static方法中，不能使用非static方法与属性，所以，如果要在static方法中使用非static方法，不能使用this关键字，需要先创建一个本类对象实例，再通过这个对象实例来进行使用。  
#Java中字符串类型
---------------
1、和`char`不同，这是字符串类型。不是`char`那样的基础数据类型。使用双引号。是一个类。而不是基础数据。
>
	String Str="hello"；//这是一个字符串。
	char c='a'；//这是一个字符。

获得子串：`substring()`方法；
>
	String substr=Str.substring(1,3);//从字符串Str中取一个子串。

拼接："+"；
  
`String`对象中的单个字符是不能修改的，也就是说，没有函数可以直接修改一个字符串中的某一个字符。  
如：  
`String Str="hello"；`  
修改为`"hellp"`的方法有两个：  
`Str="hellp";`或者`Str.substring(0,3)+"p";`而没有一个方法直接将最后一个字符进行修改。
这就是不可变字符串。
  
字符串相等比较，要使用`equals()`或者`equalsIgnoreCase()`而不是`==`  
因为：`equal()`是比较字符串是否一样的。而`==`是比较两个字符串在内存中的位置是否相等（也就是`String`对象的引用变量是否相等）。当两个字符串是一样的，但是位于内存的不同处，这样使用`==`判定就会是`false`。因为内存位置不同。  
如：
>
	String Str="hello"；
	if（Str=="hello"）//比较的是Str这个字符串变量指向的字符串的位置是否与后面的“hello”字符串所在的内存位置是一样的。判断会失误。

误区：关于string缓存机制，此处见`疯狂Java讲义p66页`。
>
	String s1=new string（"hello"）；
	String s2=new string （"hello"）；//s1！=s2；因为new创建了不同的对象，s1与s2指向不同的对象。
>
	String s3=“hello”；  
	String s4=“hello”；//s3=s4；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s4的时候，不再创建新的字符串对象，而是使用s3的字符串对象。  

同理：
>
	String s5=“hello”；
	String s6=“he”+“llo”；//s5=s6；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s6的时候，二者字符串一样。所以不再创建新的字符串对象，而是使用s5的字符串对象。

但是缓存只对于常量有用，也就是说，只会对`"hello"`这样的有缓存。对于`string s1="hello"`
这样的，下一次使用`s1`是不能使用缓存的，只有使用`"hello"`的时候才是使用上次的缓存。
>
	String s=“good”；
	String s2=s；//没有使用缓存；
	String s3=“good”;//使用了第一次的缓存。

注：使用缓存的意思就是：他们所指向的空间是一样的。

误区：关于`java`的宏替换
`final`修饰的变量会执行“宏替换”：
如果`final`修饰的变量在编译的时候就可以确定它的值（什么叫在编译的时候就知道它的值？  
如：
>
	String s="hi";  
这就是在编译的时候知道`s`的值。什么叫在运行的时候知道它的值？
如：
>
	String s1="hi";
	String s2=s1;  
那么，`s1`在编译的时候就知道它的值，而`s2`直到运行的时候才知道它的值。），那么，这个变量实际上是不存在的。而是在以后使用这个变量的时候直接执行“宏替换”。
这句话的意思就是：`final`修饰的变量如果赋予了初始值，而且这个初始值在编译的时候就已知，那么在内存中根本就不存在这个`final`变量，而只有它所指向的空间存在。以后使用的时候，是直接用这个初始值直接进行宏替换。
如：
>
	final string s3="hello";
	String s4=s3;  
这段代码中，变量`s3`并不存在，在`s4`语句中，需要用到`s3`，就是在编译到`s4`的时候直接执行宏替换，将`"hello"`置换到`s4`指向的空间中。也就是说，编译的时候，`s4`的值就已知（相当于直接在`s3`的位置放上`"hello"`）导致`s4`编译的时候就知道它的值。而且连`"hello"`这个对象也不存在，因为前面的引用变量`s3`已不存在了，所以再创建出对象也没有意义.  
而在前例中，`s2`的值在编译的时候是未知的，直到运行的时候才知道。这就是`final`修饰的一个`feature`。
总之，如果`final`变量已初始化，且在编译的时候就知道其值，那么这个变量不存在了，变量所引用的对象也是不存在的。变量都不存在了其引用对象就没有存在的必要了。
`final`成员变量定义时的赋值、初始化块中的赋值都不会插入到构造函数最前面，因为`final`成员变量在编译是已知其值，则该变量不存在。无`final`的一般成员变量都会插入到构造器中。
同理，`static`的`final`成员变量的定义时赋值也不会被插入到`static`初始化块中。无`final`的`static`的成员变量都会被插入到`static`初始化块中。

所谓的宏替换：就是查找、替换。

要注意：宏替换变量应该使用大写单词表示，且由多个单词连接而成，各个单词之间以下划线分隔。
>
	Final String s1=“hi”；
	Final String s2=“hello”；
	Final String s3=s1+s2；

这里创建了1个对象（`"hihello"`），但是只有0个变量，`s1`、s2``、`s3`这3个变量不存在。因为是`final`的，且编译时值已知。

#Java中变量
---------
##基本数据类型的变量
>
	int a=5；//这个5直接放置在a这个变量中，a就是基本类型变量。

##引用变量
引用变量中并不是放置着具体的内容数据，而是其引用的数据的地址。这就是引用变量。当然指针本身也是变量，放在栈中。指针所指向的内容放在堆中。

变量的声明，如:
>
	int a；
	double b；
变量声明之后，必须使用赋值语句进行初始化，编译器不会自己给它赋值的，这一点和`C`不同。没有自己初始化使用就会导致问题。`Java`中不区分变量的声明与定义。  
`Java`中使用`final`声明常量。使用大写。且这个量只能被赋值一次。不能修改。  
`Java`中如果要使一个常量可以被一个类中的所有方法共同使用，称之为类常量，这个量的大小不能修改，属于整个类。使用`static final`进行设置。  
>
	static final int a=10；这个值被所有的对象所有的方法使用，且不能修改。

这个不同于单纯的`static`成员变量。这个`static`变量只是属于整个类。但是不能保证不变。  

成员变量：在类中定义。  
属于类的成员变量：`static`  
属于对象的成员变量：无`static`  
在某个方法中建立一个对象的时候，对象本身在堆中，对象的引用在栈中。  
系统加载一个类，就为这个类开辟一块空间。只加载一次。  
建立对象的时候，会为成员变量进行初始化。  

局部变量：局部变量就是在方法中定义的变量，储存在方法栈中，必须由程序员进行初始化。不能用`static`进行修饰。局部变量不允许重名。  
方法中的局部变量，作用域仅在方法中。  
代码块中的局部变量，仅在代码块中有效。  
代码块：如，某个方法里面有一个括号，括号中内容就是一个代码块。代码块就是一个花括号。 
形参：在整个方法中有效。  

`Java`中没有所谓的全局变量的说法。


#Java中的运算符
--------
数据的左右移位：>>与<<
在没有数据溢出的情况下，左移n位就是乘以2的n次方。右边空的地方补上0；  
右移没有溢出问题。相当于右边去掉n位。右移n位就是在左边的空地方补上符号位，正数补上0，相当于除以2的n次方，然后舍去小数部分。负数就是补上1，相当于除以2的n次方，然后将小数部分补成整数。结果都比算术意义上的数小。   
数字以最快的速度乘以8，就是左移3位即可。这就是提高效率的方法。  
数据的无符号右移：>>>:无论数据的正负，右移都是在数据左边空地方补上0，一直补0；会将负数变为正数。  



