#Java中的块
一个变量的有效范围就是一个块。但是嵌套的块中，变量不会覆盖块外的变量，这一点和C++不同。

#Java中的语句
-------

选择语句：
>
	if（）……else if（）……else……
多重选择：
>
	switch（）case1：……break；case2：……break；default：……；一般很少使用switch。

循环语句：
>
不确定循环：
>
	while（）……do……；do……while（）；
确定循环：
>
	for循环，for循环是支持迭代的通用结构。利用每次迭代之后更新的计数器或者类似的变量来控制迭代次数。

>
Foreach 循环：
>
	for（variable：collection）statement；

#Java中方法的重载
在一个类中可以定义多个名称相同的方法，这些方法只需要名字相同，形参列表不同就行，其他的都无关，是否相同都不重要。
#Java类之间的关系
-----------
1、依赖（use a）：一个类的方法中操作了另一个类的对象，这就是依赖的关系。例如类A的某个方法中使用了B类对象作为局部变量，这就是依赖。
应该将互相依赖的类减至最少。这就是使A类不知道B类的存在，意味着B类的改变不会导致A类产生bug。这样就是让类之间的耦合度减小。

2、聚合（has a）：一个类A中的成员变量包括B类对象，这就是聚合关系。也就是A类对象包含B类对象。

3、继承（is a）：A类由B类继承而来。特殊与一般的关系。包含B类中的方法。


#Java中的引用
---------
java中的引用类似与C++中的指针。

一个java源程序中，只能有一个`public`类（也就是只能是`main`那个函数所在的类是`public`，其他的所有类都不能）。但可以有任意个非`public`类。

#Java中的可见性
Private：仅对本类可见。
Public：对所有类可见。
Protected：对本包和所有子类可见（这一点和C++不同）
默认：也就是不人工设置可见性，这个默认对本包可见。

private(本类中可以访问)<default(本类、本包中都可以访问)<protected(本包中可以访问且处于不同包中的本外部类的子类也可以访问)<public(任何地方都可以访问)  
类前面的修饰符是修饰这个类的，方法前面的修饰符是修饰这个方法的，成员变量前面的修饰符是修饰这个成员变量的。  
顶级类(顶级类不能处于其他类的内部)前面的修饰符不能是private或者protected。因为，顶级类不能处于其他类的内部，所以，就不能为什么类内部所调用了，当然也就没有其外部类的子类。  
只有一个类作为其他类的内部类出现的时候，其才能有private或者protected修饰，否则只能是protected或者default修饰。  
注意：这里的所谓的可以为子类所调用，实际上是指这个类可以为这个类的外部类的子类所调用，而不是指为这个类自己的子类所调用。  

#Java中final关键字
-----------------
1、`final`修饰变量（*成员变量*（类拥有变量与实例拥有变量）与局部变量（方法内局部变量与块内局部变量））  

`final`修饰符大部分用于基本数据类型，或者不可变类的域（类中的每一个方法都不改变该成员变量）。如果是用于一个类成员变量（也就是非基本数据类型成员变量），就会导致混乱，因为在一个类中使用`final`类成员变量，只说明这个类成员变量的引用是不变的，而不说明这个对象本身时不变的，只是引用不变而已。
所以`final`修饰符最好不要使用在非基本数据类型成员变量上。
`final`成员变量表示这个变量是不能被修改的。

A、`final`修饰成员变量
必须人工进行初始化，初始化的位置：
定义成员变量时、
初始化块（普通初始化块与`static`初始化块）、
构造函数。

普通方法不允许为`final`成员变量赋值。`final`成员变量只能在以上三个位置进行初始化且只能在一个地方赋值。因为他们前两个实际上都是插入到构造器中来发挥作用的，所以三者都是平等的地位。都可以对`final`成员进行初始化。

B、`final`修饰局部变量	
必须人工初始化，无论是否是`final`局部变量。
局部变量加了`final`之后，以后再也不能修改其值了。

要注意`final`变量的工作方式与普通变量是不同的，见java中字符串类型中说明的`final`变量的工作原理。

2、`final`修饰符用于类方法或者整个类，表示这个类或者方法不能被继承或重写了。  
非`final`类中可有非`final`方法和`final`方法，其中的非`final`方法可有被继承重写。但是`final`方法不能被重写。  
`final`类中所有的方法都是默认为`final`的，也就是说，`final`类中所有方法都不可被重写。但是不说明那些成员变量是`final`的（`final`成员变量表明成员变量不变）。
也就是说`final`成员变量可以设置为`public`，因为它已不能被修改了，为一常量。

#Java中实例对象创建过程
第一次使用这个类的时候，要初始化这个类，就是在创建一个实例变量之前，就先为这个分配一块内存，里面可以放置属于这个类的static成员属性。实际上隐含地为这个类创建了一个实例对象，只是我们无法使用而已。  
当以后再使用这个类的时候，就不必再次初始化这个类了。见`疯狂Java讲义p128页`。  
static成员变量与static成员方法在还没有创建出实例对象之前就已经存在了。其在类的加载过程中就出现了。  
static初始化块也是在实例对象创建之前就执行了，只针对static成员变量进行初始化。  
也就是说，还没有创建实例对象的时候，static初始化块就执行了。  
在static初始化块执行完之后，就开始创建实例变量，创建实例对象(new出来一个实例对象)之后，再对这个实例对象进行初始化(使用普通初始化块与构造函数)。  
至此，整个实例对象就创建完毕。  
实例对象的属性的生命范围与实例对象相同。  
类属性的生命范围与类本身相同。  

注：在Java中，除非有必要，否则，能使用局部变量就使用局部变量，就不要使用类成员变量或者实例成员变量，因为会占用内存，消耗效率。  
#Java中static关键字
-----------------
`static`就是一个标志，不是什么静态的意思。  
`static`成员变量和`static`成员方法还有`static`初始化块。与类共存亡。  


`static`成员变量属于整个类，所有对象共享。`static`成员变量可以在声明定义的时候即赋值，也可以在`static`代码块中进行赋初值，但是不能在构造函数中赋初值。  
如果是`final static`常量，能在成员常量定义的时候赋初值。也能等到在`static`初始化块里面赋初值。因为最终也是要插入到`static`初始化块的。    
`static`成员变量使用的较少。但是`static`成员常量用的较多，也就是`static final`成员常量。全类共享，且不变。  
`static`成员方法是不能对对象进行操作的，只能对类共享的成员变量进行操作。不需要对象，也就是`static`方法没有`this`这个隐藏参数。  
以下两种情况下需要使用`static`成员方法。  
1. 当这个方法不需要使用对象的状态的时候，也就是这个方法的所有的参数都是显式提供的，而不需要隐式提供的`this`。  
2. 这个方法只需要访问类的`static`成员变量，不需要访问非`static`成员变量。当有类但是没有创建对象的时候，可以通过类直接使用`static field`或者方法。

静态方法的还有一个用处就是：`Factory`方法。用于产生不同风格的格式对象。

在同一个类中：
`static`成员不能访问非`static`成员（包括成员变量与方法）。  
`this`、`super`都不能出现在`static`成员中（如，不能出现在`static`方法中）；
这里的`static`成员包括：`static`方法、`static`初始化块、`static field`但不包括构造器（也就是说，`static`成员可以调用所有的构造器，因为构造器根本就没有`static`修饰这回事儿）。
也就是说，`static`初始化块里面都不能出现属于实例的非`static`的东西。  
总之一句话，类拥有的东西不能碰对象拥有的东西，也就是说，抽象、集体的东西不能碰具体、个人的东西。但前提是：在同一个类中。
>
	Static main方法都不能访问同一个类中的非static field。
	Public class m
	{
		int a=10；
		Public static void main（String[] args）
		{
		System.out.println（a）;//这是错的，在同一个类中，本类的static成员不能访问本类的非static成员。
		}
	}
`static`的东西在导入这个类的时候即导入。是最先导入的。  
`main`方法也是一个`static`方法。
任何一个类都可以拥有它自己的main方法，这是常用的对类进行单元测试的技巧。
如果要单元测试这个类，可以直接`javac employee`即可。这样就会执行`employee`这个类的`main`方法。

#Java中abstract关键字
------------------
`abstract`类：  
`abstract`类特点：有得有失  
得：可以拥有抽象方法。因为普通类中不能有抽象方法，只有抽象类中才可以有抽象方法。所以，一个类中有了抽象方法就一定是抽象类。  
失：不能创建实例。  
误区：  
1. 其他的和普通方法都是一样的。同样有各种`field`（`static`与非`static`），各种构造器，各种初始化块（`static`与非`static`的）。  
2. 抽象类可以没有抽象方法。但这种抽象类依旧不能创建实例。

但是，既然抽象类无法创建实例，那么，我们还需要抽象类的实例方法、变量（非`static`方法与非`static`成员变量）和构造器干什么？  
Answer：  
1、抽象类的构造器是用于供其子类调用以进行父类成员变量的初始化。  
2、抽象类的各种非`static`成员方法是用于被子类重写(`override`)。或者被子类直接调用(直接使用`super`即可)。非`static`成员方法中，抽象成员方法用于被子类重写。非抽象成员方法用于被子类调用（父类、子类都拥有这些方法）。

`abstract`方法:  
说明这个方法既不能被本类调用又不能被本类的实例调用，只是占了一个坑，留给子类来填。使用`abstract`修饰，且没有方法体。  
`abstract`不能与`final`同时出现：`abstract`表明必须继承重写，`final`表明不能重写,矛盾.  
`abstract`不能与`static`同时出现：`abstract`表明这个方法不能被类调用也不能被对象调用，必须被继承重写之后才可以被使用。而`static`表面这个方法可以被本类调用,矛盾。
`abstract`不能与`private`同时出现：`private`方法不能被覆盖（`private`无法被子类调用识别，更不用谈覆盖重写了）。`abstract`方法必须被覆盖。所以二者矛盾。  
`abstract`方法可能不能被子类重写。当子类在另外的包中的时候，就不能覆盖父类中`abstract`方法。因为没有明确写访问权限的时候，父类中`abstract`方法不能被位于不同包中的子类重写。

#Java中传值
-----------
java方法传递值，都是按照值传递，也就是复制传递的。只有这一种方法。
只是复制传递过来的有两种：
基本数据类型、
对象的引用。
>
	int a=10；
	p.f（a）；
不管这个方法的具体实现。这样方法调用完之后，a的值依旧是10；因为只是一个复制拷贝被传递进来而已。

也就是说：一个方法不可能修改一个基本数据类型的参数。
但是，以一个对象引用作为参数就不同了，可以很方便得修改对象引用所对应的实际对象，不能修改这个对象的引用，但是可以通过对象引用来修改对象本身。

总之，记住，java方法传参只有一种，那就是通过复制传值，可能传递的是基本数据，也可能传递的是对象的引用变量。

#Java中构造
------------------
构造器：
特殊的方法，无需返回值。
构造器的作用：并不是用于创建对象的，而是用于进行初始化的。创建对象是new的功能。
构造器的重载：完全类似于普通方法的重载。
如果构造函数中没有显式初始化成员变量，编译器就会自己给初始化，但是实际中程序员都要自己进行初始化。
但是方法中的局部变量和类成员变量是不同的，局部变量是不会被编译器给自动初始化的。所以，方法中的局部变量必须被显式初始化。
一个成员变量在被构造函数构造之前，也就是这个成员变量定义的时候，就可以赋初值，这种用法在希望该类的每一个对象都拥有相同这个成员变量值的时候可以使用。
Java，初始化时，先初始化成员变量的定义部分赋值，然后执行初始化块中的内容，再执行构造函数中的内容。 

当一个成员变量的初始化很复杂（例如，是一个对象，需要好几个语句进行初始化赋值，这时候，就不能使用成员变量时的初始化赋初值。只能在初始化块中或者构造函数中进行赋初值。对于`static`成员变量定义时赋初值或者`static`构造块，它们执行顺序与定义的顺序是一样，也就是说，如果`static`构造块在前面，`static`成员变量初始化赋值初始化在后面，那么在使用这个类的时候，即进行初始化。总之，所以`static`的东西在非`static`的东西之前进行初始化。是所有的都是如此。非`static`是在创建对象的时候才进行初始化。`static`的成员变量在创建对象之前就初始化了。因为他是属于整个类的东西。
类所在目录路径必须与类代码前面的包名相同，这是规定。 

#Java中继承
-----------------
java中所以继承都是公有继承。 
 
尽管子类可以继承拥有父类中所有的成员变量与方法，但是，子类依旧不能使用父类中的私有成员变量与方法。只有父类才能访问他自己的私有成分。子类要使用父类的私有部分也只能通过父类中的`public`成员方法才行。`Super.f();`这样才行。 
 
在子类的构造函数中，C++中是通过构造列表来构造初始化父类中的成员变量的。而java中是通过在子类的构造函数中最先调用父类的构造函数来对父类中成员变量进行初始化`Super();`构造。
 
子类中可以增加成员变量，成员方法。还可以覆盖父类的方法， 但不能覆盖父类中的成员变量。

java中的继承：是单继承。但可以有n个间接父类。  
注：
java中的继承于现实中的继承是不同的。
现实中继承：对象与对象之间的关系。如：父亲与儿子的关系，这是对象之间的继承。  
java中的继承：类与类之间的关系。父亲与儿子之间的关系并不是java中所指的继承。  
java中的继承是：从一般到特殊的关系。是`“is-a”`的关系。就是扩展、延伸的意思。

子类继承父类：在父类中的5个部分中，子类可以获得父类所有的属性与方法（包括`private`的，但是不能在子类中访问，但确实是有），但是不能获得父类的构造器、初始化块、内部类等东西。


 
#Java中数组与Arraylist的区别
---------------
>
	int［］ m＝new int［］；

> 或者
> 	
	Emploree[] staff=new Emploree[3];
    m［0］＝1； 
    m［1］＝2；//这样即设定了数组m的长度，即使数组元素可以修改，但是数组长度不能修改了。只能为2。 
 
`Arraylist`就是一个泛型类。类似与C++中的vector模板。
Java中的Arraylist就是所谓的动态数组。在定义这个对象的时候并未决定容器长度，长度可以动态改变。 
取数组中的元素使用[]即可，但是由于arraylist并没有像c++中vector那样重载[]，所以，要是使用显式方法get（）与set（）来获得、存取数据元素。  
同时要注意，数组的元素操作是通过工具类`Arrays`类来进行的.

这就是它们之间的区别。

Arraylist中元素访问不方便，而数组规模不能扩充。所以可以采用一个方式将二者的长处结合起来，这样就可以使得即能扩充规模，又能方便地访问数据。
这种方法就是：将数据储存于arraylist中之后，将这个arraylist转换为一个数组。这样就能达到目的。就是对arraylist对象调用toArray方法，就会产生一个数组对象。
这个arraylist就是一个数组列表，相当于vector。如果插入删除较多，就会导致效率下降，这时候就应该使用linklist数据，就是链表。这样有利于插入和删除。	

Arraylist对象都有注明存储类型。

#Java中的多态
-------------
在C++中，如果要实现某个函数的多态进行动态绑定，就需要将相应的方法设为虚函数。
但是在Java中，要实现某个函数的多态动态绑定，不需要设为虚函数，Java中并没有特别指出虚函数，默认所有的函数都是虚函数。也就是说，任何函数都可以实现动态绑定实现多态，而不需特殊声明。这就是C++和Java中的区别。
当然，如果不想让这个方法实现多态动态绑定，可以将这个方法标为final的即可。这样，这个方法就不可以被重写，这样也就没有动态绑定的了。

另注意辨析Java中的final关键词，表示这个函数不能被重写。
Final类不能被继承了。Final类中所有方法都是final的。
Java中没有多重继承。Java中的置换法则，就是程序中任何的父类对象都可以使用子类对象进行置换。
如：employee e=new manager（）；employee这个父对象可以使用manager这个子类对象进行置换。

在Java中，默认对象变量是多态的，也就是说，一个父类变量既可以引用一个父类对象，也可以引用一个子类对象。如上文父类变量e既可以引用一个父类对象employee对象，也可以引用一个manager类对象。

重要的问题，动态绑定中，可以通过父类变量引用子类对象，多态引用之后，父类变量会自动使用子类中重写的方法，也就是说，如果子类重写了父类中的方法，那么会自动使用子类重写的那个方法。但是，如果某个方法在父类中是没有的而是在子类中新加入的，那么就不能使用父类变量来调用这个方法，而只能使用父类中已有的方法。也就是说，尽管有多态的存在，父类变量依旧只能使用父类中拥有的方法（子类中新加入的方法父类是不能使用的），子类对象才能使用他自己拥有的方法（包括子类中新加入的方法）。

注意：任何数组里面放的是类变量，而不是变量所引用的类对象。

Java中的方法签名：方法的名字和参数列表，但是函数的返回类型不是方法的签名。以前，在子类覆盖父类方法中，子类方法返回类型必须与父类相同，现在允许子类返回父类的子类类型。也就是说，manager类某一个覆盖父类的方法的返回值可以是manager类，也可以是employee类的。以前是必须保证manager覆盖的方法的返回值必须与父类的相同。现在可以返回父类子类类型。
当然，覆盖方法时，覆盖方法名字与参数列表是不能改变的，必须与父类的那个方法是一样的。

Private方法不能覆盖。Static也不用覆盖，final方法不能覆盖。这三种方法都是静态绑定。

多态实现的原理就是，虚拟机会搜索类变量实际类型的方法表，以确定实际上该使用哪个类的方法。然后即可以调用这个实际的方法了。这样就实现了动态绑定。

注意，final类中所有的方法默认是final的，但不说明成员变量是final的。
非final类中可以有final成员方法和非final成员方法。

将一个类或者方法设为final的原因在于：他们不会在子类中改变语义。

#Java中类型转换
--------------------

关于类型转换的问题。
基础数据类型：
短空间向长空间转换：这样可以直接转换，因为不涉及精度损失：
int a=10；double b=a；//这样是没有问题的。
B、长空间向短空间的转换：
>
    double b=10.0；int a=b；//这里必须使用强制转换，因为涉及精度损失。会产生截断。

非基础数据类型。也就是类对象变量之间的转换。
他们涉及的是向上、向下造型。//manager继承自employee对象。
子类变量向父类变量的转变：这就是向上造型。
>
	Employee e=new manager（） ；这样就是向上造型。

B、父类变量向子类变量的转变：这是向下造型，需要类型强制转换。
>	
	Manager k=new manager（）；//这样建立一个子类变量k
    Employee e =k；//这样是向上造型，将子类对象转换为父类对象，这样可以实现多态，但是转换后的父类变量e并不能调用子类中独有的方法f（），只能调用父子类都有的方法。
	Manager m=（manager）e；//这样就是向下造型。类型强制转换。将向上造型获得的父类变量还原成他原来的类型。
	m.f（）;//这样可以通过向下造型获得的子类对象来调用子类独有的方法。`

但是这样的转换往往并不成功（这是因为这种向下造型只对于那些事通过向上造型获得的父类变量才有效，也就是说向下造型值能用于还原向上造型得到的父类变量，而不能转换任意的父类变量）。所以需要事先检查到底是都可以转换，也就是：
>
	if（e instanceof manager）
	{ 
		Manager m=（manager）e；
	}

一般来说，向下转换是很少使用的，使用的时候一般用于：父类对象要使用子类的方法的时候，这个强制转换的作用就是将已经被向上造型的类变量还原成他原来的类型。也就是说，以前由向上造型从manager变为employee，那么转换之后就不再能通过转换后的employee变量来调用manager独有的方法了（就是manager自己增加的方法），这个动态绑定导致只能通过父类变量调用父子都拥有的方法，而不能调用子类独有增加的方法。如果，转换后的这个父类变量想要使用子类自己独有的方法（注意，这个时候，这个父类变量是通过向上造型获得的，他实际上引用的是子类变量，只不过他不能使用子类独有的方法而已，只能使用父子类都有的方法），这个时候就可以通过这个向下造型将向上造型获得的父类变量转换为子类变量。然后通过这个子类变量来使用它独有的那些方法。
Java中需要将向下造型与类型判断(isinstanceof)一起结合。


Java中类型转换有这么几种：
自动类型转换：
基本数据类型之间的短空间向长空间的数据类型转换。
类之间的子类向父类的向上造型。
自动转换能否完成的决定因素是：被转换的数是否在转换目标的范围之内？
>
	double i =5；//5这个int在double的范围之内，所以可以自动转换。
	Byte b=5；//5这个int在byte的范围之内，所以可以自动转换。不同强制转换。

强制类型转换：
基本数据类型之间的长空间向短空间的数据类型转换。
类之间的父类想子类的向下造型（当然是用于恢复被向上转换的子类型）。

实际上出来基本数据和类之间的类型转换，还有一种就是表达式类型的自动提升。
所谓的表达式的类型：就是表达式中最高级的运算元素的类型。如int+double：结果就是double型。
>
	int a=5+5.5;//这样就是错误的，因为右边的表达式结果是double型，要转换成左边的int型就需要强制转换，而不能直接转换，精度会有损失所以是不能自动转换的。
如果需要使用，就需要将右边表达式结果进行强制转换：
>
	int a=(int)(5+5.5);

这样才是可以的，这样就是表达式类型的提升。

此处一个注意点：任何的表达式结果的类型都是其所有的运算因子最高的类型。即使运算结果是其他的类型，也必须是运算式中的最高级。
例如：int a=10/4;//这是正确的，因为10/4这个右边的表达式的结果是2，因为10与4都是int型，所以，10/4的结果也必须是int型，即使算术上结果是2.5，那也只能得到2这个int型。所以这个式子是没有问题的。
所以来说：一个表达式的结果的数据类型早已被它的运算元素决定了，而不在于实际的算术运算的结果。


Null不能赋值给基本类型变量，只能赋给引用变量。

强类型语言更加健壮。

#Java中的抽象类
-----------------
C++中多态是通过抽象类实现的。而Java不是。
实际上Java中也有抽象成员函数。但是Java中的抽象类与抽象成员函数时用于继承的。也就是，抽象函数不用实现。留给子类进行实现。
 抽象方法充当占位的作用。
抽象类不能实例化。也就是不能创建一个抽象类对象。
但是可以创建一个抽象类变量，只是这个变量不能引用抽象类对象，可以引用非抽象类对象（如子类对象）。这也就是说抽象类变量可以作为一个多态接口。通过抽象类变量来调用具体的子类变量的方法。因为可以创建抽象类变量，只是不能创建抽象类对象而已。

只要有一个抽象方法的类就必须声明为抽象类。
没有一个抽象方法的类也可以声明为抽象类。

C++与Java中关键词对比：
Java中final=const；但是添加了不能继承的特性。
Java中static=static；全类共有的方法与变量。
Java中abstract=abstract；但是去掉了控制多态性的特性。


Java中所有的类都是Object类的子类。所以，可以使用Object 类来引用所有的类对象（包括任何的数组）。这是向上造型。


Java中抽象类的作用，抽象关键词见Java中abstract关键字。
主要是一个设计模式相联系：模板模式。Java中共有23中设计模式。
当在一个类中某个方法暂时不能被实现时，可以留给子类进行实现。这时候，就需要在父类中将这个方法设为抽象方法，同时这个类也是抽象类。
这个时候，在子类中，要么将父类中全部抽象方法都给实现了，要么子类继续当一个抽象类（因为只要子类中有一个抽象方法，子类就必须是抽象类）。

抽象类不能创建对象，但是抽象类引用变量可以引用非抽象类对象实例。
>
	Abstract class A；
	Class B extends A；//B中重写了A中的抽象方法。
	A a=new B（）；//A是抽象类，不能创建实例。B不是抽象类。A的引用变量可以引用B类对象实例。

然后就可以使用a这个引用来调用B中重写的A的抽象方法，这就模板模式的工作原理。

#Java的Object类中的常用方法
----------------------
Equal方法：
判断对象相等的方法，比较对象是否相等。
对于对象而言，使用“==”判等，只是判断对象的引用变量是否相等，而不是判断对象本身是否相等。
所以要重写equal方法来对对象判等。

注：使用==判断基本数据类型的时候，只会判断数据实际的大小，而不会比较数据的类型。
Eg：
int a=10；
double =10.0;
a==b;//对的。
　
HashCode方法：用于返回对象的散列码。
散列码是由一个对象导出的一个整数值，没有规律。对象不同，他们所对应的散列码（hashcode）也是不同的。这个散列码就是对象的内存地址。相等对象返回相同的散列码。
计算散列码的算法方法在Object类中，每一个子类计算对象散列码的算法都来自于此。

toString方法：用于返回对象的描述性字符串。
Object类中有toString方法，我们可以自己定义自己的toObject方法。
注意，equal、toString，hashCode这些方法都是从Object继承下来的类才有的。对于基本数据类型如、int这些是没有的。因为他们不是对象。只有对象才能使用这些方法。
toString方法是非常有用的调试方法。类库中许多类都拥有自己的toString方法。
Tostring方法有一个标准写法。程序员自己重写的用于调试。

Clone方法，用于复制一个新的对象，重新分配空间。创建对象的副本。

getClass，返回类的情况。
Getname，返回类的名称。
Getsuperclass，返回超类的情况。

#Java中的包装类
-------------
由于java是面向对象语言，所以java中的一切都是对象。所有的类都是object类的子类。
但是历史遗留下来的8个基本数据类型是例外（他们是从C来的）。不能当成对象来使用。
因此java为这8个基本类型提供包装器，将他们包装成类。本质依旧是基本数据类型，只是被包装成类。 	

Java中存在一个对象包装器，当需要将一个基本数据类型转换为一个对象的时候，就需要使用对象包装器来将基本数据类型装换为一个对象。实际上所有的基本数据类型都存在一个对应的类。
例如：
某个arraylist中只能存储Interger这种对象，而不能存放基本数据类型，这时候就需要将int型数据包装成interger对象。
Interger i=new interger（2）；//这样就将一个基本数据包装成i这个interger对象。这称为自动打包。现在不需要这样人工手动进行包装了，JDK会自动进行包装。
可以直接：Integer i=2；即可。
但是打包成对象之后，会导致操作效率下降。

当将一个对象赋给一个基本数据类型的时候，会自动进行解包。
int a=i；//这样就将一个对象进行解包了。
相当于：int a=i.intvalue();//现在可以自动转换，不需要再使用函数进行人工转换了。
另外，在对对象进行增、减操作的时候，也会自动进行解包，增减操作之后再进行打包。
i++；//先解包，然后对里面的基本数据进行增减操作，然后再打包。

基本数据“==”判等的时候，是判断数据大小的。
数据包装器“==”判等的时候，是判断类变量所指向的内存位置是否相等。
那么在数据包装之后的类对象进行判等就需要使用equal方法进行。
打包和拆包是编译器的事，不是虚拟机的事。编译器在生成打包后的类的时候，会生成一些字节码，加入必要的方法调用。虚拟机只是执行这些字节码。
使用基本数据包装器的好处是：可以将一些需要使用的基本方法放在对象中，因为基本数据类型中是不能自己添加方法的。所以包装成对象之后，就可以添加自己想要的方法。
 例如：将一个数值字符串转换成基本数据类型。这样就可以在包装后的类中添加必要的方法以实现这一点。
包装器对象时不可变的，也就是说基本数据类型被包装之后，就不能够被修改了。这个对象里面的内容就固定了。

Java基本类型的包装类。
byte->Byte;
short->Short;
……

在JDK1.5之后，基本类型的数据值可以直接当成对象，被类型引用变量引用。因为JDK1.5之后提供了自动装箱、解包功能，将基本数据类型数据包装成对象（被当成它的包装类使用）。也可见对象当成它的基本数据类型使用。
Eg：
Object a=3；//3这个基本数据类型值直接被a这个引用变量引用。
Integer a=2；//这也是对的，会自动将2这个基本数据包装成Integer类型。

还会自动将包装类的对象解包成基本数据。这是没有问题的。
int b=a；//这样自动将a这个对象解包成int这个基本数据类型。

由于包装和解包极其方便，所以现在很少直接使用int、double这种基本数据类型。而是使用包装的类。因为包装类使用更加方便。

对于所有的基本类型包装类，在1.7之后，添加了一个新的方法static compare（）；
Eg：
compare（Double a，Double b）：

#Java中的方法栈及内存模型
-------------
任何一个方法里面声明的变量，都是存放在这个方法的栈里面，有很多的栈，每个方法都有自己的栈。方法运行结束就会释放这块内存。栈内存只是一个临时内存。
基本数据类型变量和变量值都是放在方法的栈中。
引用类型变量也是放在方法的栈中，这个变量引用的对象是放在堆中的。每个Java虚拟机只有一个堆内存，一般默认是64M，但是可以在运行java程序的时候进行设置。只要JVM不退出，堆内存就一直存在。Java -Xms256：就是设置为256M。堆内存中的对象只能通过引用来访问。
例如：数组类型变量存放在栈中，数组这个对象本身时存放在堆中的。
Java中并没有真正意义上的数组。所谓的二维数组，只是若干数组引用变量构成的一个新的数组。

二维数组的特殊之处：内含的一维数组的首地址也就是一维数组的引用变量被存放在堆内存中。然后这个引用变量指向堆中的另一块空间中的数组。而不是如一维数组中的那样放在栈中，所以：一个引用并不一定是放在栈中，还有可能放在堆中。

Eg：二维数组的使用：
int[][] a=new int[4][];
a[0]=new int[]{1,2};//一维数组的引用。依次确定各维数组地址。a[0]就是一个引用变量。指向一个数组。
…… 
总之，N维数组的元素就是n-1维数组的引用变量。如此递归，一直向下引用。


操作数组的Arrays类，这是一个工具类，用于操作数组。
都是一些static方法，Arrays.search(a,5);//在数组a中查找一个数据5

数组引用变量被从栈中销毁之后，数组对象本身时不一定会立刻从堆中销毁（不会随着数组引用变量而回收）。
而是依靠GC（垃圾回收线程），来自动销毁堆内存中的对象。它的原理就是：GC会自动记录堆内存中对象是否有引用变量引用它。会在合适的时候回收该堆内存的位置。 

内存泄露：内存被占用，但是没有被收回，导致内存泄露。
还有一种情况：内存还需要继续被使用，就直接收回了这个内存。
这两种是编程中常见的内存问题。C语言中尤为常见。Java中概率小很多。
Java中引用实际上就是指针。只不顾对指针进行了包装，使其使用更为安全。

char ch =”0”;
int num=ch;//这样num就是48；是一个int，可以自动转换的。如果在数组中第0个元素对应为为“0”；那么转换的时候就是num-48，这样才行。

Java中对象的内存管理步骤：
在堆中开辟一块permenant空间，用于储存类的static部分。
创建对象引用变量，放在栈中。
创建引用的对象本身，这个对象放在堆中，对象自有的（不是类所有的）成员变量也放在这个对象中，就是在堆中。
调用方法时，方法中的局部变量放在栈中。





注意：集合框架里面只能放对象，而不能放普通的变量类型，也就是说，只能放Integer，而不能放int类型。