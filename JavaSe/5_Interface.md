#Java中的接口
----------------
接口的功能非常丰富，因为接口往往是和设计模式结合使用的。  
接口的概念：  
可以认为接口是一种彻底的抽象。  
是从多个相似的类中抽取出来的一种规范。可以认为接口是一种规范。  
接口体现的是通信的规范。例如电脑主板上的插槽，就是因为这些插槽都遵循统一的通信规范，所以也称之为接口。  

接口的定义：

	[修饰符] interface 接口名
	{
	　　0-n个field；
	　　0-n个抽象方法；
	　　0-n个内部类、内部接口、内部枚举定义；
	}
接口实现的只是一个规范，表示某一种功能（仅是表示一个功能而已），而不代表一个实体，是一个比抽象类更抽象的东西，只表示一个功能，任何implement这个接口的类都具有了这个功能。  

接口不能有构造器，也不能有初始化块。  
一般只有内部类自己本身才会使用private或者protected修饰符。外部类自己只能使用public或者defaule修饰符。  

##interface自身的修饰符
public|未写。因为其不能作内部的东西。因为类的修饰符就是public或者未写。见：Java中访问权限。Final修饰符也不行，因为interface中存在抽象方法。也没有abstract修饰符。Interface比abstract更加抽象。  
接口名用形容词。接口代表它可以做某一件事情（具有某一项功能）。  
##接口里面field的修饰符
public static final三个。默认的就已加上了这三个修饰符。自己不能进行修改了，要么不写，要么写这三者中的一部分。即使自己写了别的也就只是在这三者基础上加。 所以，field必须在定义的时候就赋与初值。因为有final、static修饰，所以必须由程序员来赋初值，但是没有初始化块，而且static变量不能在构造器中初始化。  
##接口里的方法修饰符
默认修饰符：public abstract，不能用static进行修饰，因为abstract不能与static同时修饰。也不能有final修饰符。同样不能进行修改。限定死了。所以方法必须没有方法体。也就是是说接口是个更抽象的东西，里面的方法必须没有方法体。都是抽象方法。  
##接口里的内部类、内部接口、内部枚举
默认修饰符：public static。不能修改。  


注：为什么接口的field、方法、内部类等这些都是采用public进行修饰？
Answer：因为借口的作用就是让别人使用这个功能，所以必须对外开放，所以都有默认public。
总之，接口内部和接口本身的修饰都可以不写，而使用自己默认的。写不写效果一样。

一个类只能有1个父类。但是一个接口可以有n个父接口。

对于一个java文件而言，里面只能有一个public类，运行的时候，会自动装载这个public类，然后装载这个public类中的static成员（包括static成员方法与变量），装载static void main方法的时候，就会自动从这个main方法开始执行。所以，java成员能够运行的道理，从要运行文件中的唯一一个public类开始，从这个public类的static main方法开始执行。

同样，对于，一个java文件而言，只能有一个public interface。其余都是默认的为空。可以将接口理解为一种特殊的类。是一种彻底抽象的类。

##接口的使用
接口可用于定义引用变量，但是不能用于创建实例（接口定义的引用变量可以引用它的子类对象，这时就相当于向上造型，当然，进行向上造型后获得的接口定义引用变量，可以对其进行强制类型转换，变为实现类的类型，然后调用实现类中的所有成员方法）。接口里面不能有main方法子类的，也就是说，接口里面的任何方法都必须借助实现了接口的类的对象来调用，而不能通过接口调用，因为接口极其抽象，无实体。接口里的方法不能是static。

接口最大的用处就是供其他类来实现：implements。就是使得这个类具有接口所代表的功能。注：一个类可以同时实现n个接口。可以弥补java单继承的不足，相当于模拟了多继承。当实现类中实现了接口之后，就会获得接口中所有的抽象方法。由于接口中所有的方法都是抽象的，所以实现类中要么为所有的这些抽象方法提供实现，要么这个实现类继续做抽象类。

接口主要是在面向接口编程的时候有用。

注意：类实现接口时，由于接口中的方法默认的权限是public，而implements的要求被实现后的方法的权限比原来接口中的方法权限更大，所以，在类中实现接口中的方法的时候，该方法的权限必须加上public，否则就是空，空权限小于public，不符合implements的要求。

注：在方法的调用中，编译时类型由引用变量类型决定，运行时类型是由引用变量引用的对象决定。在调用一个方法的时候，首先要保证编译能通过，那么就要保证这个被调用的方法是引用变量类型的成员方法（即使是抽象方法亦可）。  
然后到了运行的时候，再根据引用变量所引用的对象类型来决定该引用哪一个成员方法（是父类的方法还是子类重写的方法？）。  
接口与抽象类之间的共同点与区别  
二者都可以保护抽象方法。  
都不能创建实例。  
子类继承抽象类、实现接口时，都要求实现所有的抽象方法，否则子类也只能是抽象类。  
接口里面只能有抽象方法（默认即是如此），抽象类里面可以没有抽象方法。  
接口里面没有静态方法（因为是默认abstract的，所以不能有static的）。但抽象类里面可以有静态方法。  
接口里的field都是public static final；但抽象类中是普通的。  
接口无初始化块，抽象类中可以有。  
接口中无构造器，抽象类中可以有。  
接口可以n个父接口，抽象类只能有一个父类。  


#Java中的内部类、内部接口、枚举
----------------------
##枚举：一种实例数固定的特定类。
Eg：
性别这个类，只有两个实例。  
行星这个类，只有八个实例。  
这些类，不同于一般的类，他们的实例数只有已知的那么几个。  

##内部类：把一个类在另一个类里面进行定义。
所谓的内部类，就是表面外部这个类具有内部类这个东西。内部类不是表示外部类的某个属性的。而是表示外部类本身所具有的具体的零件，是具体实体的一部分。  
例如：  
牛具有一项属性：名字，那么bull这个类具有一个属性name，那么程序语言的表示上就是：has a的关系，也就是说bull类有一个field是String字符串。这是表示某个类的属性的表示方法，作为一个field表示。  
但是如果是牛具有某一个零件，如，牛具有角，那么这个角对于牛这个类来说就不能如牛的名字哪样表示成一个内部拥有的属性了。而是应表示成牛这个类的内部类。  

要注意：外部类不能用private修饰，也不能被protected修饰。因为在外部类本身之外并无外部类（这个外部类只是属于包）。所以这两个修饰符并无意义。也不能使用static修饰，不属于某个类。  
但是，对于内部类而言，其处于外部类的里面，所以对于内部类而言，private、protected这些修饰符是有意义的，所以其修饰符可以是这个三种中任何一个。也可以使用static修饰。有static修饰的内部类属于外部类本身。否则是属于实例。  

内部类上一级程序单元是外部类，外部类上一级程序单元是包。  
Java中，每一个类是一个文件，然后很多类编译出来的结果放在一起组成一个包。  

内部类的定义和普通类是一样的。内部类可以直接使用（需要加上外部类名.this或者外部类名.）外部类的属性、方法、构造器等，无论是private还是别的。  
同样，外部类的方法也可以使用内部类，也就是在外部类的方法中创建内部类的实例。通过这个内部类对象引用变量来调用内部类自己的方法。  
但是外部类不能直接使用内部类的成员（属性、方法等），而只能通过创建内部类对象来使用这个内部类的成员（属性、方法等）。不能直接使用。  
实际上，将内部类视为寄生类，将外部类视为宿主类，更容易理解。

注：编译之后，内部类的文件编译而成的class文件名变为外部类$内部类.class。

调用原则：
内部类本质是寄生类。
没有static修饰的内部类，寄生在外部类的实例里面。
所以在外部类的方法中创建内部类的实例时，实际上是使用：new this.mouth(),
当然实际上在外部类方法中创建内部类的实例时，使用的是：new mouth()这样的写法。那么外部类的static方法等就不能访问static内部类。
有static修饰的内部类，是寄生在外部类的类里面。如果，内部类是static修饰的，那么，外部类的static成员方法就可以直接使用static内部类了，而且这个static内部类是属于整个外部类的，所以不用通过外部类实例调用外部类方法，不用在外部类的方法中来创建内部类实例。当然这个static的内部类也不能访问非static的外部类成员。

内部类的使用：
内部类优点：提供更好的封装性。将外部类的零件直接封装起来，可以让外部完全对其义务所值。
在外部类里面使用内部类和使用内部类是同样的，没有特殊。
在内部类外面使用内部类时，分为static内部类和非static内部类两种情况。
在外部类之外使用非static内部类时，使用外部类.内部类+变量名声明内部类的引用变量。
Eg：outer.inner in;//这就是创建了一个内部类引用变量。

创建内部类实例对象的时候，要先创建外部类对象，然后再创建内部类的实例。
Eg：
Outer ot；//先创建一个外部类引用变量。
Ot.new inner(); 	//使用这个外部类引用变量来创建一个内部类的实例对象。

如果某一个类是继承了内部类，那么该怎样使用内部类？
寄生类的子类也是寄生类。它也需要一个宿主。
>
	Class innerSub extends outer.inner
	{
	   //内部类的子类的构造函数就是与众不同的。因为子类必须要调用父类的构造函数一次，所以这个调用就是一个问题。
		Public Innersub()
		{
			New outer().super();//对于这个子类而言会自动调用父类的构造器，但是我们知道其父类的构造器必须通过父类的对象来调用，而不能直接调用，所以要先创建一个父类的对象。    
		}
		Public innersub(outer out)
		{
			Out.super();
		}//父类是一个非static内部类，所以子类自动调用父类的构造器的时候，需要使用父类的寄主对象来调用父类的构造器。所以这里可以传入一个out寄主对象。
	}


B、在外部类之外使用static内部类的时候。
他可以直接通过外部类来进行调用，而不用像非static内部类那样创建宿主类对象来使用内部类。只有用到外部类，内部类就有了，因为内部类就是属于外部类的，而不是属于外部类对象。不需要程序员去关注宿主，因为他的宿主是天然就有的。

子类继承Static内部类的时候，寄主天生就有，就是外部类本身。使用的时候，可以将外部类当成内部类的一个包即可。
>
	Class innerSub extends outer.inner
	{
	   //内部类的子类的构造函数就是与众不同的。因为子类必须要调用父类的构造函数一次，所以这个调用就是一个问题。
		Public Innersub()
		{
			New outer().super();//对于这个子类而言会自动调用父类的构造器，但是我   们知道其父类的构造器必须通过父类的对象来调用，而不能直接调用，所以要先创建一个父类的对象。    
		}
		//或者：
		Public innersub(outer out)
		{
			Out.super();
		}//父类是一个非static内部类，所以子类自动调用父类的构造器的时候，需要使用父类的寄主对象来调用父类的构造器。所以这里可以传入一个out寄主对象。
	}


局部内部类：用得不多。因为意义不大（因为局部内部类的作用域太有限了，仅在方法里面有效，也导致使用比较简单）。了解一些即可。
局部内部类的作用就是：当我们在任何一个方法中某个地方时，需要使用一个新的类的时候，如，实现一个接口或者继承一个类的时候，这个时候就要临时创建一个类，这时候不必再在外面创建类，太麻烦，可以在这个地方现场创建一个类，实现接口或者继承其他的类。这样就是局部内部类的作用。当然，内部匿名类也是这个作用。
>
	Public int f（）
	{	
		Class pro 
		{
			……
		}
		//或者
		Class pro implements per
		{
			……
		}
	}


局部内部类的内容和普通类都是一样的。

局部内部类可以同名的，如，在不同的方法中，可以定义相同的内部类。
所以，局部内部类的class文件名为（每一个类都有一个文件，当然包括，内部类、局部内部类这些）：外部类+n（表示是外部类中第几个局部内部类）+局部内部类.class。以代表多个重名的局部内部类。


匿名内部类：适合于创建只需要一次使用的类。没有名字的类。
所以，程序以后无法再次访问这个匿名内部类。
当程序在创建这个匿名内部类的时候，会立即创建这个匿名内部类的实例。

实际上在一个地方要使用一个新的类对象的时候，与其使用局部内部类，还不如使用匿名内部类，更加方便，且效果好。
语法格式：
>
	new 父类接口（）|父类构造器//这个新的匿名内部类可以是实现父类接口
					  //或者继承其他类，都可以，只是用一种随要随造					 //的方式予以实现，无名。但是方便。
	{
		//类体部分
	}

以上的语法格式返回了匿名内部类的实例对象。以后就只能使用这一个创建的实例对象。
>
	interface walkable
	{
    	void walk();
	}
	public class 
	{
		public static void main(String[] args)
		{
			walkable w=new walkable()
			{
			int a=10;//这里的匿名内部类的意思就是：walkable与{}共同构成对walkable这个			 //接口的重载，然后加上new就创建了一个实现类的实例对象。再进行向上转		 //型,被接口定义的变量所引用。实际上单纯的接口是不能创建对象的。但			 //是，如果匿名内部类实现了这个接口，就可以用这个匿名内内部类创建实例		 //对象了。所以这里做了两件事：创建一个接口实现类、用这个接口实现类.
			@Override
			public void walk()
			{
				System.out.println("walk");
			}
			public void f()
			{
				System.out.print("f");
			}
			//实现接口的匿名内部类中可以有field、重写方法、方法、初始化块，但不能有构造
			//器，因为匿名内部类没有名字，没办法写构造器。
			/*
			 * 以上代码相当于：
			 * class walker implenments walkable
			 * {
			 *		int a=10;
			 *		@override
			 *		public void walk()
			 *		{
			 *			system.out.println("walk");
			 *		}
			 *
			 *		public void f()
			 *		{
			 *			System.out.print("f");
			 *		}
			 *	}
			 *
			 *	walkable w=new walker();
			 * /
		}；//注意匿名内部类这里有一“；”
	}
	}


就是说，原来实现一个接口，然后用这个实现类来创建一个类对象的工作可以通过匿名内部类的方法予以完成，在任何地方，随要随做，无需名称，很快完成。



匿名内部类规则：

1. 匿名内部类只能继承一个已有的类或者实现一个接口（而不能和普通的实现类那样实现多个接口）。
2. 匿名内部类必须实现接口或者父类的所有抽象方法，因为，匿名内部类不能是抽象的。因为创建这个匿名内部类之后就需要立刻创建实例。
匿名内部类没有构造器，因为没有类名，但是可以有初始化块。

本质上来看：类、枚举、接口都是同一级的概念。  
抽象性：类<内部类<接口。  
