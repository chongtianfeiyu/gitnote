#Java中的多态
-------------
多态：可以使父类引用变量引用一个子类对象。使用的时候，依旧是使用父类引用变量来调用子类的方法。
所谓的态：行为、特征。
所谓的多态，就是同一个引用变量（如父类引用变量），在调用执行同一个方法的时候，表现出各种不同的行为特征。

多态实现的原因：
java中引用变量的类型有两种：
编译时类型：这就是写源代码时声明的引用变量类型。
运行时类型：决定于实际运行时这个引用变量所引用的对象。
如果，某引用变量的编译时类型与运行时类型不一致，就可能导致多态。
所以这样一来，两个编译是类型一样的引用变量，由于实际运行时类型不同，导致他们在调用相同的方法时，呈现不同的行为特征，这就是多态。
在编译的时候，编译器将父类引用变量视为父类变量。
在运行的时候，JVM将父类引用变量视为子类变量。

但是必须注意的是：多态针对的只是继承中那些在子类中已经重写的方法，而对于不是重写的方法，并不能体现多态的特性。也就是说，不能用父类引用变量来调用子类中新加入的方法。如果使用父类引用变量来调用子类中新加入的方法，就连编译都没办法通过。
因为：
在编译的时候，编译器将父类引用变量视为父类变量。
在运行的时候，JVM将父类引用变量视为子类变量。

#Java中引用类型的强制类型转换
-----------------
向下造型：也就是强制类型转换：
那么怎样让父类引用变量能够调用子类新加入的方法呢？
当一个父类引用变量引用了一个子类对象的时候，这就是所谓的向上造型。是自动进行的。

那么怎样让这样的一个父类引用变量调用子类新加入的方法？
就要采用向下造型。强制将父类引用变量转换为子类引用变量，这样就可以通过新的子类引用变量来调用子类新加入的方法了。
使用向下造型的前提是父类引用变量是通过子类对象向上造型而得来的。

强制转换的原理：
是使得原来的父类引用变量的编译时类型发生改变，变成了子类的引用类型。
而父类引用变量的运行时类型无需发生改变，因为原来的运行时类型就是子类类型。


强制类型转换的注意点：
基本数据类型中，除了boolean类型，其他类型都可以使用强制类型转换来实现大空间向小空间的转换。
引用类型中，只能在具有继承关系的两个类型间进行转换（父类引用变量转换为子类引用变量）。否则在编译的时候即会报错。而且将父类引用变量转换为子类引用变量之前，必须保证这个父类引用变量确实是引用一个子类对象才可以进行下面的转换。

`instanceof()`:用于判断前面的前面的引用变量是否引用后面类型的实例。
注意：使用这个函数时：要么前面的引用变量引用了后面类型的变量，要么二者有继承关系。否则编译时会报错。
Eg：
1

	Class A extends B；
	B b；
	b instanceof A；//false，二者具有继承关系。


Class A extends B；
B b；
b instanceof B；//true，b引用变量引用了后面的类型的实例。

	
Class A extends B；
B b；
b instanceof M；//会编译报错。因为b引用对象既不是M类实例，也与M类没有继承关系。

Java中常见异常
NullPointerException：空指针引用异常。
ArrayIndexOutOfBoundary：数组越界异常。
ClassCastException：类型转换异常：非引用子类对象的父类引用变量转换为子类引用变量发生异常。

#Java中编译类型
------------------
一个误区：
在继承中，如果子类新加入了一个与父类同名的成员变量，不会覆盖父类的成员变量，而是子类拥有了两个同名的成员变量。那么在通过子类或者父类引用变量来调用该名字的成员变量的时候，具体是调用了哪一个成员变量，决定于这个引用变量的编译是类型（到底是子类引用变量还是父类引用变量）。
示例如下：
>
	Class A
	{
 		int a=10；
	}
>
	Class B extends A
	{
 		int a=20；
	}//这样B类中有两个a成员变量，一个是10，一个是20.
>
那么，使用时，
>
	B b=new B();
	b.a;//这里输出的是20这一个成员变量，因为这里引用变量的编译时类型是B。
	A b=new B();//发生向上造型
    b.a;//这里输出的是10这一个成员变量，因为这里引用变量的编译是类型是A。
    
    
#Java中的方法重写
--------------------
方法重写：重写后的方法：两同、一大、一小。
方法名、参数列表相同。
访问权限更大或者相等。
返回值类型更小或者相同。子类抛出的异常要更小。

在重写方法前面加上：@override，可以在编译的时候，让编译器强制检查重写的方法有无错误。没有别的用处。
super：用于调用父类的方法或者某一个构造器。
注意：方法会有重写，但是成员变量没有重写（即使子类有父类中同名的成员变量，也依旧不是进行覆盖，而是子类中有了两个同名的该成员变量），也就是说不能在子类中覆盖父类中国的某个成员变量，而是必须在构造器中进行初始化。
在子类中无法区分到底是使用子类还是父类中的同名成员变量、方法。默认的是访问子类中的，也就是说默认是加上了this。那么如果要使用父类的成员变量、方法，可以使用super关键字。
在使用this或者super作构造器调用的时候，都必须放在构造器的第一行。而且this与super调用构造器是不能同时出现的。
如果没有人为调用父类的super或者this构造器构造器，机器会自动调用父类的无参构造器。
否则会人工调用对应的构造器。


关于重写：
父类中的public方法可以被子类重写。
父类中的private方法不能被子类重写。因为根本就无法访问，更不必说重写了。
父类中protected方法能被子类重写。
父类中为表明访问权限的方法不能被处于不同包中的子类重写。
Eg：

     class newer
	{
	int a=10;
	private void f()
	{
		System.out.println(10);
	}

	}

    class newTest extends newer
    {
	private void f()
	{
		System.out.println(100);
	}  //这是newTest自己新建的方法，而不是重写了newer类中已有的方法。即使他们是同名的方法。
	public static void main(String[] args)
	{
		newTest n = new newTest();
		n.f();
	}
	}


