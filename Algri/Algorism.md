#字符串反转
##暴力反转法
##三步反转法




思路之可有，灵感之可无

#看到判断集合中是否包含某个(些)元素、求集合中元素的个数，判断个数的多少，第一个、第二个等，都要立即想到素数法。素数法用于解决元素各有各的特征的那些情况。用于求解判断包含关系的题目。

#看到求对称(对称就是只考虑偶数个)，求回文(回文就是要分奇偶个数的对称)，都要立刻想到中心移位法。

#看到旋转，倒装，都要立刻想到先切开，再各部分旋转，再旋转整体的方法。


笔试和面试中，除了字符串，另一类出现频率极高的问题便是与数组相关的问题。在阅读完第1章和本第二章后，读者会慢慢了解到解决面试编程题的有几种常用思路。  
首先一般考虑“万能的”暴力穷举（递归、回溯），如求n个数的全排列或八皇后（N皇后问题）。  
但因为穷举时间复杂度通常过高，所以需要考虑更好的方法，如分治法（通过分而治之，然后归并），以及空间换时间（如活用哈希表）。  
此外，选择合适的数据结构可以显著提升效率，如寻找最小的k个数中，用堆代替数组。  
再有，如果题目允许排序，则可以考虑排序。比如，寻找和为定值的两个数中，先排序，然后用前后两个指针往中间扫。  
而如果如果已经排好序了（如杨氏矩阵查找中），则想想有无必要二分。  
但是，如果题目不允许排序呢？这个时候，我们可以考虑不改变数列顺序的贪心算法（如最小生成树Prim、Kruskal及最短路dijkstra），或动态规划（如 01背包问题，每一步都在决策）。  
最后，注意细节处理，不要忽略边界条件，如字符串转换成整数。




如何查找一个集合中最小的、最大的、最高的、最……的k个元素。或者找到一个集合的第k大的元素  
这个问题的关键是，不需要全部排序，只需要拍前k个元素即可。转化问题就是找到最大的k个元素。只需要是最大的k个即可，而不管这k个是否都排好了序。  
这个问题也就是求全集合中的部分元素的排序问题。不需全部排序，只需局部排序，也就是找一个小集合存放，然后与外部进行比较即可。  
1. 进行时集合中的元素可以比较大小(例如给每一个元素赋以)，然后进行快速排序，取前面的相应个元素。这里的浪费只处在于，对所有的元素都进行了排序，实际上只需要前面的k个，所以不必对所有的元素都进行排序。  
2. 先遍历集合取前k个元素，将这k个元素放在一个新集合中，然后交换法找到这新集合中最大(最小)的一个元素。将新集合之外的所有元素与这个最大的元素进行比较，如果小于新集合中最大的元素，就进行交换。交换之后，再查找新集合中最大的哪一个元素。再去外面进行比较。如此一趟一趟地进行比较查找交换即可。  

类似于跳台阶问题怎么解决？
当告诉我们做一件事每一步都有若干种选择的时候，例如，上台阶，每一步可以上一阶也可以上两阶，问总共有多少种上法。这个时候，可以进行问题的分解。确定第一步有两种上法，剩下的问题就变小了，这样就可以使用递归法进行求解。类似与fabinacci数列的方法。这就是问题的缩小化解决。先找出自己能够确定的部分，再寻找剩下的不能确定的部分的规律。




排序法：
1. 冒泡排序，原理就是，从前向后扫描，将一路上所能找到的最大的数交换到后面去(进行比较同时还要进行交换)。不断的交换。交换直至不再能交换为止。O（n*n）;  
2. 选择排序，原理就是，从前向后扫描，查找选择一路上最大的元素(进行比较但是不会交换，只是将最大的元素记住)，然后将这个最大的元素与最后位置上的元素直接交换，而不是一路边比较边交换。O(n*n);