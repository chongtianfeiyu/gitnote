#Java中类的原型
-----------------
一个类中最多有5个部分：

    修饰符 class 类名
    {
    　　//0-n个field定义；
    　　//0-n个方法定义；
    　　//0-n个构造器定义；
    　　//初始化块（static块）……
    　　//内部类、内部接口、枚举等。……
    }
如果多于5个即为错误的类。


Field定义：注：[]表示可以省略；
[修饰符]+类型+field名+[=默认值];
修饰符：public|protected|private, static，final。
类型：基本数据类型，数组，类（JDK中的类或者自定义类），接口，枚举。

方法定义：
[修饰符]+返回值类型+方法名(0-n个参数)
{
……
}
修饰符：public|protected|private, static，abstract|final。Abstract与final相反。
返回值：基本数据类型，数组，类（JDK中的类或者自定义类），接口，枚举，void。


构造器定义：
[修饰符]+构造器名（0-n个参数）
{
……
}
修饰符：public|protected|private;
构造器的作用：初始化类的实例，也就是初始化对象。

初始化块：
1、[static]
{
　　//可执行语句。
　　//类初始化块。专门用于初始化类拥有的成员变量，也就是static成员变量。
}

Eg：
`Public class A
{
　　static int age；
　　
　　Static
　　{
　　Age=10；//类初始化块。
　　}
}`


2、如果没有static，就是实例初始化块。
{
　　//可执行语句。
　　//实例初始化块。专门用于初始化实例拥有的成员变量，也就是非static成员变量。
}
Eg：
Public class A
{
　　int age；
　　{
　　Age=10；//实例初始化块。
　　}
}
　　
注：初始化块是自动调用的。不能被认为调用。

为什么要定义初始化块？
对于一个类而言，会有许多个构造器，这些构造器中互相有一些重复的初始化语句，这样就会加大代码量。所以，可以将这些重复的初始化语句放在一起，构成一个初始化块，让这些重复的初始化语句对于每一个对象或者类都自动执行。就可以减小代码量。这就是初始化语句的作用。
但是：只有处于构造器中前面的初始化语句才可以放在初始化块中，而不是跳跃式放入初始化语句。

Java中允许多个实例初始化块，但没有意义！


什么是实例初始化块的工作原理？
在编译中，所有的实例初始化块都会被还原到相应的构造器中，然后直接调用构造器即可。因此在汇编代码中并没有初始化块的痕迹。
同时，要注意的是：在声明成员变量时赋给的成员变量的值也是不会在汇编代码中留下痕迹的。也就是说，声明成员变量是赋给成员变量的初始值也会在汇编的时候直接插入到相应的构造函数中。

总之，初始化块中对成员变量赋值与成员变量声明时所赋的值都是一种假象（不包括static初始化块和static成员变量）。他们都是在编译的时候被直接插入到构造函数中（放在构造器的最前面。初始化块与成员变量赋值在构造器中具体哪一个放在前面决定于代码中哪一个放在前面，放在前面的在构造器中放在前面。），然后通过调用构造函数来进行起作用的。


类初始化块的工作原理？
类初始化块在类被加载的时候执行。对类拥有的field进行初始化。不会对所有的对象都执行，总共只执行一次。

static成员变量声明时赋值会在编译的时候插入到static初始化块中，然后执行static初始化块即可。插入位置与在代码中相对位置有关。这一点是不同于实例初始化块（实例成员变量和实例初始化块都一起插入到构造函数中）

那么初始化块代码在什么时候执行？
实例初始化块在每次调用构造器之前自动执行。而且实例初始化块与实例成员变量会在编译时直接插入到构造器中最前面，然后直接执行构造器即可。
类初始化块在类加载的时候就执行。而且类成员变量会被直接插入到类初始化块中，直接执行类初始化块即可。


Static:实际上并不是静态的意思。也不是公共的意思。而是一个标志，表明这个成员变量是属于这个类的。而不是属于某个对象。
在创建类对象之前，就将整个类加载到内存中，加载过程中，就将属于这个类自己的东西加载到堆中的某一个区域（叫做：permanent区）。也就是说，还没有分配对象的空间（构造器启动之前），就已经为static成员分配堆中的空间了。
总之：static修饰的属性、方法根本就不属于对象的，就是说，任何一个对象根本就没有这个static属性、方法。即使允许通过对象来访问static属性、方法。但是这只是一个语言设计上的错误、缺陷。实际上这个static属性、方法根本就不属于任何对象。只属于类。考试的时候常有这样的题目作陷阱。
　　
static方法也是属于这个类的。而不是属于某一个对象。也就是说，永远不要用某一个对象来调用static方法，因为对象根本就不永远这个static方法。

注：只要用到了一个类，那么就会初始化static部分，
Eg：person p；//这样就是用到了person这个类，就是加载了person这个类，该类拥有的成员变量就会进行初始化。
而且初始化是从顶层向下层的顺序进行的。

Java中所有的引用如果是被JVM初始化，那么全部被初始化为null；没有指向任何的有效内存区。
类属性、方法（static修饰）与实例属性、方法（非static修饰）是不一样的。

注意：永远都不要使用对象来调用Static修饰的类方法、类属性。如果别人的程序中有使用对象来调用static修饰的类方法、类属性时，首先就要把这个对象换成类。然后再继续看。
这种题目经常出现在面试考题中，所以要注意这个问题。一定要使用类来调用类方法、属性。而不是对象。

局部变量，既不属于类也不属于对象，所以永远不能用static修饰。

注：java方法中怎样传入多个参数？不知道有多少个。

    void f（int... Nums)
    {
    　　Nums[1]……；
    　　Nums[2]……；
    }//int后面加...,表明传入多个int。在方法中nums相当于一个数组引用。
参数个数可变的方法只能参数中可变的参数只能有一个。也就是说nums只能有这一个数组，而不能又有第二个多参数组。本质就是数组，实际上不怎么使用，不如直接传入一个数组引用。
　　
　　
`    Person p = new person();//注意：此中new才是创建对象，构造函数是对对象拥有的成员变量``进行初始化。二者功能是不同的。`

Java中this关键字
------------
this关键字用法：
this引用：在任何地方都可以使用this引用来调用非static方法。非static方法属于对象。
this调用：只能在构造函数第一行进行调用，用于调用本对象其他的构造函数。
在本类的方法中使用本对象的成员变量时，最好将this留下来。包括在构造函数中亦是如此。

this调用：使用this（）调用另外一个构造器。This()相当于一个构造器。
this引用：使用this.name;这是调用一个成员变量。

Java中递归
------------------

递归方法：
递归方法里面，实际上包含了一个隐式的循环。
递归方法就是再次调用自己，朝向已知的方向调用。

Java中重载
--------
方法的重载：
两同一不同：返回值相同，方法名相同。参数不同。
方法重载与返回值类型、是否static没有关系。
Java中访问权限
Private:当前类访问权限。
Protected:子类访问权限。
Public：公共访问权限。
没有设置访问权限：包访问权限。希望在同一个包中可以访问。
局部变量不能用这些修饰符修饰的原因：局部变量应该只在这个方法中有效，本来作用域就很想。所以就不需要使用修饰符限制使用范围了。

注：整个类是属于包的。也就是说类自己的修饰符可以省略。只能有一个类使用public修饰。就是主类。
如果这个类前加了public，那么在包内（package）和包外都可以访问。
如果用private等修饰，就没有意义了。
类名修饰符：public\final\abstract之一。

总之：
成员方法与变量的权限修饰符为：
Public：所有地方都可访问。
Private：本类内部可以访问，外部都不能访问。
Protected：本类内部和子类中可以访问，其他都不能访问。
未写：本包内可以访问，包外都不能访问。
所以，成员方法与变量的权限修饰符是public|protected|private|未写。

类的权限修饰符为：
Public：所有地方都可以使用这个类。
不能是Private：因为这个类不在其他类里面，所有设置为private之后，这个类就不能被使用了，因为private只能被本类内部使用。
不能是protected：因为这个类不在其他类里面，因为protected只能被子类所用，这个protected类不在另一个类中，所以他不能被另一个类的子类所使用。
未写：这个类可以被同一个包中的任何东西访问。
所以，类的权限修饰符只能是public或者未写。
Java中的包
包：命名空间的作用。将不同公司定义的同名类互相隔开。
所以，java中一个类的类名是：包名+类名。
定义包的语法：
Package 包1.包2.包3.……；

包名：用公司的域名的倒写。

要将一个类放在某一个包中需要：
在类的源代码中使用package指点放置目录路径。
生成的class文件必须放在package所声明的文件结构下面。可以手动建立package所声明的目录路径，然后将编译结果放进去。
还可以在编译的时候使用 javac -d . 源文件。这样-d选项可以自动创建package指明的目录路径，并将结果放在这个路径里面。也就是放在包里。

注意：在运行放在一个包中的class时，不再是java hi.  而应该加上包名：java hu.pi.hi。这样才行。
也就是说，运行包中的编译结果时，也必须将路径加上。而且当前目录必须在hu目录之外，不能进入包的路径中去运行class。必须在包的目录外运行（加上class的路径）。

总之，一旦为一个类加上了包名。那么这个类的名字就变为包名+类名。那么在任何时候使用这个类编译的class的时候，都必须使用包名+类名。如java命令运行这个class或者在其他源文件中import这个class的时候，均是如此。

使用这个类的时候，通过import包名来导入类。
还可以使用：import static java.lang.*;这就是JDK1.5后提供的静态导入。用于导入一个类中所有的static成员。
